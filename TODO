* Rename AST into ParseTree (or similar)

* Define a [Sampling] type-class

We can sample streams and histories. We would like to do so using a
single, common notation.

* Remove [sem_var_instant]

It's not really a semantic rule.

* Grep for "XXX:"  and "TODO:"
* Use type classes for predicates

Example: Is_free_*, Is_Defined_*, Is_Variable_*, clk_

* Prove the characterizing equivalence of [memories]

Cf. [NLustre/Memories.v]

* Do we really need [Ordered_nodes] and [NoDup]?

These are directly implied by [Welldef_global] and are used only in
situations where we have the stronger [Welldef_global] property.

* Defined Welldef_global as a zipper over a list of equations

So that we don't need to split the equations [alleqs = eqs ++ oeqs] in
the correctness proof.

* Extract a [Welldef_node] from [Welldef_global] 

Currently, [Welldef_global] contains constraints about a single node
as well as constraints about this node in the larger context. Extract
this in another predicate, [Welldef_global] including the new one.

* Repair the decision procedure for [WellFormed]

Use it in the Example

* Follow consistent naming

Follow the 'Implicit Type' declarations

* [Is_present_in] and [Is_absent_in] might not be necessary

Cf. branch 'dumb' for a construction that does not require a dedicated
inductive predicate.

* [equiv_env] is misleading

It is not an [equivalence], rather a [faithful] map.

* Allocate explicit identifiers to node instances.

Currently, the instance name of a node application
[y0, ..., yn = f(e0, ..., em)] comes from the first result variable, i.e.,
[y0].
This approach has two disadvantages.

(1) There is no way to translate calls with no return values.

(2) translate_eqn uses [hd Ids.default ys] which necessitates awkward lemmas
    and conditions to rule out the default case, e.g.,
    [not_Is_Defined_in_eq_stmt_eval_mobj_inv] and [non_trivial_EqApp].

