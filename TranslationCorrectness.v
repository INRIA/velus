
Require Import Rustre.Common.
Require Import Rustre.DataflowSyntax.
Require Import Rustre.DataflowNatSemantics.
Require Import Rustre.DataflowNatMSemantics.
Require Import Rustre.SynchronousNat.
Require Import Rustre.WellFormed.

(* ** Definitions on imperative statements *)

Require Import Rustre.Minimp.
Require Import PArith.
Require Import Rustre.Translation.

Import List.ListNotations.
Open Scope list_scope.

(* TODO:
   - Assume we are given a list of dataflow equations eqs satisfying
        sch_eqs (memories eqs) PS.empty (defined eqs) eqs
   - Show that the step function generated by translate_eqs is correct,
     i.e., that its semantics correspond to the 'held semantics' of the
     original dataflow equations.
   - The 'held semantics' use holdR rather than fbyR for defining 'fby'.
   - Basic invariant for a single pass (to show by induction along the list
     of dataflow equations/sequence of conditional assignments):
        forall x,
             (PS.In x (PS.inter memories written) -> M x = H x (S n))
          /\ (PS.In x (PS.diff memories written) -> M x = H x n)
          /\ (PS.In x (PS.diff written memories) ->
              H x n = present c -> p x = c)

   - Afterward, this must be extended to run (i.e., forall n from 0).
   - and we must switch back to the standard fby semantics for instants
     where a clock is active.
 *)

Example eqn1_well_sch: Is_well_sch (PS.add 1 (memories eqns1)) eqns1.
Proof.
  assert (well_sch (PS.add 1 (memories eqns1)) eqns1 = true) as HW by apply eq_refl.
  pose proof (well_sch_spec (PS.add 1 (memories eqns1)) eqns1) as HS.
  rewrite HW in HS.
  assumption.
Qed.

Example eqn2_well_sch: Is_well_sch (PS.add 1 (memories eqns2)) eqns2.
Proof.
  assert (well_sch (PS.add 1 (memories eqns2)) eqns2 = true) as HW by apply eq_refl.
  pose proof (well_sch_spec (PS.add 1 (memories eqns2)) eqns2) as HS.
  rewrite HW in HS.
  assumption.
Qed.

Inductive Is_present_in (mems: PS.t) (menv: memoryEnv) (env: constEnv)
  : clock -> Prop :=
| IsCbase: Is_present_in mems menv env Cbase
| IsCon:
    forall ck c v,
      Is_present_in mems menv env ck
      -> exp_eval menv env (tovar mems c) (Cbool v)
      -> Is_present_in mems menv env (Con ck c v).

Lemma exp_eval_tovar_Cbool_dec:
  forall menv env mems c v,
    {exp_eval menv env (tovar mems c) (Cbool v)}
    + {~exp_eval menv env (tovar mems c) (Cbool v)}.
Proof.
  Ltac no_match := right; inversion_clear 1; try unfold find_mem in *;
                   match goal with
                   | H: PM.find _ _ = _ |- _ => rewrite H in *; discriminate
                   end.
  intros menv env mems c v.
  unfold tovar.
  destruct (PS.mem c mems).
  - case_eq (find_mem c menv).
    + intro c0; destruct c0.
      * no_match.
      * destruct b; destruct v; (left; apply estate; assumption) || no_match.
    + no_match.
  - case_eq (PM.find c env).
    + intro c0; destruct c0.
      * no_match.
      * destruct b; destruct v; (left; apply evar; assumption) || no_match.
    + no_match.
Qed.

Lemma Is_present_in_dec:
  forall mems menv env ck,
    {Is_present_in mems menv env ck}+{~Is_present_in mems menv env ck}.
Proof.
  intros.
  induction ck.
  - left; constructor.
  - destruct IHck.
    + destruct (exp_eval_tovar_Cbool_dec menv env mems i b); destruct b;
      (left; constructor; assumption) || right; inversion_clear 1; auto.
    + right; inversion_clear 1; auto.
Qed.

Lemma exp_eval_tovar:
  forall x v menv env memories,
    exp_eval menv env (tovar memories x) v
    <-> (exp_eval menv env (State x) v /\ PS.In x memories)
        \/ (exp_eval menv env (Var x) v /\ ~PS.In x memories).
Proof.
  split; intro Heval;
  destruct In_dec with x memories as [Hxm|Hxm];
    pose proof Hxm as Hxmt;
    apply PS.mem_spec in Hxmt || apply mem_spec_false in Hxmt;
    unfold tovar in *;
    rewrite Hxmt in *;
    intuition.
Qed.

Lemma stmt_eval_translate_eqns_cons:
  forall prog mems menv env menv' env' eq eqs,
    stmt_eval prog menv env (translate_eqns mems (eq :: eqs)) (menv', env')
    <->
    (exists menv'' env'',
        stmt_eval prog menv env (translate_eqns mems eqs) (menv'', env'')
        /\ stmt_eval prog menv'' env'' (translate_eqn mems eq) (menv', env')).
Proof. (* TODO: redo proof *)
  split.
  - intro H.
    unfold translate_eqns in H.
    simpl in H.
    apply stmt_eval_fold_left_shift in H.
    destruct H as [menv'' [env'' [H1 H2]]].
    exists menv'', env''.
    split; [now apply H1|].
    inversion_clear H2.
    inversion H0.
    subst.
    exact H.
  - intro H.
    destruct H as [menv'' [env'' [H1 H2]]].
    unfold translate_eqns.
    simpl.
    apply stmt_eval_fold_left_shift.
    exists menv'', env''.
    split; [now apply H1|].
    eapply Icomp. apply H2.
    apply Iskip.
Qed.

Lemma stmt_eval_Control:
  forall prog menv env mems c s menv' env',
    stmt_eval prog menv env (Control mems c s) (menv', env')
    -> (Is_present_in mems menv env c
        /\  stmt_eval prog menv env s (menv', env'))
       \/ (~Is_present_in mems menv env c /\ menv' = menv /\ env' = env).
Proof.
  Hint Constructors Is_present_in.
  intros prog menv env mems c s menv' env' Hs.
  induction c.
  - intuition.
  - destruct (Is_present_in_dec mems menv env (Con c i b)) as [Hp|Hnp];
    [ left | right ];
    destruct b; inversion_clear Hs;
    try match goal with
        | H:stmt_eval _ _ _ (Control _ _ _) _ |- _ => apply IHc in H;
            destruct H; destruct H
        | H:stmt_eval _ _ _ Skip _ |- _ => inversion H
        end;
    try match goal with
        | Hn: ~Is_present_in _ _ _ _, H: Is_present_in _ _ _ _ |- _ =>
          inversion_clear H; contradiction
        end;
    try (inversion_clear Hp;
         match goal with
         | H0: exp_eval _ _ _ (Cbool false),
           H1: exp_eval _ _ _ (Cbool true) |- _ =>
           discriminate (exp_eval_det _ _ _ _ _ H0 H1)
         end);
    try match goal with
        | Hm: menv = _, He: env = _ |- _ => rewrite Hm, He in *
        end;
    auto;
    contradict Hnp; auto.
Qed.

Lemma stmt_eval_translate_cexp_menv_inv:
  forall prog menv env mems x menv' env' ce,
    stmt_eval prog menv env (translate_cexp mems x ce) (menv', env')
    -> menv' = menv.
Proof.
  intros prog menv env mems x menv' env'.
  induction ce using cexp_mult
  with (P := (fun cae : caexp =>
           stmt_eval prog menv env (translate_caexp mems x cae) (menv', env') ->
           menv' = menv));
  (apply IHce || inversion_clear 1); auto.
Qed.

Lemma stmt_eval_translate_cexp_env_add:
  forall prog menv env mems x menv' env' ce,
    stmt_eval prog menv env (translate_cexp mems x ce) (menv', env')
    -> exists c, env' = PM.add x c env.
Proof.
  intros prog menv env mems x menv' env'.
  induction ce using cexp_mult
  with (P := (fun cae : caexp =>
          stmt_eval prog menv env (translate_caexp mems x cae) (menv', env') ->
          exists c, env' = PM.add x c env));
    (apply IHce || inversion_clear 1); auto.
  exists v; rewrite <- H1; intuition.
Qed.

Lemma not_Is_memory_in_eq:
  forall prog x eq menv env mems menv' env',
    ~Is_memory_in_eq x eq
    -> stmt_eval prog menv env (translate_eqn mems eq) (menv', env')
    -> find_mem x menv' = find_mem x menv.
Proof. (* TODO: Tidy proof *)
  intros prog x eq menv env mems menv' env' Hneq Heval.
  destruct eq as [y cae|y f lae|y v0 lae].
  - destruct cae.
    simpl in Heval.
    apply stmt_eval_Control in Heval; destruct Heval as [Heval|Heval];
    destruct Heval as [Heval1 Heval2].
    apply stmt_eval_translate_cexp_menv_inv in Heval2.
    rewrite Heval2. intuition.
    destruct Heval2 as [Hmenv]; rewrite Hmenv; intuition.
  - destruct lae.
    simpl in Heval.
    apply stmt_eval_Control in Heval; destruct Heval as [Heval|Heval];
    destruct Heval as [Hipi Heval].
    inversion_clear Heval.
    rewrite <- H2.
    reflexivity.
    destruct Heval as [Hmenv Henv]; rewrite Hmenv; intuition.
  - apply not_Is_memory_in_eq_EqFby in Hneq.
    unfold translate_eqn in Heval.
    destruct lae.
    apply stmt_eval_Control in Heval; destruct Heval as [Heval|Heval];
    destruct Heval as [Hipi Heval].
    inversion_clear Heval.
    rewrite <- H0.
    unfold find_mem, add_mem.
    simpl; rewrite PM.gso; [intuition | apply Hneq].
    destruct Heval as [Hmenv Henv]; rewrite Hmenv; intuition.
Qed.

Lemma not_Is_instance_in_eq:
  forall prog x eq menv env mems menv' env',
    ~Is_instance_in_eq x eq
    -> stmt_eval prog menv env (translate_eqn mems eq) (menv', env')
    -> find_obj x menv' = find_obj x menv.
Proof. (* TODO: Tidy proof *)
  intros prog x eq menv env mems menv' env' Hneq Heval.
  destruct eq as [y cae|y f lae|y v0 lae].
  - destruct cae.
    simpl in Heval.
    apply stmt_eval_Control in Heval; destruct Heval as [Heval|Heval];
    destruct Heval as [Heval1 Heval2].
    apply stmt_eval_translate_cexp_menv_inv in Heval2.
    rewrite Heval2. intuition.
    destruct Heval2 as [Hmenv]; rewrite Hmenv; intuition.
  - destruct lae.
    simpl in Heval.
    apply stmt_eval_Control in Heval; destruct Heval as [Heval|Heval];
    destruct Heval as [Hipi Heval].
    + inversion_clear Heval.
      rewrite <- H2.
      destruct (ident_eq_dec x y) as [Hxy|Hxny].
      * rewrite Hxy in Hneq; exfalso; apply Hneq; constructor.
      * rewrite find_obj_gso; [reflexivity|assumption].
    + destruct Heval as [HR1 HR2]; rewrite HR1; reflexivity.
  - unfold translate_eqn in Heval.
    destruct lae.
    apply stmt_eval_Control in Heval; destruct Heval as [Heval|Heval];
    destruct Heval as [Hipi Heval].
    inversion_clear Heval.
    rewrite <- H0.
    unfold find_obj, add_mem.
    reflexivity.
    destruct Heval as [Hmenv Henv]; rewrite Hmenv; intuition.
Qed.

Lemma not_Is_variable_in_eq:
  forall prog x eq menv env mems menv' env',
    ~Is_variable_in_eq x eq
    -> stmt_eval prog menv env (translate_eqn mems eq) (menv', env')
    -> PM.find x env' = PM.find x env.
Proof.
  intros prog x eq menv env mems menv' env' Hnd Heval.
  destruct eq as [y e|y f e|y v0 e];
  try apply not_Is_variable_in_eq_EqDef in Hnd.
  - (unfold translate_eqn in Heval;
     destruct e;
     apply stmt_eval_Control in Heval; destruct Heval as [Heval|Heval];
     destruct Heval as [Hipi Heval]; [
       apply stmt_eval_translate_cexp_env_add in Heval;
       destruct Heval; rewrite H;
       rewrite PM.gso; [intuition | apply Hnd]
     | destruct Heval as [Hmenv Henv]; rewrite Henv; intuition]).
  - simpl in Heval; destruct e.
    apply stmt_eval_Control in Heval; destruct Heval as [Heval|Heval];
    destruct Heval as [Heval1 Heval2].
    inversion_clear Heval2.
    rewrite <- H3.
    rewrite PM.gso; [reflexivity|].
    intro Hxy; apply Hnd; rewrite Hxy; constructor.
    destruct Heval2 as [Hmenv Henv]; rewrite Henv; intuition.
  - simpl in Heval; destruct e.
    apply stmt_eval_Control in Heval; destruct Heval as [Heval|Heval];
    destruct Heval as [Heval1 Heval2].
    inversion Heval2; intuition.
    destruct Heval2 as [Hmenv Henv]; rewrite Henv; intuition.
Qed.

Lemma stmt_eval_translate_eqns_menv_inv:
  forall prog menv env mems eqs menv' env',
    stmt_eval prog menv env (translate_eqns mems eqs) (menv', env')
    -> (forall x, ~Is_memory_in x eqs ->
                  find_mem x menv' = find_mem x menv).
Proof.
  induction eqs as [ |eq].
  + inversion_clear 1; reflexivity.
  + intros menv' env' Heval x Hnmem.
    apply not_Is_memory_in_cons in Hnmem.
    destruct Hnmem as [H0 H1].
    apply stmt_eval_translate_eqns_cons in Heval.
    destruct Heval as [menv'' Heval];
      destruct Heval as [env'' Heval];
      destruct Heval as [Heval0 Heval1].
    apply IHeqs with (x:=x) (2:=H1) in Heval0.
    apply not_Is_memory_in_eq with (1:=H0) in Heval1.
    rewrite Heval1, Heval0.
    reflexivity.
Qed.

Lemma stmt_eval_translate_eqns_minst_inv:
  forall prog menv env mems eqs menv' env',
    stmt_eval prog menv env (translate_eqns mems eqs) (menv', env')
    -> (forall x, ~Is_instance_in x eqs ->
                  find_obj x menv' = find_obj x menv).
Proof.
  induction eqs as [ |eq].
  + inversion_clear 1; reflexivity.
  + intros menv' env' Heval x Hnmem.
    apply not_Is_instance_in_cons in Hnmem.
    destruct Hnmem as [H0 H1].
    apply stmt_eval_translate_eqns_cons in Heval.
    destruct Heval as [menv'' Heval];
      destruct Heval as [env'' Heval];
      destruct Heval as [Heval0 Heval1].
    apply IHeqs with (x:=x) (2:=H1) in Heval0.
    apply not_Is_instance_in_eq with (1:=H0) in Heval1.
    rewrite Heval1, Heval0.
    reflexivity.
Qed.

Lemma stmt_eval_translate_eqns_env_inv:
  forall prog menv env mems eqs menv' env',
    stmt_eval prog menv env (translate_eqns mems eqs) (menv', env')
    -> (forall x, ~Is_variable_in x eqs ->
                  PM.find x env' = PM.find x env).
Proof.
  induction eqs as [ |eq].
  + inversion_clear 1; reflexivity.
  + intros menv' env' Heval x Hndef.
    apply not_Is_variable_in_cons in Hndef.
    destruct Hndef as [H0 H1].
    apply stmt_eval_translate_eqns_cons in Heval.
    destruct Heval as [menv'' Heval];
      destruct Heval as [env'' Heval];
      destruct Heval as [Heval0 Heval1].
    apply IHeqs with (x:=x) (2:=H1) in Heval0.
    apply not_Is_variable_in_eq with (1:=H0) in Heval1.
    rewrite Heval1, Heval0.
    reflexivity.
Qed.

Local Ltac split_env_assumption :=
  match goal with
  | Henv: context Is_free_in_lexp [_], Hsem: sem_var _ ?y _ _
    |- _ => apply Henv in Hsem; [destruct Hsem |solve [auto]]; clear Henv
  | Henv: context Is_free_in_clock [_], Hsem: sem_var _ ?y _ _
    |- _ => apply Henv in Hsem; [destruct Hsem |solve [auto]]; clear Henv
  end.

(* Note that the converse:
       Is_present_in memories menv env ck -> sem_clock H ck n true
   cannot be shown, since the present/absent status of memories is lost
   in menv/env. In other words, all elements of menv are always present,
   so Is_present_in may be true when the corresponding clock is not
   true under H (since it's elements may not be present on the "dataflow
   side"). *)
Lemma clock_correct_true:
  forall H n memories menv env ck,
    (forall x c, Is_free_in_clock x ck
                 -> sem_var H x n (present c)
                 -> (~PS.In x memories -> PM.find x env = Some c)
                    /\ (PS.In x memories -> find_mem x menv = Some c))
    -> sem_clock H ck n true
    -> Is_present_in memories menv env ck.
Proof.
  Hint Constructors Is_present_in.
  Hint Constructors sem_clock.
  Hint Constructors Is_free_in_clock.
  Hint Constructors exp_eval.
  intros H n memories menv env.
  induction ck as [|? ? x]; [ intuition | ].
  intro Henv.
  inversion_clear 1.
  constructor. apply IHck; auto.
  intros.
  split_env_assumption.
  apply exp_eval_tovar;
    destruct In_dec with x memories;
    intuition.
Qed.

Lemma clock_correct_false:
  forall H n memories menv env ck,
    (forall x c, Is_free_in_clock x ck
                 -> sem_var H x n (present c)
                 -> (~PS.In x memories -> PM.find x env = Some c)
                    /\ (PS.In x memories -> find_mem x menv = Some c))
    -> sem_clock H ck n false
    -> ~Is_present_in memories menv env ck.
Proof.
  Hint Constructors Is_present_in.
  Hint Constructors sem_clock.
  Hint Constructors Is_free_in_clock.
  intros H n memories menv env.
  induction ck as [|? ? x]; [inversion 2|].
  intro Henv.
  inversion_clear 1 as [| |? ? ? ? Hclk'|? ? ? ? ? Hclk' Hvar].
  apply IHck in Hclk'; auto.
  inversion_clear 1; contradiction.
  inversion_clear 1 as [|? ? ? Hipi Heval].
  split_env_assumption.
  repeat progress
         match goal with
         | H:_ \/ _ |- _ => destruct H
         | H:_ /\ _ |- _ => destruct H
         | H:exp_eval _ _ (tovar _ _ ) _ |- _ => apply exp_eval_tovar in H
         | H:exp_eval _ _ (State _) _ |- _ => inversion_clear H
         | H:exp_eval _ _ (Var _) _ |- _ => inversion_clear H
         | H: find_mem _ _ = Some _ |- _ => rewrite H in *
         | H: PM.find _ _ = Some _ |- _ => rewrite H in *
         | Hin: PS.In _ _, Hmenv: PS.In _ _ -> _ |- _ => apply Hmenv in Hin
         | Hin: ~PS.In _ _, Henv: ~PS.In _ _ -> _ |- _ => apply Henv in Hin
         | H: Some _ = Some _ |- _ => solve [ injection H; auto ]
         end.
Qed.

Lemma lexp_correct:
  forall H memories menv env n c e,
    sem_lexp H e n (present c)
    -> (forall x c, Is_free_in_lexp x e
                    -> sem_var H x n (present c)
                    -> (~PS.In x memories -> PM.find x env = Some c)
                       /\ (PS.In x memories -> find_mem x menv = Some c))
    -> exp_eval menv env (translate_lexp memories e) c.
Proof.
  Hint Constructors exp_eval.
  intros H memories menv env n c.
  induction e as [c0 e IH|c0|y|e IH y yb] using lexp_mult
  with (P:=fun e =>
          sem_laexp H e n (present c)
          -> (forall x c, Is_free_in_laexp x e
                          -> sem_var H x n (present c)
                          -> (~PS.In x memories -> PM.find x env = Some c)
                             /\ (PS.In x memories -> find_mem x menv = Some c))
          -> exp_eval menv env (translate_laexp memories e) c);
    inversion 1; intros;
    try apply IH; try apply econst; auto.
  split_env_assumption;
    unfold translate_lexp;
    destruct (PS.mem y memories) eqn:Hm;
    rewrite PS.mem_spec in Hm || rewrite mem_spec_false in Hm;
    auto.
Qed.

Lemma laexp_correct:
  forall H memories menv env n c e,
    sem_laexp H e n (present c)
    -> (forall x c, Is_free_in_laexp x e
                    -> sem_var H x n (present c)
                    -> (~PS.In x memories -> PM.find x env = Some c)
                       /\ (PS.In x memories -> find_mem x menv = Some c))
    -> exp_eval menv env (translate_laexp memories e) c.
Proof.
  intros H memories menv env n c e Hsem Henv.
  destruct e as [ck ce].
  inversion_clear Hsem as [? ? ? ? Hlexp ?|].
  change (exp_eval menv env (translate_lexp memories ce) c).
  apply (lexp_correct _ _ _ _ _ _ _ Hlexp); auto.
Qed.

(* TODO: Tidy this proof *)
Lemma cexp_correct:
  forall H memories prog menv env menv' env' n c x e,
    sem_cexp H e n (present c)
    -> (forall x c, Is_free_in_cexp x e
                    -> sem_var H x n (present c)
                    -> (~PS.In x memories -> PM.find x env = Some c)
                       /\ (PS.In x memories -> find_mem x menv = Some c))
    -> stmt_eval prog menv env (translate_cexp memories x e) (menv', env')
    -> env' = PM.add x c env.
Proof.
  intros H memories prog menv env menv' env' n c x.
  induction e as [ck e IH|b et IHt ef IHf|e] using cexp_mult
  with (P:=fun e =>
             sem_caexp H e n (present c)
             -> (forall x c,
                    Is_free_in_caexp x e
                    -> sem_var H x n (present c)
                    -> (~PS.In x memories -> PM.find x env = Some c)
                       /\ (PS.In x memories -> find_mem x menv = Some c))
             -> stmt_eval prog menv env (translate_caexp memories x e)
                          (menv', env')
             -> env' = PM.add x c env).
  - (* CAexp *) inversion 1; auto.
  - (* Emerge *)
    inversion_clear 1; inversion_clear 2;
    solve [
        apply IHt; auto
      | apply IHf; auto
      | split_env_assumption;
        repeat progress
               match goal with
               | H:_ \/ _ |- _ => destruct H
               | H:_ /\ _ |- _ => destruct H
               | H:exp_eval _ _ (tovar _ _ ) _ |- _ => apply exp_eval_tovar in H
               | H:exp_eval _ _ (State _) _ |- _ => inversion_clear H
               | H:exp_eval _ _ (Var _) _ |- _ => inversion_clear H
               | H: find_mem _ _ = Some _ |- _ => rewrite H in *
               | H: PM.find _ _ = Some _ |- _ => rewrite H in *
               | Hin: PS.In _ _, Hmenv: PS.In _ _ -> _ |- _ => apply Hmenv in Hin
               | Hin: ~PS.In _ _, Henv: ~PS.In _ _ -> _ |- _ => apply Henv in Hin
               | H: Some _ = Some _ |- _ => repeat injection H;
                                            discriminate || auto
               end
      ].
  - (* Eexp *)
    inversion 1; inversion 2; subst;
    repeat progress match goal with
    | H:sem_lexp _ _ _ _ |- _ => eapply lexp_correct in H; [|now auto]
    | H1:exp_eval _ _ _ _, H2:exp_eval _ _ _ _ |- _ =>
                                 eapply (exp_eval_det _ _ _ _ _ H1) in H2; subst
    | _ => reflexivity
    end.
Qed.

Lemma caexp_correct:
  forall H memories prog menv env menv' env' n c x e,
    sem_caexp H e n (present c)
    -> (forall x c, Is_free_in_caexp x e
                    -> sem_var H x n (present c)
                    -> (~PS.In x memories -> PM.find x env = Some c)
                       /\ (PS.In x memories -> find_mem x menv = Some c))
    -> stmt_eval prog menv env (translate_caexp memories x e) (menv', env')
    -> env' = PM.add x c env.
Proof.
  intros H memories prog menv env menv' env' n c x e Hsem Henv Hstmt.
  destruct e as [ck ce].
  inversion_clear Hsem as [? ? ? ? Hlexp ?|].
  change (stmt_eval prog menv env (translate_cexp memories x ce) (menv', env'))
    in Hstmt.
  apply cexp_correct with (1:=Hlexp) (3:=Hstmt); auto.
Qed.

(* Notes:
   1. The assumption sem_equations must be shown for a set of equations.
      TODO: lemma showing that a well-typed and well-clocked set of
            equations has a semantics.

   2. The assumption stmt_eval (translate_eqns mems eqs) implies that an
      execution exists and thus that exp_eval's evar and estate find some
      value for each required variable.
      This is somehow backwards; it should be an obligation to show that
      an execution exists. This is something assured indirectly in the
      lemma below where we require not just that evar and estate find
      some value, but also that it is the correct value.
 *)

(* TODO: Struggle to give a prettier definition of Memory_Corres and
         an associated induction principle. Tim: 0, Coq: 1.

Inductive Memory_Corres (G: global) (n: nat) :
       ident -> memory -> memoryEnv -> Prop :=
| MemC:
    forall f M menv i o eqs,
      find_node f G = Some(mk_node f i o eqs)
      -> List.Forall (Memory_Corres_eq G n M menv) eqs
      -> Memory_Corres G n f M menv

with Memory_Corres_eq (G: global) (n: nat) :
       memory -> memoryEnv -> equation -> Prop :=
| MemC_EqDef:
    forall M menv x cae,
      Memory_Corres_eq G n M menv (EqDef x cae)
| MemC_EqApp:
    forall M menv x f lae,
      (forall Mo omenv, mfind_inst x M = Some Mo
                        -> find_obj x menv = Some omenv
                        -> Memory_Corres G n f Mo omenv)
      -> Memory_Corres_eq G n M menv (EqApp x f lae)
| MemC_EqFby:
    forall M menv x v0 lae,
      (forall ms, mfind_mem x M = Some ms
                  -> find_mem x menv = Some (ms n))
      -> Memory_Corres_eq G n M menv (EqFby x v0 lae).

Scheme Memory_Corres_mult := Induction for Memory_Corres Sort Prop
with Memory_Corres_eq_mult := Induction for Memory_Corres_eq Sort Prop.

Check Memory_Corres_mult.
Check Memory_Corres_eq_mult.

Section Memory_Corres_ind'.
  Variables (G: global) (n: nat).

  Variable P : forall f M menv, Memory_Corres G n f M menv -> Prop.
  Variable Peq : forall M menv eq, Memory_Corres_eq G n M menv eq -> Prop.

  Hypothesis EqDef_case: forall M menv x cae,
      Peq M menv (EqDef x cae) (MemC_EqDef G n M menv x cae).

  Hypothesis EqApp_case: forall M menv x f lae
                                (Hmc : forall Mo omenv,
                                    mfind_inst x M = Some Mo
                                    -> find_obj x menv = Some omenv
                                    -> Memory_Corres G n f Mo omenv),
      (forall Mo omenv (Hmfind : mfind_inst x M = Some Mo)
                       (Hfindo : find_obj x menv = Some omenv),
          P f Mo omenv (Hmc Mo omenv Hmfind Hfindo))
      -> Peq M menv (EqApp x f lae) (MemC_EqApp G n M menv x f lae Hmc).

  Hypothesis EqFby_case: forall M menv x v0 lae
                                (Hfind : forall ms,
                                    mfind_mem x M = Some ms
                                    -> find_mem x menv = Some (ms n)),
        Peq M menv (EqFby x v0 lae) (MemC_EqFby G n M menv x v0 lae Hfind).

  Hypothesis MemC_case:
    forall f M menv i o eqs
           (Hfind : find_node f G = Some (mk_node f i o eqs))
           (Heqs : List.Forall (Memory_Corres_eq G n M menv) eqs),
      List.Forall (fun eq=> exists Hmc, Peq M menv eq (Hmc eq)) eqs
      -> P f M menv (MemC G n f M menv i o eqs Hfind Heqs).

  Definition mc_adapter M menv eqs
    (mc_eq_ind': forall (eq : equation)
                        (He : Memory_Corres_eq G n M menv eq), Peq M menv eq He)
    (H: List.Forall (Memory_Corres_eq G n M menv) eqs)
    : List.Forall (fun eq=> exists Hmc, Peq M menv eq (Hmc eq)) eqs.
  Proof.
    induction eqs as [|eq eqs IH]; [constructor|].
    inversion_clear H as [|? ? H0 H1].
    constructor.
    exists (fun _=> H0).
    apply (mc_eq_ind' eq H0).
    apply IH.
    exact H1.
  Defined.
  Print mc_adapter.

  Check (fun (M : memory) (menv : memoryEnv) (eqs : list equation)
             (mc_eq_ind' : forall (eq : equation)
                                  (Hmceq : Memory_Corres_eq G n M menv eq),
                 Peq M menv eq Hmceq)
             (H : List.Forall (Memory_Corres_eq G n M menv) eqs) =>
   let P := (fun eq => exists Hmc, Peq M menv eq (Hmc eq)) in
   let Q := (fun eqs => List.Forall (Memory_Corres_eq G n M menv) eqs
                        -> List.Forall P eqs) in
   list_ind Q
     (fun _ => List.Forall_nil P)
     (fun (eq : equation) (eqs0 : list equation)
          (IH : Q eqs0)
          (H0 : List.Forall (Memory_Corres_eq G n M menv) (eq :: eqs0)) =>
        (fun H1 : forall (A : Type) (P : A -> Prop) (x : A) (l : list A),
             List.Forall P (x :: l) -> P x /\ List.Forall P l =>
           (fun H2 : Memory_Corres_eq G n M menv eq
                     /\ List.Forall (Memory_Corres_eq G n M menv) eqs0 =>
              match H2 with
              | conj H3 H4 =>
                List.Forall_cons eq
                  (ex_intro
                     (fun Hmc => Peq M menv eq (Hmc eq)) (fun _ => H3)
                     (mc_eq_ind' eq H3)) (IH H4)
              end) (H1 equation (Memory_Corres_eq G n M menv) eq eqs0 H0))
          (fun (A : Type) (P : A -> Prop) (x : A) (l : list A) =>
             match Forall_cons2 A P x l with
             | conj x0 _ => x0
             end)) eqs H).

  Fixpoint Memory_Corres_ind' f M menv
           (Hmc : Memory_Corres G n f M menv) {struct Hmc}
         : P f M menv Hmc :=
    match Hmc as H in (Memory_Corres _ _ m1 m2 m3) return (P m1 m2 m3 H) with
    | MemC f M menv x y eqs Hf Heqs =>
        MemC_case f M menv x y eqs Hf Heqs
          (mc_adapter M menv eqs (Memory_Corres_eq_ind' M menv) Heqs)
    end

  with Memory_Corres_eq_ind' M menv eq
         (Hmceq : Memory_Corres_eq G n M menv eq) {struct Hmceq}
       : Peq M menv eq Hmceq :=
    match Hmceq as m1 in (Memory_Corres_eq _ _ m2 m3 e0)
                return (Peq m2 m3 e0 m1)
    with
    | MemC_EqDef M menv x cae => EqDef_case M menv x cae
    | MemC_EqApp M menv x f lae Hmc =>
      EqApp_case M menv x f lae Hmc
           (fun Mo omenv (Hmfind : mfind_inst x M = Some Mo)
                         (Hfindo : find_obj x menv = Some omenv) =>
              Memory_Corres_ind' f Mo omenv (Hmc Mo omenv Hmfind Hfindo))
    | MemC_EqFby M menv x v0 lae i => EqFby_case M menv x v0 lae i
    end.

End Memory_Corres_ind'.

*)

Inductive Memory_Corres (G: global) (n: nat) :
                        ident -> memory -> memoryEnv -> Prop :=
| MemC:
    forall f M menv i o eqs,
      find_node f G = Some(mk_node f i o eqs)
      -> Memory_Corres_eqs G n M menv eqs
      -> Memory_Corres G n f M menv

with Memory_Corres_eqs (G: global) (n: nat) :
       memory -> memoryEnv -> list equation -> Prop :=
| MemC_nil: forall m menv,
    Memory_Corres_eqs G n m menv []
| MemC_EqDef:
    forall M menv x cae eqs,
      Memory_Corres_eqs G n M menv eqs
      -> Memory_Corres_eqs G n M menv (EqDef x cae::eqs)
| MemC_EqApp:
    forall M menv x f lae eqs,
      (forall Mo omenv, mfind_inst x M = Some Mo
                        -> find_obj x menv = Some omenv
                        -> Memory_Corres G n f Mo omenv)
      -> Memory_Corres_eqs G n M menv eqs
      -> Memory_Corres_eqs G n M menv (EqApp x f lae::eqs)
| MemC_EqFby:
    forall M menv x v0 lae eqs,
      (forall ms, mfind_mem x M = Some ms
                  -> find_mem x menv = Some (ms n))
      -> Memory_Corres_eqs G n M menv eqs
      -> Memory_Corres_eqs G n M menv (EqFby x v0 lae::eqs).

Scheme Memory_Corres_mult := Induction for Memory_Corres Sort Prop
with Memory_Corres_eqs_mult := Induction for Memory_Corres_eqs Sort Prop.

Lemma Memory_Corres_eqs_node_tl:
  forall node G eqs n M menv,
    Ordered_nodes (node::G)
    -> ~Is_node_in node.(n_name) eqs
    -> (Memory_Corres_eqs (node::G) n M menv eqs
        <-> Memory_Corres_eqs G n M menv eqs).
Proof.
  intros node G eqs n M menv Hord Hini.
  split; intro Hmc; revert M menv eqs Hmc Hini.
  - induction 1 as [? ? ? ? ? ? Hfind| | | |? ? ? ? ? ? Hmfind]
      using Memory_Corres_eqs_mult
      with (P0:=fun M menv eqs IH=>
                  ~Is_node_in node.(n_name) eqs
                  -> Memory_Corres_eqs G n M menv eqs)
           (P:=fun f M menv IH=>
                 node.(n_name) <> f ->
                 Memory_Corres G n f M menv); intro HH.
    + rewrite find_node_tl with (1:=HH) in Hfind.
      econstructor; [exact Hfind|].
      apply IHHmc.
      apply find_node_later_not_Is_node_in with (1:=Hord) (2:=Hfind).
    + constructor.
    + constructor; apply IHHmc; apply not_Is_node_in_cons in HH; intuition.
    + constructor.
      * intros Mo omenv Hmfind Hfindo.
        apply H; try assumption.
        intro Hneq; rewrite <-Hneq in HH.
        apply HH; repeat constructor.
      * apply IHHmc; apply not_Is_node_in_cons in HH; intuition.
    + constructor; [trivial|].
      apply IHHmc. apply not_Is_node_in_cons in HH. intuition.
  - induction 1 as [? ? ? ? ? ? Hfind| | | |? ? ? ? ? ? Hmfind]
      using Memory_Corres_eqs_mult
      with (P0:=fun M menv eqs IH=>
                  ~Is_node_in node.(n_name) eqs
                  -> Memory_Corres_eqs (node::G) n M menv eqs)
           (P:=fun f M menv IH=>
                 node.(n_name) <> f ->
                 Memory_Corres (node::G) n f M menv); intro HH.
    + econstructor; [rewrite find_node_tl with (1:=HH); exact Hfind|].
      apply IHHmc.
      apply find_node_later_not_Is_node_in with (1:=Hord) (2:=Hfind).
    + constructor.
    + constructor; apply IHHmc; apply not_Is_node_in_cons in HH; intuition.
    + constructor.
      * intros Mo omenv Hmfind Hfindo.
        apply H; try assumption.
        intro Hneq; rewrite <-Hneq in HH.
        apply HH; repeat constructor.
      * apply IHHmc; apply not_Is_node_in_cons in HH; intuition.
    + constructor; [trivial|].
      apply IHHmc. apply not_Is_node_in_cons in HH. intuition.
Qed.

Lemma Memory_Corres_node_tl:
  forall f node G n M menv,
    node.(n_name) <> f
    -> Ordered_nodes (node :: G)
    -> (Memory_Corres (node :: G) n f M menv <-> Memory_Corres G n f M menv).
Proof.
  intros f node G n M menv Hnf Hord.
  split;
    inversion_clear 1;
    econstructor;
    repeat progress
         match goal with
         | Hf: find_node ?f (_ :: ?G) = Some _ |- _ =>
           rewrite find_node_tl with (1:=Hnf) in Hf
         | |- find_node ?f (_ :: ?G) = Some _ =>
           rewrite find_node_tl with (1:=Hnf)
         | Hf: find_node ?f ?G = Some _ |- find_node ?f ?G = Some _ => exact Hf
         | H:Memory_Corres_eqs _ _ _ _ _ |- Memory_Corres_eqs _ _ _ _ _ =>
           apply Memory_Corres_eqs_node_tl with (1:=Hord) (3:=H)
         | Hf: find_node ?f ?G = Some _ |- ~Is_node_in _ _ =>
           apply find_node_later_not_Is_node_in with (1:=Hord) (2:=Hf)
         end.
Qed.

Lemma Memory_Corres_eqs_tl:
  forall G n M menv eq eqs,
    Memory_Corres_eqs G n M menv (eq::eqs)
    -> Memory_Corres_eqs G n M menv eqs.
Proof.
  intros G n M menv eq eqs Hmc.
  inversion Hmc; assumption.
Qed.

Lemma Is_memory_in_Memory_Corres_eqs:
  forall G n M menv x eqs,
    Is_memory_in x eqs
    -> Memory_Corres_eqs G n M menv eqs
    -> (forall ms, mfind_mem x M = Some ms
                   -> find_mem x menv = Some (ms n)).
Proof.
  induction eqs as [|eq eqs IH]; [now inversion 1|].
  intros Himi Hmc ms.
  apply Is_memory_in_cons in Himi.
  destruct Himi as [Himeqs|[Himeq Himeqs]].
  - destruct eq; inversion_clear Himeqs; inversion_clear Hmc; auto.
  - apply Memory_Corres_eqs_tl in Hmc.
    apply IH with (1:=Himeqs) (2:=Hmc).
Qed.

Lemma Is_memory_in_msem_var:
  forall G H M n x eqs c,
    Is_memory_in x eqs
    -> sem_var H x n (present c)
    -> List.Forall (msem_equation G H M) eqs
    -> (exists ms, mfind_mem x M = Some ms /\ ms n = c).
Proof.
  induction eqs as [|eq eqs IH];
    inversion_clear 1 as [? ? Himi|? ? Himi];
    intros Hsv Hmsem;
    apply Forall_cons2 in Hmsem;
    destruct Hmsem as [Hmeq Hmeqs].
  - destruct eq; inversion Himi; subst.
    inversion_clear Hmeq as [| |? ? ? ? ls ? Ha Hmfind Hms0 Hsemls Hmls].
    exists ms.
    split; [apply Hmfind|].
    specialize Hmls with n.
    destruct (ls n);
      destruct Hmls as [Hms Hsv'];
      apply sem_var_det with (1:=Hsv) in Hsv';
      [discriminate Hsv'|injection Hsv'];
      auto.
  - apply IH; assumption.
Qed.

Local Ltac resolve_env_assumption :=
  intro x; intros; split; intros;
  match goal with
  | Hws: Is_well_sch (PS.add ?input _) _ |- _ =>
    destruct (ident_eq_dec x input);
      repeat progress
             match goal with
             | H: exists _, _ |- _ => destruct H
             | H: _ /\ _ |- _ => destruct H

             | H:   ~PS.In x _,
               Hin: x=input,
               Hws: Is_well_sch _ (_ :: _) |- _ =>
                 subst;
                 apply Is_well_sch_free_variable_in_mems with input _ _ _ in Hws;
                 [ apply not_Is_defined_in_not_Is_variable_in in Hws
                 | auto | apply PS.add_spec; auto ]

             | H1: x = input, H2: PS.In x ?mems |- _ =>
               rewrite H1 in H2; contradiction

             | H:   ~PS.In x _,
               Hin: x<>input,
               Hws: Is_well_sch _ (_ :: _) |- _ =>
                 apply Is_well_sch_free_variable with x _ _ _ in Hws;
                 [ | auto | intro HH; apply PS.add_spec in HH; intuition ]

             | H:   PS.In x _,
               Hws: Is_well_sch _ (_ :: _),
               Hm:  forall x : ident, ~Is_memory_in _ _ -> _ |- _ =>
                 apply Is_well_sch_free_variable_in_mems with x _ _ _ in Hws;
                 [ apply not_Is_defined_in_not_Is_memory_in in Hws;
                   apply Hm in Hws; rewrite Hws | | apply PS.add_spec ]; auto

             | H0:~Is_variable_in _ _,
               H1: stmt_eval _ _ _ _ _ |- _ =>
                 apply (stmt_eval_translate_eqns_env_inv _ _ _ _ _ _ _ H1) in H0;
                 rewrite H0

             | H:forall c:const, sem_var _ _ _ _ <-> PM.find ?x ?env = _
                                 |- PM.find ?x ?env = _ => now (apply H)

             | Hv: forall x' : ident,
                 Is_variable_in x' ?eqs ->
                                forall c' : const,
                                  sem_var ?H x' ?n (present c')
                                  <-> PM.find x' ?env = Some c',
               Hs: sem_var ?H ?x ?n (present ?c)
               |-  PM.find ?x ?env = Some ?c => apply Hv; [now auto|apply Hs]

             | Hin: PS.In ?x ?mems,
               Hm: forall x, PS.In x ?mems -> Is_memory_in x _
               |- find_mem ?x ?menv = Some _ => apply Hm in Hin

             | H1: Is_memory_in ?x ?eqs,
               H2: sem_var ?H ?x ?n (present ?c),
               H3: List.Forall (msem_equation ?G ?H ?M) ?eqs
               |- find_mem ?x ?menv = Some _ =>
               apply Is_memory_in_msem_var with (1:=H1) (2:=H2) in H3

             | H1: ?ms ?n = ?c |- find_mem ?x ?menv = Some ?c => rewrite <- H1

             | H1: Is_memory_in ?x ?eqs,
               H2: Memory_Corres_eqs ?G ?n ?M ?menv ?eqs,
               H3: mfind_mem ?x ?M = ?xs
               |- find_mem ?x ?menv = Some (?ms ?n) =>
               apply Is_memory_in_Memory_Corres_eqs with (1:=H1) (2:=H2) (3:=H3)

             | H1: Is_memory_in ?x ?eqs,
               H2: Memory_Corres_eqs ?G ?n ?M ?menv ?eqs,
               H3: mfind_mem ?x ?M = Some _ |- _ =>
               apply Is_memory_in_Memory_Corres_eqs with (1:=H1) (2:=H2) in H3

             | H1: ?xs ?n = ?c,
               H2: find_mem ?x ?menv = Some (?xs ?n)
               |- find_mem ?x ?menv = Some ?c =>
               rewrite H1 in H2; exact H2
             end
  end.

Lemma stmt_eval_EqDef_mem_inv:
  forall prog menv env mems x e menv' env',
    stmt_eval prog menv env (translate_eqn mems (EqDef x e)) (menv', env')
    -> menv' = menv.
Proof.
  intros until env'. intro Hstmt.
  destruct e as [ck].
  induction ck as [|? IH ? b];
    [now apply stmt_eval_translate_cexp_menv_inv with (1:=Hstmt)|].
  destruct b;
    inversion_clear Hstmt;
    match goal with
    | H: stmt_eval prog menv env _ (menv', env') |- _ =>
      (apply IH in H; assumption) || (inversion_clear H0; reflexivity)
    end.
Qed.

Lemma stmt_eval_EqFby_env_inv:
  forall prog menv env mems x v0 e menv' env',
    stmt_eval prog menv env (translate_eqn mems (EqFby x v0 e)) (menv', env')
    -> env' = env.
Proof.
  intros until env'. intro Hstmt.
  destruct e as [ck].
  induction ck as [|? IH ? b];
    [inversion_clear Hstmt; reflexivity|].
  destruct b;
    inversion_clear Hstmt;
    match goal with
    | H: stmt_eval prog menv env _ (menv', env') |- _ =>
      (apply IH in H; assumption) || (inversion_clear H0; reflexivity)
    end.
Qed.

(* TODO: These lemmas would not be necessary with a proper definition of
         Memory_Corres (using List.Forall)... *)
Lemma Memory_Corres_eqs_cons:
  forall G n M menv eq eqs,
    Memory_Corres_eqs G n M menv (eq::eqs)
    <-> Memory_Corres_eqs G n M menv [eq]
        /\ Memory_Corres_eqs G n M menv eqs.
Proof.
  Hint Constructors Memory_Corres_eqs.
  split; [inversion 1|destruct 1 as [H0 ?]; inversion H0]; intuition.
Qed.

Lemma Memory_Corres_eqs_app:
  forall G n M menv leqs reqs,
    Memory_Corres_eqs G n M menv (leqs ++ reqs)
    <-> Memory_Corres_eqs G n M menv leqs
        /\ Memory_Corres_eqs G n M menv reqs.
Proof.
  Hint Constructors Memory_Corres_eqs.
  induction leqs as [|eq leqs IH]; [now intuition|].
  intro reqs.
  split; intro HH.
  - rewrite <- List.app_comm_cons in HH.
    apply Memory_Corres_eqs_cons in HH.
    destruct HH as [H0 H1].
    apply IH in H1; destruct H1.
    split; [apply Memory_Corres_eqs_cons|]; intuition.
  - rewrite <- List.app_comm_cons.
    apply Memory_Corres_eqs_cons.
    destruct HH as [H0 H1].
    apply Memory_Corres_eqs_cons in H0.
    rewrite IH.
    intuition.
Qed.

Lemma Memory_Corres_eqs_add_mem:
  forall G M menv n y ms eqs,
    mfind_mem y M = Some ms
    -> Memory_Corres_eqs G n M menv eqs
    -> Memory_Corres_eqs G n M (add_mem y (ms n) menv) eqs.
Proof.
  induction eqs as [|eq eqs IH]; [now auto|].
  intros Hmfind Hmc.
  apply Memory_Corres_eqs_cons in Hmc.
  destruct Hmc as [Hmc0 Hmc1].
  apply Memory_Corres_eqs_cons.
  split; [|now apply IH with (1:=Hmfind) (2:=Hmc1)].
  destruct eq; repeat constructor.
  - intros Mo omenv Hifind Hfindo.
    inversion_clear Hmc0 as [| |? ? ? ? ? ? Hmc H0|]; clear H0.
    now apply Hmc with (1:=Hifind) (2:=Hfindo).
  - intros ms' Hmfind'.
    destruct (ident_eq_dec i y) as [He|Hne].
    + rewrite He in *.
      rewrite Hmfind in Hmfind'.
      injection Hmfind'; intro H; rewrite <- H; clear H.
      rewrite find_mem_gss; reflexivity.
    + rewrite find_mem_gso with (1:=Hne).
      inversion_clear Hmc0 as [| | |? ? ? ? ? ? Hmc H0]; clear H0.
      now apply Hmc with (1:=Hmfind').
Qed.

(* Unfortunately, a similar lemma to Memory_Corres_eqs_add_mem but for add_obj
   does not seem to hold without extra conditions:

     Lemma Memory_Corres_eqs_add_obj:
       forall G n M menv y Mo g omenv eqs,
         mfind_inst y M = Some Mo
         -> Memory_Corres G n g Mo omenv
         -> Memory_Corres_eqs G n M menv eqs
         -> Memory_Corres_eqs G n M (add_obj y omenv menv) eqs.

   Consider the equations:
      [ x = f y; x = g y; ... ]
   It is possible for this system to have an m-semantics if both f and g have
   the same input/output behaviour, but also possible for the memory structures
   of f and g to differ from one another. In this case, we end up having as
   hypothesis
        Memory_Corres G n g Mo omenv
   and the goal
        Memory_Corres G n f Mo omenv *)

Lemma find_node_translate_find_class:
  forall f G node,
    find_node f G = Some node
    -> (exists prog',
           find_class f (translate G) = Some (translate_node node, prog')).
Proof.
  induction G as [|nd G IH]; [now inversion 1|].
  intros node Hfind.
  simpl; simpl in Hfind.
  destruct (ident_eqb nd.(n_name) f) eqn:Heq.
  - injection Hfind; intro He; rewrite He in *; clear He Hfind.
    exists (translate G); reflexivity.
  - apply IH in Hfind.
    destruct Hfind as [prog'].
    exists prog'.
    assumption.
Qed.

Lemma Memory_Corres_eqs_add_obj:
  forall G n M menv eqs y omenv,
    Memory_Corres_eqs G n M menv eqs
    -> ~Is_instance_in y eqs
    -> Memory_Corres_eqs G n M (add_obj y omenv menv) eqs.
Proof.
  induction eqs as [|eq eqs IH]; [now constructor|].
  intros y omenv Hmce Hniii.
  apply Memory_Corres_eqs_cons in Hmce.
  destruct Hmce as [Hmce0 Hmce1].
  apply not_Is_instance_in_cons in Hniii.
  destruct Hniii as [Hniii0 Hniii1].
  apply Memory_Corres_eqs_cons.
  split; [|now apply IH with (1:=Hmce1) (2:=Hniii1)].
  destruct eq; constructor; try constructor.
  - intros Mo omenv' Hmfind Hfindo.
    destruct (ident_eq_dec i y) as [Hiy|Hniy].
    + rewrite Hiy in Hniii0; exfalso; apply Hniii0; constructor.
    + rewrite find_obj_gso in Hfindo; [|exact Hniy].
      inversion_clear Hmce0 as [| |? ? ? ? ? ? HH|].
      apply HH with (1:=Hmfind) (2:=Hfindo).
  - intros ms Hmfind.
    inversion_clear Hmce0 as [| | |? ? ? ? ? ? HH].
    rewrite find_mem_add_obj.
    apply HH with (1:=Hmfind).
Qed.

(* TODO: Abstract out this pattern of induction over G using find_node. *)
(* TODO: Introduce some lemmas to simplify reasoning around ident_eq_dec. *)
Lemma Memory_Corres_unchanged:
  forall G f fnode n M menv,
    Welldef_global G
    -> find_node f G = Some fnode
    -> Memory_Corres G n f M menv
    -> Mem_unchanged n M
    -> Memory_Corres G (S n) f M menv.
Proof.
  induction G as [|node G IHnode]; [now inversion_clear 2|].
  intros f fnode n M menv Hwdef Hfindn Hmc Hmu.
  pose proof (Welldef_global_Ordered_nodes _ Hwdef) as Hord.
  destruct node as [name input output eqs].
  destruct (ident_eq_dec f name) as [Hfeq|Hfneq].
  - rewrite Hfeq in *.
    destruct fnode as [name' input' output' eqs'].
    assert (Hfindn':=Hfindn).
    simpl in Hfindn';
      unfold ident_eqb in Hfindn';
      rewrite Pos.eqb_refl in Hfindn'.
    injection Hfindn';
      intros HR1 HR2 HR3 HR4;
      rewrite <-HR1,<-HR2,<-HR3,<-HR4 in *;
      clear HR1 HR2 HR3 HR4 Hfindn'.
    econstructor; [now apply Hfindn|].

    inversion Hwdef as [|? ? Hwdef' neqs ni no
                           Hwsch Hindi Hoivi Hnini Hfnone Hnname [HR1 HR2]].
    unfold neqs,ni,no in *; clear neqs ni no HR1 HR2.
    simpl in *.
    clear Hfindn.
    apply Memory_Corres_eqs_node_tl with (1:=Hord) (2:=Hnini).
    inversion_clear Hmc as [? ? ? ? ? ? Hfindn Hmceqs].
    simpl in Hfindn;
      unfold ident_eqb in Hfindn;
      rewrite Pos.eqb_refl in Hfindn.
    injection Hfindn;
      intros HR1 HR2 HR3;
      rewrite <-HR1,<-HR2,<-HR3 in *;
      clear HR1 HR2 HR3 Hfindn.
    apply Memory_Corres_eqs_node_tl with (1:=Hord) (2:=Hnini) in Hmceqs.

    clear Hwdef Hwsch Hindi Hoivi Hnini Hord.
    induction eqs as [|eq eqs IH]; [now constructor|].
    apply Memory_Corres_eqs_cons in Hmceqs.
    destruct Hmceqs as [Hmceq Hmceqs].

    destruct eq as [x e|x g e|x v0 e];
    (apply IH in Hmceqs;
       [|intros g' Hgini; apply Hfnone; constructor 2; exact Hgini]);
    constructor; try exact Hmceqs.
    + intros Mo omenv Hmfind Hfindo.
      inversion_clear Hmu as [? Hmfindm Hmfindi].
      assert (Hmu':=Hmfind).
      apply Hmfindi in Hmu'.
      inversion_clear Hmceq as [| |? ? ? ? ? ? Homc H0|].
      pose proof (Homc _ _ Hmfind Hfindo) as Homc'.
      assert (find_node g G <> None) as Hfindg
          by (apply Hfnone; repeat constructor).
      assert (exists node, find_node g G = Some node) as Hnode.
      destruct (find_node g G) as [node|];
        [|exfalso; apply Hfindg; reflexivity].
      exists node; reflexivity.
      destruct Hnode as [node Hnode].
      now apply IHnode with (1:=Hwdef') (2:=Hnode) (3:=Homc') (4:=Hmu').
    + intros ms Hmfind.
      inversion_clear Hmu as [? Hmfindm Hmfindi].
      assert (Hms:=Hmfind).
      apply Hmfindm in Hms.
      inversion_clear Hmceq as [| | |? ? ? ? ? ? Hfindm H0].
      apply Hfindm in Hmfind.
      rewrite Hmfind.
      rewrite Hms.
      reflexivity.
  - apply Welldef_global_cons in Hwdef.
    apply not_eq_sym in Hfneq.
    apply Memory_Corres_node_tl with (1:=Hfneq) (2:=Hord).
    apply Pos.eqb_neq in Hfneq.
    simpl in Hfindn.
    unfold ident_eqb in Hfindn.
    rewrite Hfneq in Hfindn.
    apply Pos.eqb_neq in Hfneq.
    apply Memory_Corres_node_tl with (1:=Hfneq) (2:=Hord) in Hmc.
    now apply IHnode with (1:=Hwdef) (2:=Hfindn) (3:=Hmc) (4:=Hmu).
Qed.

Lemma is_step_correct:
  forall (G: global)
         (H: history)
         (M: memory)
         (mems: PS.t)
         (alleqs : list equation),

    List.Forall (msem_equation G H M) alleqs
    -> (forall x:ident, PS.In x mems -> Is_memory_in x alleqs) (* ?? *)

    -> forall (prog: program)
              (input: ident)
              (eqs: list equation)
              (n: nat)
              (menv: memoryEnv)
              (menv': memoryEnv)
              (env: constEnv)
              (env': constEnv),
        (exists oeqs, alleqs = oeqs ++ eqs)
        -> Welldef_global G
        -> prog = translate G

        (* - input (assumed) *)
        -> (forall c, sem_var H input n (present c)
                      <-> PM.find input env = Some c)
          (* NB: PM.find x env' = Some c -> sem_var H x n (present c)
                 does not hold if PM.find x env = Some arbitrary_c, since
                 x will not be written to when its clock is absent.

                 It may just be better to show the direction:
                 sem_var H x n (present c) -> PM.find x env' = Some c

                 which is enough if the outputs are only sampled when
                 they are present (normally the case).

                 More discussion/context is needed. *)
        -> (forall x, Is_variable_in x eqs -> PM.find x env = None)
        -> ~PS.In input mems
        -> ~ Is_defined_in input eqs

        (* - execution of translated equations *)
        -> Is_well_sch (PS.add input mems) eqs
        -> (forall x:ident, PS.In x mems -> Is_memory_in x alleqs)
        -> (stmt_eval prog menv env (translate_eqns mems eqs) (menv', env'))

        (* - instantiated nodes (assumed) *)
        -> (forall (f : ident) (fnode : DataflowSyntax.node)
                   (xs : stream) (M : memory) (ys : stream)
                   (prog' : program) (fclass : class) (menv : memoryEnv)
                   (env : constEnv) (menv' : memoryEnv) (env' : constEnv),
               find_node f G = Some fnode
               -> msem_node G f xs M ys
               -> find_class f prog = Some (fclass, prog')
               -> (forall c, xs n = present c
                             <-> PM.find fclass.(c_input) env = Some c)
               -> (forall x, Is_variable_in x fnode.(n_eqs)
                             -> PM.find x env = None)
               -> stmt_eval prog' menv env fclass.(c_step) (menv', env')
               -> Memory_Corres G n f M menv
               -> (forall c, ys n = present c
                             <-> PM.find fclass.(c_output) env' = Some c)
                  /\ Memory_Corres G (S n) f M menv')

        (* - unwritten memories (assumed) *)
        -> Memory_Corres_eqs G n M menv alleqs

        (* - locals (shown) *)
        -> (forall x, Is_variable_in x eqs
                    -> forall c : const, sem_var H x n (present c)
                                         <-> PM.find x env' = Some c)
           (* - written memories (shown) *)
           /\ Memory_Corres_eqs G (S n) M menv' eqs.
Proof.
  intros until alleqs.
  intros Hsems Himi.

  induction eqs as [|eq].
  split; intros; [ match goal with
                   | H:Is_variable_in _ nil |- _ => inversion H
                   end | now constructor ].
  intros n menv menv'' env env'' Hall Hwdef Hprog Hin Henv Hin1 Hin2 Hwsch
         Hmeq Hevals Hnode Hmc.

  (* split stmt_eval into two parts *)
  apply stmt_eval_translate_eqns_cons in Hevals;
    destruct Hevals as [menv' Hevals];
    destruct Hevals as [env' Hevals];
    destruct Hevals as [Hevals Heval].

  assert ((forall x, Is_variable_in x eqs
                     -> forall c, sem_var H x n (present c)
                                  <-> PM.find x env' = Some c)
          /\ Memory_Corres_eqs G (S n) M menv' eqs) as IHeqs'.
  { eapply IHeqs.
    - apply List_shift_away with (1:=Hall).
    - exact Hwdef.
    - exact Hprog.
    - exact Hin.
    - intros; apply Henv; constructor 2; auto.
    - exact Hin1.
    - apply not_Is_defined_in_cons with (1:=Hin2).
    - apply Is_well_sch_cons with (1:=Hwsch).
    - exact Hmeq.
    - exact Hevals.
    - exact Hnode.
    - exact Hmc. }

  clear IHeqs.
  destruct IHeqs' as [IHeqs0 IHeqs1].

  destruct Hall as [oeqs Hall].
  assert (Hsems' := Hsems); rewrite Hall in Hsems'.

  apply Forall_app in Hsems'.
  destruct Hsems' as [H0 Hsems']; clear H0.
  apply Forall_cons2 in Hsems'.
  destruct Hsems' as [Hsem Hsems'].

  destruct eq as [y cae|y f lae|y v0 lae].
  - (* Inductive step for EqDef *)
    split; [|constructor; apply stmt_eval_EqDef_mem_inv in Heval;
             rewrite Heval; exact IHeqs1].
    intros x Hvi c.
    apply Is_variable_in_cons in Hvi; destruct Hvi as [Hvieq|Hivieqs].
    + inversion Hvieq; subst; clear Hvieq.
      destruct cae as [ck ce].
      simpl in Heval.
      inversion_clear Hsem as [? ? ? ? Hsem'| |];
        specialize Hsem' with n;
        destruct Hsem' as [v Hsem];
        destruct Hsem as [Hsv Hcae].
      pose proof (stmt_eval_translate_eqns_menv_inv _ _ _ _ _ _ _ Hevals)
        as Hminv.
      apply stmt_eval_Control in Heval;
        destruct Heval as [Heval|Heval];
        destruct Heval as [Hpi Heval].
      { (* Is_present_in ck *)
        inversion Hcae as [? ? ? c' Hcexp Hclk|? ? ? Hcexp Hclk];
        subst; clear Hcae.
        { (* sem_clock H ck n true *)
          apply (cexp_correct _ _ _ _ _ _ _ _ _ _ _ Hcexp) in Heval.
          2:now resolve_env_assumption.
          rewrite Heval; rewrite PM.gss; split.
          intro Hsv';
            assert (present c' = present c) as Heq
              by apply sem_var_det with (1:=Hsv) (2:=Hsv').
          injection Heq as Heq'; subst; reflexivity.
          injection 1 as Heq; rewrite Heq in Hsv; assumption. }
        { (* sem_clock H ck n false *)
          apply clock_correct_false with _ _ mems menv' env' _ in Hclk.
          2:now resolve_env_assumption.
          contradiction. }
      }
      { (* ~Is_present_in ck *)
        destruct Heval as [HR1 HR2]; rewrite HR2 in *; clear HR1 HR2.
        inversion Hcae as [ ck' ce' n' c' Hcexp Hclk
                          | ck' ce' n' Hcexp Hclk [HR1 HR2] HR3 HR4].
        { (* sem_clock H ck n true *)
          apply (clock_correct_true H n mems menv' env' ck) in Hclk.
          2:now resolve_env_assumption.
          contradiction. }
        { (* sem_clock H ck n false *)
          split.
          { intro Hsv'.
            pose proof (sem_var_det _ _ _ _ _ Hsv Hsv') as Hbad.
            rewrite <- HR4 in Hbad.
            discriminate Hbad. }
          { intro Hfx.
            destruct (Is_variable_in_dec y eqs) as [Hvi|Hvni].
            apply IHeqs0; [apply Hvi | apply Hfx].
            apply (stmt_eval_translate_eqns_env_inv _ _ _ _ _ _ _ Hevals)
              in Hvni.
            rewrite Hvni in Hfx.
            rewrite Henv in Hfx.
            discriminate.
            repeat constructor. }
        }
      }
    + destruct Hivieqs as [H0 H1].
      apply IHeqs0 with (c:=c) in H1; rewrite H1.
      apply not_Is_variable_in_eq with (2:=Heval) in H0.
      rewrite H0; intuition.
  - (* TODO: Inductive step for EqApp: y = f lae. *)
    destruct lae as [ck le].
    simpl in Heval.
    inversion_clear Hsem as [|? ? ? ? Mo ? ls ys Hfindi Hlae Hsy Hmsem|].
    assert (Hmsem' := Hmsem).
    inversion_clear Hmsem' as [? ? ? ? i o neqs Hfindn HnH].
    destruct HnH as [fH [Hls [Hys [Hfclk Hsneqs]]]].

    pose proof (stmt_eval_translate_eqns_menv_inv _ _ _ _ _ _ _ Hevals)
      as Hminv.
    apply stmt_eval_Control in Heval;
      destruct Heval as [Heval|Heval];
      destruct Heval as [Hpi Heval].
    + (* Is_present_in ck *)
      inversion_clear Heval.
      match goal with
      | H0: find_obj y menv' = Some omenv,
        H1: exp_eval menv' env' (translate_lexp mems le) v,
        H2 : stmt_step_eval prog omenv f v omenv' rv,
        H3 : add_obj y omenv' menv' = menv'',
        H4 : PM.add y rv env' = env'' |- _ =>
          rename H0 into Hfindo;
          rename H1 into Hexp;
          rename H2 into Heval;
          rename H3 into Hmenv'';
          rewrite <-H4 in *; clear H4
      end.
      specialize Hlae with n.
      inversion Hlae as [? ? ? ? Hlexp Hclk H1 H2 Hlsn
                        | ? ? ? Hlexp Hclk H0 H2 Hlsn]; clear H0 H1 H2.
      * (* sem_clock H ck n true *)
        apply lexp_correct with (memories:=mems) (menv:=menv') (env:=env')
          in Hlexp.
        2:resolve_env_assumption.
        inversion_clear Heval as [? ? ? ? prog' ? ? cls oenv' Hfindc Heval' Hout].
        assert (Hfindn':=Hfindn).
        apply find_node_translate_find_class in Hfindn'.
        destruct Hfindn' as [prog'' Hfindc'].
        rewrite Hprog in Hfindc.
        rewrite Hfindc' in Hfindc.
        injection Hfindc;
          intros He1 He2; rewrite He1 in *; rewrite <-He2 in Hout;
          clear He1 Hfindc; simpl in *.
        apply (exp_eval_det _ _ _ _ _ Hexp) in Hlexp.

        assert((forall c, ys n = present c
                          <-> PM.find cls.(c_output) oenv' = Some c)
               /\ Memory_Corres G (S n) f Mo omenv') as Hinv.
        { eapply Hnode with (env:=PM.add (c_input cls) v empty).
          - exact Hfindn.
          - exact Hmsem.
          - rewrite <-He2, Hprog. exact Hfindc'.
          - rewrite <-He2; simpl.
            rewrite PM.gss, <- Hlsn, Hlexp.
            intro c0; split; injection 1; intro He; rewrite He; intuition.
          - intros x Hivi.
            rewrite <- He2, PM.gso.
            apply PM.gempty.
            intro Hxni; simpl in Hxni.
            apply Welldef_global_input_not_Is_defined_in
              with (1:=Hwdef) in Hfindn.
            apply not_Is_defined_in_not_Is_variable_in in Hfindn.
            rewrite Hxni in Hivi.
            contradiction.
          - exact Heval'.
          - rewrite Hall in Hmc.
            apply Memory_Corres_eqs_app in Hmc.
            destruct Hmc as [H0 Hmc]; clear H0.
            apply Memory_Corres_eqs_cons in Hmc.
            destruct Hmc as [Hmc H0]; clear H0.
            inversion_clear Hmc as [| |? ? ? ? ? ? Hmc' H0|].
            apply Hmc' with (1:=Hfindi).
            rewrite <- Hfindo; symmetry.
            inversion_clear Hwsch as [| |? ? ? ? ? ? Hnii|].
            apply stmt_eval_translate_eqns_minst_inv with (1:=Hevals) (2:=Hnii).
        }
        rewrite <-He2 in Hinv; simpl in Hinv.
        destruct Hinv as [Hinv0 Hinv1].
        rewrite <-Hmenv'' in *.
        split.
        { intros x' Hivi c0.
          inversion_clear Hivi as [? ? Hivi'|? ? Hivi'].
          - inversion Hivi' as [|x f' e HR1 [HR2 HR3 HR4]];
              rewrite <-HR1, HR2 in *; clear HR1 HR2 HR3 HR4.
            rewrite PM.gss, <-Hout, <-Hinv0.
            specialize Hsy with n.
            split.
            + intro Hsy'; apply sem_var_det with (1:=Hsy) (2:=Hsy').
            + intro Hsy'; rewrite Hsy' in Hsy; exact Hsy.
          - destruct (ident_eq_dec x' y) as [Hxy|Hnxy].
            + rewrite Hxy in *; clear Hxy.
              rewrite PM.gss, <-Hout, <-Hinv0.
              specialize Hsy with n.
              split.
              * intro Hsy'; apply sem_var_det with (1:=Hsy) (2:=Hsy').
              * intro Hsy'; rewrite Hsy' in Hsy; exact Hsy.
            + rewrite (PM.gso _ _ Hnxy).
              now apply IHeqs0 with (1:=Hivi').
        }
        {
          assert (~Is_instance_in y eqs) as Hniii
              by (inversion_clear Hwsch; assumption).
          constructor.
          2:now apply Memory_Corres_eqs_add_obj with (1:=IHeqs1) (2:=Hniii).
          intros Mo' omenv'' Hmfind Hfindo'.
          rewrite find_obj_gss in Hfindo'.
          injection Hfindo'; intro He; rewrite <-He in *; clear He Hfindo'.
          rewrite Hfindi in Hmfind.
          injection Hmfind; intro He; rewrite <-He in *; clear He Hmfind.
          exact Hinv1.
        }
      * (* sem_clock H ck n false *)
        apply clock_correct_false with _ _ mems menv' env' _ in Hclk.
        2:now resolve_env_assumption.
        contradiction.
    + (* ~Is_present_in ck *)
      clear Hnode.
      destruct Heval as [HR1 HR2]; rewrite HR1, HR2 in *; clear HR1 HR2.
      specialize Hlae with n.
      inversion Hlae as [? ? ? ? Hlexp Hclk H1 H2 Hlsn
                        | ? ? ? Hlexp Hclk H0 H2 Hlsn];
        clear H0 H1 H2;
        symmetry in Hlsn.
      { (* sem_clock H ck n true *)
        apply (clock_correct_true H n mems menv' env' ck) in Hclk.
        2:now resolve_env_assumption.
        contradiction. }
      { (* sem_clock H ck n false *)
        split.
        { intros x Hivi.
          inversion_clear Hivi as [? ? Hivi'|? ? Hivi'];
            [|now apply IHeqs0 with (1:=Hivi')].
          inversion_clear Hivi'.
          intro c.
          specialize Hsy with n.
          specialize Hls with n.
          rewrite Hlsn in Hlae.
          split; intro HH.
          - (* Exploit the 'clocking assumption' built into msem_node. *)
            pose proof (Welldef_global_output_Is_variable_in
                          _ _ _ Hwdef Hfindn) as Hivio.
            apply Is_variable_in_Is_defined_in in Hivio.
            simpl in Hivio.
            apply Hfclk with (2:=Hivio) in Hlsn.
            pose proof (sem_var_det _ _ _ _ _ Hsy HH) as Hysn.
            specialize Hys with n.
            rewrite Hysn in Hys.
            pose proof (sem_var_det _ _ _ _ _ Hys Hlsn) as Hbad.
            discriminate Hbad.
          - assert (PM.find y env = None) as Hyenv
                by (apply Henv; constructor; constructor).
            destruct (Is_variable_in_dec y eqs) as [Hyeqs|Hnyeqs].
            + apply IHeqs0 with (c:=c) in Hyeqs.
              apply Hyeqs in HH.
              exact HH.
            + pose proof (stmt_eval_translate_eqns_env_inv
                            _ _ _ _ _ _ _ Hevals) as Hinv.
              apply Hinv in Hnyeqs.
              rewrite <-Hnyeqs in Hyenv.
              rewrite Hyenv in HH.
              discriminate HH.
        }
        {
          assert (~Is_instance_in y eqs) as Hniii
              by (inversion_clear Hwsch; assumption).
          constructor.
          2:now apply IHeqs1.
          intros Mo' omenv' Hfindi' Hfindo.
          rewrite Hfindi in Hfindi'.
          injection Hfindi'; intro He; rewrite <-He in *; clear He.
          rewrite (stmt_eval_translate_eqns_minst_inv
                     _ _ _ _ _ _ _ Hevals _ Hniii) in Hfindo.
          rewrite Hall in Hmc.
          apply Memory_Corres_eqs_app in Hmc.
          destruct Hmc as [Hmc0 Hmc]; clear Hmc0.
          inversion_clear Hmc as [| |? ? ? ? ? ? Hmc0 H0|]; clear H0.
          apply Hmc0 with (2:=Hfindo) in Hfindi; clear Hmc0.
          apply absent_invariant with (2:=Hlsn) in Hmsem.
          now apply Memory_Corres_unchanged
            with (1:=Hwdef) (2:=Hfindn) (3:=Hfindi) (4:=Hmsem).
        }
      }
  - (* Inductive step for EqFby: y = v0 fby lae *)
    clear Hnode.
    Hint Constructors Is_memory_in_eq.
    Hint Immediate Is_memory_in_EqFby.
    pose proof (stmt_eval_EqFby_env_inv _ _ _ _ _ _ _ _ _ Heval) as Henv''.
    split.
    + (* EqFby does not update env... *)
      inversion_clear 1 as [? ? Hivieq|? ? Hivi];
      [now inversion Hivieq|].
      rewrite Henv''.
      now apply IHeqs0 with (1:=Hivi).
    + (* ...but it does update menv *)
      pose proof (stmt_eval_translate_eqns_menv_inv _ _ _ _ _ _ _ Hevals)
        as Hminv.
      destruct lae as [ck l].

      inversion_clear Hsem as [| |? ? ms ? ls ? ? Hmfind Hms0 Hlae Hmsn].
      specialize Hmsn with n.
      specialize Hlae with n.

      simpl in Heval;
        apply stmt_eval_Control in Heval;
        destruct Heval as [Heval|Heval];
        destruct Heval as [Hpi Heval].
      { (* Is_present_in ck *)
        inversion_clear Heval.
        match goal with
        | H1: exp_eval _ _ _ _, H2: add_mem _ _ _ = _ |- _ =>
          rename H1 into Heval; rewrite <-H2 in *; clear H2
        end.
        inversion Hlae as [? ? ? ? Hlexp Hclk H1 H2 Hlsn
                          | ? ? ? Hlexp Hclk H0 H2 Hlsn]; clear H0 H1 H2.
        { (* sem_clock H ck n true *)
          rewrite <- Hlsn in Hmsn.
          destruct Hmsn as [Hmsn Hvsn]; clear Hlsn.
          rewrite Henv'' in Heval.
          apply lexp_correct with (menv:=menv') (env:=env') (memories:=mems)
            in Hlexp.
          2:now resolve_env_assumption.
          apply (exp_eval_det _ _ _ _ _ Heval) in Hlexp.
          rewrite Hlexp in *; clear Hlexp.
          constructor.
          - intros ms' Hmfind'.
            rewrite Hmfind in Hmfind'.
            injection Hmfind'; intros He; rewrite <- He in *;
              clear He Hmfind' ms'.
            rewrite Hmsn.
            rewrite find_mem_gss.
            reflexivity.
          - rewrite <- Hmsn.
            now apply Memory_Corres_eqs_add_mem with (1:=Hmfind) (2:=IHeqs1).
        }
        { (* sem_clock H ck n false *)
          apply clock_correct_false with _ _ mems menv' env'' _ in Hclk.
          rewrite Henv'' in Hclk.
          contradiction.
          rewrite Henv'' in *.
          resolve_env_assumption.
        }
      }
      { (* ~Is_present_in ck *)
        destruct Heval as [HR1 HR2]; rewrite HR1 in *; clear HR1 HR2.
        inversion Hlae as [? ? ? ? Hlexp Hclk H1 H2 Hlsn
                          | ? ? ? Hlexp Hclk H0 H2 Hlsn]; clear H0 H1 H2.
        { (* sem_clock H ck n true *)
          rewrite Hall in *.
          apply (clock_correct_true H n mems menv' env' ck) in Hclk.
          2:now resolve_env_assumption.
          contradiction. }
        { (* sem_clock H ck n false *)
          Hint Constructors Is_memory_in_eq.
          Hint Immediate Is_memory_in_EqFby.
          rewrite <-Hlsn in Hmsn.
          destruct Hmsn as [Hmsinv Hsv].
          apply Memory_Corres_eqs_cons.
          split; [|assumption].
          constructor; [|now constructor].
          destruct (Is_memory_in_dec y eqs) as [Hxin|Hxin].
          - (* If we already updated x, we're good. *)
            intro ms'.
            now apply Is_memory_in_Memory_Corres_eqs with (1:=Hxin) (2:=IHeqs1).
          - (* Otherwise our memory is untouched and we don't touch it either *)
            rewrite Hall in Hmc.
            apply Memory_Corres_eqs_app in Hmc.
            destruct Hmc as [H0 Hmc]; clear H0.
            apply Memory_Corres_eqs_cons in Hmc.
            destruct Hmc as [Hmc H0]; clear H0.
            inversion_clear Hmc as [| | |? ? ? ? ? ? Hfindc H0]; clear H0.
            rewrite Hmfind.
            injection 1; intro Hmse; rewrite <-Hmse; clear Hmse.
            apply Hfindc in Hmfind.
            rewrite (Hminv _ Hxin).
            rewrite Hmfind.
            rewrite Hmsinv.
            reflexivity.
        }
      }
Qed.

Lemma is_node_correct:
  forall (G: global)
         (f: ident)
         (fnode: node)
         (xs: stream)
         (M: memory)
         (ys: stream)

         (prog: program)
         (prog': program)
         (fclass: class)
         (n: nat)
         (menv: memoryEnv)
         (env: constEnv)
         (menv': memoryEnv)
         (env': constEnv),

    Welldef_global G

    -> find_node f G = Some fnode
    -> msem_node G f xs M ys

    -> prog = translate G
    -> find_class f prog = Some(fclass, prog')
    -> (forall c, xs n = present c <-> PM.find fclass.(c_input) env = Some c)
    -> (forall x, Is_variable_in x fnode.(n_eqs) -> PM.find x env = None)
    -> stmt_eval prog' menv env fclass.(c_step) (menv', env')

    -> Memory_Corres G n f M menv

    -> (forall c, ys n =present c <-> PM.find (fclass.(c_output)) env' = Some c)
       /\ Memory_Corres G (S n) f M menv'.
Proof.
  induction G as [|node G IH]; [discriminate|].
  intros f fnode xs M ys prog prog' fclass n menv env menv' env'.
  intros Hwd Hfnd Hmsem Hprog Hfcls Hin1 Hother Hstmt Hmc.
  assert (Ordered_nodes (node::G)) as Hord
    by apply Welldef_global_Ordered_nodes with (1:=Hwd).

  simpl in Hfnd.
  destruct (ident_eqb (n_name node) f) eqn:Hfeq.

  Focus 2.
  { assert (node.(n_name) <> f) as Hfneq
        by apply Pos.eqb_neq with (1:=Hfeq).
    rewrite Memory_Corres_node_tl with (1:=Hfneq) (2:=Hord) in Hmc |- *.
    apply IH with (f:=f) (fnode:=fnode) (xs:=xs)
                         (prog:=translate G) (prog':=prog')
                         (menv:=menv) (env:=env)
                         (menv':=menv') (env':=env').
    apply (Welldef_global_cons _ _ Hwd).
    apply Hfnd.
    apply Pos.eqb_neq in Hfeq.
    apply Welldef_global_Ordered_nodes in Hwd.
    apply msem_node_cons with (1:=Hwd) (2:=Hmsem) (3:=Hfeq).
    reflexivity.
    rewrite Hprog in Hfcls; simpl in Hfcls; rewrite Hfeq in Hfcls; exact Hfcls.
    exact Hin1.
    exact Hother.
    exact Hstmt.
    exact Hmc. }
  Unfocus.

  rewrite Hprog in Hfcls; clear Hprog.
  simpl in Hfcls; rewrite Hfeq in Hfcls.
  symmetry in Hfcls; injection Hfcls.
  intros He1 He2; rewrite He1, He2 in *; clear He1 He2 Hfcls.

  injection Hfnd; intro He; rewrite He in *; clear He Hfnd.

  destruct fnode.
  simpl in *.

  inversion_clear Hmsem as [? ? ? ? i o eqs Hfind Hsem].
  simpl in *.
  rewrite Hfeq in Hfind.
  injection Hfind.
  intros; subst.
  clear Hfind.
  destruct Hsem as [H [Hi [Ho [Hclk Hsem]]]].
  specialize Hi with n.
  specialize Ho with n.

  inversion_clear Hwd as [|? ? Hwd' neqs ni no Hwsch Hin2 Hout Hnode Hnd Hfind].
  rename Hwd' into Hwd.
  simpl in *.
  unfold neqs, ni, no in *; clear neqs ni no.
  rewrite ps_from_list_gather_eqs_memories in Hstmt.

  assert ((forall x, Is_variable_in x eqs ->
                     forall c, sem_var H x n (present c)
                               <-> PM.find x env' = Some c)
          /\ Memory_Corres_eqs G (S n) M menv' eqs) as His_step_correct.
  {
    eapply is_step_correct with (mems:=memories eqs) (env:=env) (menv:=menv)
                                (input:=i.(v_name)) (prog:=translate G).
    (* TODO: Tidy this up... *)
    - apply Forall_msem_equation_global_tl
      with (1:=Hord) (2:=Hnd) (3:=Hnode) (4:=Hsem).
    - intros; apply Is_memory_in_memories; assumption.
    - exists []; trivial.
    - exact Hwd.
    - reflexivity.
    - intro c.
      rewrite <- Hin1.
      split; intro HH; [now apply (sem_var_det _ _ _ _ _ Hi HH)
                       |rewrite <- HH; now apply Hi].
    - exact Hother.
    - rewrite Is_memory_in_memories.
      apply not_Is_defined_in_not_Is_memory_in in Hin2.
      exact Hin2.
    - exact Hin2.
    - exact Hwsch.
    - intro; apply Is_memory_in_memories.
    - exact Hstmt.
    - apply (fun f fnode xs M ys prog' fclass menv env menv' env' Hfind Hmsem
             => IH f fnode xs M ys (translate G) prog' fclass
                   n menv env menv' env'
                   Hwd Hfind Hmsem (eq_refl (translate G))).
    - (* TODO: Tidy up this mess... *)
      inversion_clear Hmc.
      simpl in H0.
      rewrite Hfeq in H0.
      injection H0; intros Heq0 Heq1 Heq2;
      rewrite <-Heq0, <-Heq1, <-Heq2 in *;
      clear Heq0 Heq1 Heq2 H0.
      apply Memory_Corres_eqs_node_tl with (1:=Hord) (2:=Hnode) (3:=H1).
  }

  clear IH.
  destruct His_step_correct as [Hvar' Hmc'].
  split.
  - intro c.
    apply Hvar' with (c:=c) in Hout.
    rewrite <- Hout.
    split; intro HH;
      [ rewrite HH in Ho; exact Ho
      | now apply sem_var_det with (1:=Ho) (2:=HH) ].
  - econstructor.
    + simpl; rewrite Pos.eqb_refl; reflexivity.
    + apply Memory_Corres_eqs_node_tl with (1:=Hord) (2:=Hnode) (3:=Hmc').
Qed.

Lemma stmt_eval_translate_reset_eqn_shift:
  forall prog eqs iacc menv env menv' env',
    stmt_eval prog menv env
              (List.fold_left translate_reset_eqn eqs iacc)
              (menv', env')
    <->
    exists menv'' env'',
      stmt_eval prog menv env
                (List.fold_left translate_reset_eqn eqs Skip)
                (menv'', env'')
      /\
      stmt_eval prog menv'' env'' iacc (menv', env').
Proof.
  Hint Constructors stmt_eval.
  induction eqs as [|eq eqs IH].
  - split; [ now eauto | ].
    intro H; do 2 destruct H.
    destruct H as [H0 H1].
    inversion_clear H0; apply H1.
  - intros.
    split.
    + intro H0.
      apply IH in H0.
      destruct H0 as [menv'' [env'' [H0 H1]]].
      destruct eq; [now eauto| |];
      inversion_clear H1;
      exists menv1; exists env1;
      split; try (simpl; apply IH); eauto.
    + intros.
      destruct eq; [ now (apply IH; auto) | |];
      (apply IH;
       simpl in H;
       destruct H as [menv'' [env'' [H0 H1]]];
       apply IH in H0;
       destruct H0 as [menv0 [env0 [H2 H3]]];
       exists menv0; exists env0;
       split; [now auto|];
       inversion_clear H3;
       inversion H0; subst;
       econstructor; eauto).
Qed.

Lemma stmt_eval_translate_reset_eqns_cons:
  forall prog menv env menv' env' (eq:equation) eqs,
    stmt_eval prog menv env (translate_reset_eqns (eq :: eqs)) (menv', env')
    <->
    (exists menv'' env'',
        stmt_eval prog menv env (translate_reset_eqns eqs) (menv'', env'')
        /\ stmt_eval prog menv'' env'' (translate_reset_eqn Skip eq) (menv', env')).
Proof. (* TODO: redo proof *)
  split.
  - intro H.
    unfold translate_reset_eqns in H.
    simpl in H.
    apply stmt_eval_translate_reset_eqn_shift in H.
    destruct H as [menv'' [env'' [H1 H2]]].
    exists menv'', env''.
    split; [now apply H1|now apply H2].
  - intro H.
    destruct H as [menv'' [env'' [H1 H2]]].
    unfold translate_reset_eqns.
    simpl.
    apply stmt_eval_translate_reset_eqn_shift.
    exists menv'', env''.
    split; [now apply H1 | apply H2 ].
Qed.

(* This lemma is stated with Welldef_global rather than simply Ordered_nodes
   since the former gives Is_well_sch for each set of node equations within
   the global environment. In turn, Is_well_sch guarantees that any EqApp
   equation is unique, i.e., given x = EqApp f e, there is no other instance
   of x. This greatly simplifies the induction where it must be shown from

   that

   The case of EqFby is simpler due to the lemma Memory_Corres_eqs_add_mem.
   The comment following this lemma explains why there can be no corresponding
   Memory_Corres_eqs_add_obj lemma. *)
Lemma is_node_reset_correct:
  forall (G: global)
         (f: ident)
         (xs: stream)
         (M: memory)
         (ys: stream)

         (prog': program)
         (fclass: class)
         (menv: memoryEnv)
         (env: constEnv)
         (menv': memoryEnv)
         (env': constEnv),

       Welldef_global G
    -> msem_node G f xs M ys

    -> find_class f (translate G) = Some(fclass, prog')
    -> stmt_eval prog' menv env fclass.(c_reset) (menv', env')

    -> Memory_Corres G 0 f M menv'.
Proof.
  induction G as [|node G IH]; [now inversion 1|].
  intros until env'.
  intros Hwdef Hmsem Hfindc Heval.
  pose proof (Welldef_global_Ordered_nodes _ Hwdef) as Hord.
  assert (Hmsem0:=Hmsem).
  inversion_clear Hmsem as [? ? ? ? i' o' eqs' Hfind Hmsem'].
  assert (Hfind':=Hfind).
  simpl in Hfind,Hfindc.
  destruct (ident_eqb (n_name node) f) eqn:Heqb;
    [ apply Pos.eqb_eq in Heqb | apply Pos.eqb_neq in Heqb ].
  - clear Hmsem0.
    destruct node as [name i o eqs].
    injection Hfind; intro He; rewrite <-He in *; clear He Hfind.
    intros HR1 HR2 HR3; rewrite <-HR1,<-HR2,HR3 in *; clear HR1 HR2 HR3.
    econstructor; [exact Hfind'|clear Hfind'].
    injection Hfindc;
      intros HR1 HR2; rewrite <-HR1,<-HR2 in *; clear HR1 HR2 Hfindc.
    destruct Hmsem' as [H [Hxs [Hys [Hclk Hmsem]]]].
    simpl in Heval.
    assert (HordF:=Hord).
    inversion_clear Hord as [|? ? Hord' Hnin Hnneq].
    apply Memory_Corres_eqs_node_tl with (1:=HordF);
      [intro Hini; apply Hnin in Hini; intuition|].
    simpl in *.

    apply Forall_msem_equation_global_tl with (1:=HordF) in Hmsem;
      [| intros g HH; apply find_node_Exists; apply Hnin in HH; now intuition
       | intro HH; apply Hnin in HH; intuition ].
    clear HordF Hclk.

    inversion_clear Hwdef as [|? ? Hwdef' neqs ni no Hwsch HO1 HO2 HO3 HO4 HO5].
    simpl in neqs, ni.
    unfold neqs, ni in *.
    clear HO1 HO2 HO3 HO4 HO5 neqs ni no.
    revert Hwsch.
    generalize (PS.add (v_name i) (memories eqs)) as mems.
    intros mems Hwsch.

    revert menv' env' Heval.
    induction eqs as [|eq eqs IHeqs]; [now constructor|].

    intros menv'' env'' Heval.
    unfold translate_reset_eqns in Heval.
    apply stmt_eval_translate_reset_eqns_cons in Heval.
    destruct Heval as [menv' [env' [Hevals Heval]]].

    apply Forall_cons2 in Hmsem.
    destruct Hmsem as [Hmsem Hmsems].
    assert (forall g, Is_node_in g eqs
              -> g <> f /\ List.Exists (fun n => g = n_name n) G) as Hnin'.
    { intros g Hgini.
      assert (Is_node_in g (eq::eqs)) as Hgini'.
      constructor 2; exact Hgini.
      now apply Hnin with (1:=Hgini'). }
    pose proof (IHeqs Hmsems Hnin' (Is_well_sch_cons _ _ _ Hwsch) _ _ Hevals)
      as Hmc.
    clear IHeqs Hnin' Hmsems Hevals.

    destruct eq as [x e|x g e|x v0 e]; simpl in Heval.
    + constructor. inversion Heval.
      match goal with H:menv' = menv'' |- _ => rewrite <-H; apply Hmc end.
    + inversion_clear Hwsch as [| |? ? ? ? Hwsch' Hdeps Hnii|].
      clear Hwsch' Hdeps.

      inversion_clear Hmsem as [|? ? ? ? Mo ? ? ? Hmfind' Hls Hxs0 Hmsem'|].
      inversion_clear Heval
        as [| | | |? ? ? ? ? env0 menv0 ? ? Heval0 Heval1| | | | |].
      inversion Heval1 as [| | | | | | | | |? ? ? HR1 HR2 HR3 HR4 [HR5 HR6]].
      rewrite HR5,HR6 in *; clear HR1 HR2 HR3 HR4 HR5 HR6 Heval1.

      assert(Hmsem'':=Hmsem').
      inversion_clear Hmsem'' as [? ? ? ? ? ? ? Hfindn Hmsem].
      destruct Hmsem as [H' [Hls' [Hxs0' Hmsem]]].
      inversion_clear Heval0 as [| | |? ? ? ? ? ? ? Hreset Hadd| | | | | |].
      inversion_clear Hreset as [? ? ? ? ? ? Hfindc Hreset'].

      constructor.
      * intros Mo' omenv'' Hmfind Hfindo.
        rewrite Hmfind in Hmfind';
          injection Hmfind'; intro He;
          rewrite <-He in *; clear He Hmfind'.
        eapply IH with (1:=Hwdef') (2:=Hmsem') (3:=Hfindc).
        rewrite <-Hadd in Hfindo.
        rewrite find_obj_gss in Hfindo.
        injection Hfindo; intro He; rewrite He in *; clear He Hfindo.
        apply Hreset'.
      * rewrite <-Hadd.
        now apply Memory_Corres_eqs_add_obj with (1:=Hmc) (2:=Hnii).
    + inversion Heval
        as [| | | |? ? ? ? ? ? ? ? ? Heval0 Heval1| | | | |].
      inversion Heval1
        as [| | | | | | | | |? ? ? HR1 HR2 HR3 HR4 [HR5 HR6]].
      rewrite HR5,HR6 in *; clear HR1 HR2 HR3 HR4 HR5 HR6.
      inversion_clear Heval0
        as [| ? ? ? ? ? ? ? Heval' Haddm| | | | | | | |].
      rewrite <-Haddm.
      inversion_clear Hmsem
        as [| |? ? ? ? ? ? ? Hfindm Hms0 HH0 HH1]; clear HH0 HH1.
      inversion Heval' as [| |c HR1 HR2].
      rewrite <-HR2 in *; clear HR1 HR2.
      rewrite <-Hms0.

      constructor;
        [| now apply Memory_Corres_eqs_add_mem with (1:=Hfindm) (2:=Hmc)].
      intros ms' Hfindm'.
      rewrite Hfindm in Hfindm';
        injection Hfindm'; intro He; rewrite <-He in *; clear He Hfindm'.
      rewrite find_mem_gss.
      rewrite Hms0.
      reflexivity.
  - apply Memory_Corres_node_tl with (1:=Heqb) (2:=Hord).
    eapply IH.
    + inversion_clear Hwdef; assumption.
    + now apply msem_node_cons with (1:=Hord) (2:=Hmsem0) (3:=Heqb).
    + exact Hfindc.
    + exact Heval.
Qed.

Lemma is_translate_correct:
  forall (G: global)
         (f: ident)
         (xs: stream)
         (ys: stream)
         (ci: const)
         (r: ident)
         (obj: ident)
         (n: nat)
         (menv: memoryEnv)
         (env: constEnv),

    Welldef_global G
    -> sem_node G f xs ys
    -> (forall n, xs n = present ci)
    -> stmt_eval (translate G) mempty empty
                 (Comp (Reset_ap f obj)
                       (Repeat (S n) (Step_ap r f obj (Const ci)))) (menv, env)
    -> (forall co, ys n = present co <-> PM.find r env = Some co).
Proof.
  intros until env.
  intros Hwdef Hsem Hxs Heval.
  apply sem_msem_node in Hsem.
  destruct Hsem as [M Hsem].
  inversion_clear Heval
    as [| | | |? ? ? ? ? env0 menv0 ? ? Hevalr Hevals| | | | |].
  inversion_clear Hevalr as [| | |? ? ? ? ? omenv0 ? Hreset Hmenv0| | | | | | ].
  inversion_clear Hreset as [? ? ? ? ? ? Hfindr Hevalr].
  assert (Memory_Corres G 0 f M omenv0) as Hmc0
    by apply is_node_reset_correct
       with (1:=Hwdef) (2:=Hsem) (3:=Hfindr) (4:=Hevalr).

  assert(Hsem':=Hsem).
  inversion_clear Hsem' as [? ? ? ? ? ? ? Hfindn Hsem''].
  destruct Hsem'' as [H [Hi [Ho [Hclk Hsem']]]].

  assert ((forall co, ys n = present co <-> PM.find r env = Some co)
          /\ (match find_obj obj menv with
              | None => False
              | Some omenv => Memory_Corres G (S n) f M omenv
              end)) as Hinv.
  (* TODO: Ugly, dumb proof. How to streamline / beautify all these
           inversions and rewrites. *)
  { revert menv env Hevals.
    induction n as [|? IH].
    - intros menv env Hevals.
      inversion Hevals as [| | | | | | | |? ? ? ? ? ? ? ? ? Heval0 Heval1
                                            HR1 HR2 HR3 [HR4 HR5] [HR6 HR7]|].
      clear HR1 HR2 HR3 HR4 HR5 HR6 HR7 Hevals menv1 env1 menv3 env3 a.
      inversion Heval0 as [| | | | | | |? ? ? ? HR1 HR2 HR3 HR4 [HR5 HR6]| |].
      rewrite <-HR5,<-HR6 in *.
      clear HR1 HR2 HR3 HR4 HR5 HR6 Heval0 menv1 env1 menv2 env2 prog0 a n.
      inversion_clear Heval1
        as [| |? ? ? ? ? ? ? ? ? ?
                 omenv omenv' rc Hfindo Hexp Hstep Hmenv Henv| | | | | | | ].
      rewrite <-Hmenv,<-Henv in *; clear Hmenv Henv.
      rewrite find_obj_gss.
      inversion Hexp as [| |? HR1 HR2].
      rewrite <-HR2 in *; clear HR1 HR2 c.
      rewrite PM.gss.
      inversion_clear Hstep as [? ? ? ? ? ? ? ? ? Hfindc Heval Hfindov].
      rewrite Hfindr in Hfindc.
      injection Hfindc; intros HR1 HR2;
        rewrite <-HR1,<-HR2 in *; clear HR1 HR2 Hfindc.
      rewrite <-Hfindov.

      eapply is_node_correct
      with (1:=Hwdef) (2:=Hfindn) (3:=Hsem) (4:=eq_refl (translate G))
                      (5:=Hfindr) (8:=Heval).
      + rewrite PM.gss.
        specialize Hxs with 0%nat.
        split; intro HH; [rewrite Hxs in HH|];
        injection HH; intro He; rewrite He in *;
        intuition.
      + pose proof (find_node_translate_find_class _ _ _ Hfindn) as Htrans.
        destruct Htrans as [prog'' Htrans].
        rewrite Hfindr in Htrans.
        injection Htrans; intros HR1 HR2; rewrite HR1,<-HR2 in *.

        apply Welldef_global_input_not_Is_defined_in with (1:=Hwdef) in Hfindn.
        simpl in *.
        intros x Hxivi.
        rewrite PM.gso; [rewrite PM.gempty; reflexivity|].
        intro Hxcls.
        apply Is_variable_in_Is_defined_in in Hxivi.
        rewrite Hxcls in Hxivi.
        rewrite HR2 in Hxivi.
        unfold translate_node in Hxivi.
        simpl in Hxivi.
        contradiction.
      + rewrite <-Hmenv0 in Hfindo.
        rewrite find_obj_gss in Hfindo.
        injection Hfindo; intro He; rewrite He in *; clear He.
        exact Hmc0.
    - intros menv env Hevals.
      inversion Hevals
        as [| | | | | | | |? ? ? ? ? ? ? ? ? Hevals' Heval
                             HR0 HR1 HR2 [HR3 HR4] [HR5 HR6]|].
      clear HR0 HR1 HR2 HR3 HR4 HR5 HR6.
      apply IH in Hevals'; clear IH.
      destruct Hevals' as [Hout Hmc]; clear Hout.
      inversion_clear Heval
        as [| |? ? ? ? ? ? ? ? ? ?
                 omenv omenv' rc Hfindo Hexp Hstep Hmenv Henv| | | | | | | ].
      rewrite <-Hmenv,<-Henv in *.
      rewrite Hfindo in Hmc.
      rewrite find_obj_gss.
      inversion Hexp as [| |? HR1 HR2].
      rewrite <-HR2 in *; clear HR1 HR2 c.
      rewrite PM.gss.
      inversion_clear Hstep as [? ? ? ? ? ? ? ? ? Hfindc Heval Hfindov].
      rewrite Hfindr in Hfindc.
      injection Hfindc; intros HR1 HR2;
        rewrite <-HR1,<-HR2 in *; clear HR1 HR2 Hfindc.
      rewrite <-Hfindov.

      eapply is_node_correct
      with (1:=Hwdef) (2:=Hfindn) (3:=Hsem) (4:=eq_refl (translate G))
           (5:=Hfindr) (8:=Heval) (9:=Hmc).
      + rewrite PM.gss.
        specialize Hxs with (S n).
        split; intro HH; [rewrite Hxs in HH|];
        injection HH; intro He; rewrite He in *;
        intuition.
      + pose proof (find_node_translate_find_class _ _ _ Hfindn) as Htrans.
        destruct Htrans as [prog'' Htrans].
        rewrite Hfindr in Htrans.
        injection Htrans; intros HR1 HR2; rewrite HR1,<-HR2 in *.

        apply Welldef_global_input_not_Is_defined_in with (1:=Hwdef) in Hfindn.
        simpl in *.
        intros x Hxivi.
        rewrite PM.gso; [rewrite PM.gempty; reflexivity|].
        intro Hxcls.
        apply Is_variable_in_Is_defined_in in Hxivi.
        rewrite Hxcls in Hxivi.
        rewrite HR2 in Hxivi.
        unfold translate_node in Hxivi.
        simpl in Hxivi.
        contradiction.
  }

  intro co.
  destruct n; [now auto|].
  destruct Hinv as [Hinv0 Hinv1].
  now apply Hinv0.
Qed.

