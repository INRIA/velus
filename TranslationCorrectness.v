Require Import Rustre.Common.
Require Import Rustre.DataflowSyntax.

(* ** Definitions on imperative statements *)

Require Import Rustre.Minimp.
Require Import Rustre.Translation.
Require Import Rustre.DataflowNatSemantics.
Require Import Rustre.SynchronousNat.

(* TODO:
   - Assume we are given a list of dataflow equations eqs satisfying
        sch_eqs (memories eqs) PS.empty (defined eqs) eqs
   - Show that the step function generated by translate_eqs is correct,
     i.e., that its semantics correspond to the 'held semantics' of the
     original dataflow equations.
   - The 'held semantics' use holdR rather than fbyR for defining 'fby'.
   - Basic invariant for a single pass (to show by induction along the list
     of dataflow equations/sequence of conditional assignments):
        forall x,
             (PS.In x (PS.inter memories written) -> M x = H x (S n))
          /\ (PS.In x (PS.diff memories written) -> M x = H x n)
          /\ (PS.In x (PS.diff written memories) ->
              H x n = present c -> p x = c)

   - Afterward, this must be extended to run (i.e., forall n from 0).
   - and we must switch back to the standard fby semantics for instants
     where a clock is active.
 *)

Lemma pm_in_dec: forall A i m, PM.In (A:=A) i m \/ ~PM.In (A:=A) i m.
Proof.
  unfold PM.In, PM.MapsTo.
  intros A i m.
  case (PM.find i m).
  eauto.
  right; intro; destruct H; discriminate H.
Qed.

(** ** Predicates *)

(**
   The list of equations should be in reverse order: the first
   equation to execute should be the last in the list.

   The set 'mems' should include any input variables. The relevant
   clause is written:
          (PS.In i mems -> ~Is_defined_in i eqs)

   rather than:
          (PS.In i mems -> ~Is_memory_in i eqs)

   To require that such input variables are not redefined in eqs.
*)
Inductive Is_well_sch (mems: PS.t) : list equation -> Prop :=
| WSchEqDef:
    forall x e eqs,
      Is_well_sch mems eqs ->
      (forall i, Is_free_in_caexp i e ->
                    (PS.In i mems -> ~Is_defined_in i eqs)
                 /\ (~PS.In i mems -> Is_variable_in i eqs)) ->
      Is_well_sch mems (EqDef x e :: eqs)
| WSchEqApp:
    forall x f e eqs,
      Is_well_sch mems eqs ->
      (forall i, Is_free_in_laexp i e ->
                    (PS.In i mems -> ~Is_defined_in i eqs)
                 /\ (~PS.In i mems -> Is_variable_in i eqs)) ->
      Is_well_sch mems (EqApp x f e :: eqs)
| WSchEqFby:
    forall x v e eqs,
      Is_well_sch mems eqs ->
      PS.In x mems ->
      (forall i, Is_free_in_laexp i e ->
                    (PS.In i mems -> ~Is_defined_in i eqs)
                 /\ (~PS.In i mems -> Is_variable_in i eqs)) ->
      Is_well_sch mems (EqFby x v e :: eqs).

Lemma Is_well_sch_cons:
  forall m eq eqs, Is_well_sch m (eq :: eqs) -> Is_well_sch m eqs.
Proof. inversion 1; auto. Qed.

Lemma Is_well_sch_free_variable:
  forall x eq eqs mems,
    Is_well_sch mems (eq :: eqs)
    -> Is_free_in_equation x eq
    -> ~ PS.In x mems
    -> Is_variable_in x eqs.
Proof.
  intros x eq eqs mems Hwsch Hfree Hnim.
  destruct eq;
    inversion_clear Hwsch as [? ? ? ? Hp|? ? ? ? ? Hp|? ? ? ? ? ? Hp];
    inversion_clear Hfree as [? ? ? Hc|? ? ? ? Hc|? ? ? ? Hc];
    apply Hp in Hc;
    intuition.
Qed.

Lemma Is_well_sch_free_variable_in_mems:
  forall y eq eqs mems,
    Is_well_sch mems (eq :: eqs)
    -> Is_free_in_equation y eq
    -> PS.In y mems
    -> ~Is_defined_in y eqs.
Proof.
  intros x eq eqs mems Hwsch Hfree Hnim.
  destruct eq;
    inversion_clear Hwsch as [? ? ? ? Hp|? ? ? ? ? Hp|? ? ? ? ? ? Hp];
    inversion_clear Hfree as [? ? ? Hc|? ? ? ? Hc|? ? ? ? Hc];
    apply Hp in Hc;
    destruct Hc as [Hc0 Hc1];
    apply Hc0 in Hnim;
    apply Hnim.
Qed.

Lemma Is_wsch_is_defined_in:
  forall x eq eqs mems,
    Is_well_sch mems (eq :: eqs) ->
    Is_defined_in x (eq :: eqs) ->
    Is_defined_in_eq x eq
    \/ (~Is_defined_in_eq x eq /\ Is_defined_in x eqs).
Proof.
  intros x eq eqs mems Hwsch Hdef.
  apply List.Exists_cons in Hdef.
  destruct (Is_defined_in_eq_dec x eq); intuition.
Qed.

Lemma Is_wsch_Is_memory_in_mems:
  forall mems x eqs,
    Is_well_sch mems eqs ->
    Is_memory_in x eqs ->
    PS.In x mems.
Proof.
  induction eqs as [|eq]; [inversion 1|].
  intros Hwsch Himi.
  apply Is_memory_in_cons in Himi.
  destruct Himi as [Himi|Himi].
  - destruct eq; inversion_clear Himi; auto.
    inversion_clear Hwsch; auto.
  - apply Is_well_sch_cons in Hwsch.
    destruct Himi as [? Himi].
    auto.
Qed.

(* TODO: Write a function to decide
            {Is_well_sch mems eqs}+{~Is_well_sch mems eqs}
         and test it on the example programs in DataflowSyntax.v
*)

Lemma stmt_eval_translate_eqns_cons:
  forall mems menv env menv' env' eq eqs,
    stmt_eval menv env (translate_eqns mems (eq :: eqs)) (menv', env')
    <->
    (exists menv'' env'',
        stmt_eval menv env (translate_eqns mems eqs) (menv'', env'')
        /\ stmt_eval menv'' env'' (translate_eqn mems eq) (menv', env')).
Proof. (* TODO: redo proof *)
  split.
  - intro H.
    unfold translate_eqns in H.
    simpl in H.
    apply stmt_eval_fold_left_shift in H.
    destruct H as [menv'' H].
    destruct H as [env'' H].
    exists menv''. exists env''.
    destruct H as [H1 H2].
    split. apply H1.
    inversion_clear H2.
    inversion H0.
    rewrite <- H2.
    rewrite <- H4.
    apply H.
  - intro H.
    destruct H as [menv'' H].
    destruct H as [env'' H].
    destruct H as [H1 H2].
    unfold translate_eqns.
    simpl.
    apply stmt_eval_fold_left_shift.
    exists menv''. exists env''.
    split. apply H1.
    eapply Icomp. apply H2.
    apply Iskip.
Qed.

Inductive Is_present_in (mems: PS.t) (menv: memoryEnv) (env: valueEnv)
  : clock -> Prop :=
| IsCbase: Is_present_in mems menv env Cbase
| IsCon:
    forall ck c v,
      Is_present_in mems menv env ck
      -> exp_eval menv env (tovar mems c) (Cbool v)
      -> Is_present_in mems menv env (Con ck c v).

Lemma exp_eval_tovar_Cbool_dec:
  forall menv env mems c v,
    {exp_eval menv env (tovar mems c) (Cbool v)}
    + {~exp_eval menv env (tovar mems c) (Cbool v)}.
Proof.
  Ltac no_match := right; inversion_clear 1; try unfold find_mem in *;
                   match goal with
                   | H: PM.find _ _ = _ |- _ => rewrite H in *; discriminate
                   end.
  intros menv env mems c v.
  unfold tovar.
  destruct (PS.mem c mems).
  - case_eq (find_mem c menv).
    + intro c0; destruct c0.
      * no_match.
      * destruct b; destruct v; (left; apply estate; assumption) || no_match.
    + no_match.
  - case_eq (PM.find c env).
    + intro c0; destruct c0.
      * no_match.
      * destruct b; destruct v; (left; apply evar; assumption) || no_match.
    + no_match.
Qed.

Lemma Is_present_in_dec:
  forall mems menv env ck,
    {Is_present_in mems menv env ck}+{~Is_present_in mems menv env ck}.
Proof.
  intros.
  induction ck.
  - left; constructor.
  - destruct IHck.
    + destruct (exp_eval_tovar_Cbool_dec menv env mems i b); destruct b;
      (left; constructor; assumption) || right; inversion_clear 1; auto.
    + right; inversion_clear 1; auto.
Qed.

Lemma stmt_eval_Control:
  forall menv env mems c s menv' env',
    stmt_eval menv env (Control mems c s) (menv', env')
    -> (Is_present_in mems menv env c /\  stmt_eval menv env s (menv', env'))
       \/ (~Is_present_in mems menv env c /\ menv' = menv /\ env' = env).
Proof.
  Hint Constructors Is_present_in.
  intros menv env mems c s menv' env' Hs.
  induction c.
  - intuition.
  - destruct (Is_present_in_dec mems menv env (Con c i b)) as [Hp|Hnp];
    [ left | right ];
    destruct b; inversion_clear Hs;
    try match goal with
        | H:stmt_eval _ _ (Control _ _ _) _ |- _ => apply IHc in H;
            destruct H; destruct H
        | H:stmt_eval _ _ Skip _ |- _ => inversion H
        end;
    try match goal with
        | Hn: ~Is_present_in _ _ _ _, H: Is_present_in _ _ _ _ |- _ =>
          inversion_clear H; contradiction
        end;
    try (inversion_clear Hp;
         match goal with
         | H0: exp_eval _ _ _ (Cbool false),
           H1: exp_eval _ _ _ (Cbool true) |- _ =>
           discriminate (exp_eval_det _ _ _ _ _ H0 H1)
         end);
    try match goal with
        | Hm: menv = _, He: env = _ |- _ => rewrite Hm, He in *
        end;
    auto;
    contradict Hnp; auto.
Qed.

Lemma stmt_eval_translate_cexp_menv_inv:
  forall menv env mems x menv' env' ce,
    stmt_eval menv env (translate_cexp mems x ce) (menv', env')
    -> menv' = menv.
Proof.
  intros menv env mems x menv' env'.
  induction ce using cexp_mult
  with (P := (fun cae : caexp =>
                stmt_eval menv env (translate_caexp mems x cae) (menv', env') ->
                menv' = menv));
  (apply IHce || inversion_clear 1); auto.
Qed.

Lemma stmt_eval_translate_cexp_env_add:
  forall menv env mems x menv' env' ce,
    stmt_eval menv env (translate_cexp mems x ce) (menv', env')
    -> exists c, env' = PM.add x c env.
Proof.
  intros menv env mems x menv' env'.
  induction ce using cexp_mult
  with (P := (fun cae : caexp =>
                stmt_eval menv env (translate_caexp mems x cae) (menv', env') ->
                exists c, env' = PM.add x c env));
    (apply IHce || inversion_clear 1); auto.
  exists v; rewrite <- H1; intuition.
Qed.

Lemma not_Is_memory_in_eq:
  forall x eq menv env mems menv' env',
    ~Is_memory_in_eq x eq
    -> stmt_eval menv env (translate_eqn mems eq) (menv', env')
    -> find_mem x menv' = find_mem x menv.
Proof.
  intros x eq menv env mems menv' env' Hneq Heval.
  destruct eq as [y cae|y f lae|y v0 lae].
  destruct cae.
  simpl in Heval.
  apply stmt_eval_Control in Heval; destruct Heval as [Heval|Heval];
  destruct Heval as [Heval1 Heval2].
  apply stmt_eval_translate_cexp_menv_inv in Heval2.
  rewrite Heval2. intuition.
  destruct Heval2 as [Hmenv]; rewrite Hmenv; intuition.
  admit. (* TODO: node application *)

  apply not_Is_memory_in_eq_EqFby in Hneq.
  unfold translate_eqn in Heval.
  destruct lae.
  apply stmt_eval_Control in Heval; destruct Heval as [Heval|Heval];
  destruct Heval as [Hipi Heval].
  inversion_clear Heval.
  rewrite <- H0.
  unfold find_mem, add_mem.
  simpl; rewrite PM.gso; [intuition | apply Hneq].
  destruct Heval as [Hmenv Henv]; rewrite Hmenv; intuition.
Qed.

Lemma not_Is_variable_in_eq:
  forall x eq menv env mems menv' env',
    ~Is_variable_in_eq x eq
    -> stmt_eval menv env (translate_eqn mems eq) (menv', env')
    -> PM.find x env' = PM.find x env.
Proof.
  intros x eq menv env mems menv' env' Hnd Heval.
  destruct eq as [y e|y f e|y v0 e];
  try apply not_Is_variable_in_eq_EqDef in Hnd.
  (unfold translate_eqn in Heval;
   destruct e;
   apply stmt_eval_Control in Heval; destruct Heval as [Heval|Heval];
   destruct Heval as [Hipi Heval]; [
     apply stmt_eval_translate_cexp_env_add in Heval;
     destruct Heval; rewrite H;
     rewrite PM.gso; [intuition | apply Hnd]
   | destruct Heval as [Hmenv Henv]; rewrite Henv; intuition]).
  admit. (* TODO: node application *)
  simpl in Heval; destruct e.
  apply stmt_eval_Control in Heval; destruct Heval as [Heval|Heval];
  destruct Heval as [Heval1 Heval2].
  inversion Heval2; intuition.
  destruct Heval2 as [Hmenv Henv]; rewrite Henv; intuition.
Qed.

Lemma stmt_eval_translate_eqns_menv_inv:
  forall menv env mems eqs menv' env',
    stmt_eval menv env (translate_eqns mems eqs) (menv', env')
    -> (forall x, ~Is_memory_in x eqs ->
                  find_mem x menv' = find_mem x menv).
Proof.
  induction eqs as [ |eq].
  + inversion_clear 1; reflexivity.
  + intros menv' env' Heval x Hnmem.
    apply not_Is_memory_in_cons in Hnmem.
    destruct Hnmem as [H0 H1].
    apply stmt_eval_translate_eqns_cons in Heval.
    destruct Heval as [menv'' Heval];
      destruct Heval as [env'' Heval];
      destruct Heval as [Heval0 Heval1].
    apply IHeqs with (x:=x) (2:=H1) in Heval0.
    apply not_Is_memory_in_eq with (1:=H0) in Heval1.
    rewrite Heval1, Heval0.
    reflexivity.
Qed.

Lemma stmt_eval_translate_eqns_env_inv:
  forall menv env mems eqs menv' env',
    stmt_eval menv env (translate_eqns mems eqs) (menv', env')
    -> (forall x, ~Is_variable_in x eqs ->
                  PM.find x env' = PM.find x env).
Proof.
  induction eqs as [ |eq].
  + inversion_clear 1; reflexivity.
  + intros menv' env' Heval x Hndef.
    apply not_Is_variable_in_cons in Hndef.
    destruct Hndef as [H0 H1].
    apply stmt_eval_translate_eqns_cons in Heval.
    destruct Heval as [menv'' Heval];
      destruct Heval as [env'' Heval];
      destruct Heval as [Heval0 Heval1].
    apply IHeqs with (x:=x) (2:=H1) in Heval0.
    apply not_Is_variable_in_eq with (1:=H0) in Heval1.
    rewrite Heval1, Heval0.
    reflexivity.
Qed.

Inductive sem_held_equation (H: history) (H': history) : equation -> Prop :=
| SHEqDef:
    forall x cae,
      (forall n c, sem_var H x n (present c) -> sem_var H' x n (present c))
      -> sem_held_equation H H' (EqDef x cae)
| SHEqApp:
    forall x f lae,
      (forall n c, sem_var H x n (present c) -> sem_var H' x n (present c))
      -> sem_held_equation H H' (EqApp x f lae)
| SHEqFby:
    forall x v0 lae ys,
      (forall n, sem_laexp H lae n (ys n))
      -> (forall n c, sem_var H' x n (present c) <-> holdR v0 ys n c)
      -> sem_held_equation H H' (EqFby x v0 lae).

Definition sem_held_equations
           (H: history) (H': history) (eqs: list equation) : Prop :=
  List.Forall (sem_held_equation H H') eqs.

Lemma sem_held_equations_tl:
  forall H H' eq eqs,
    sem_held_equations H H' (eq::eqs) -> sem_held_equations H H' eqs.
Proof.
  intros H H' eq eqs Hsem.
  apply Forall_cons2 in Hsem.
  intuition.
Qed.

Lemma holdR_ext:
  forall xs ys,
    (forall n, xs n = ys n)
    -> forall v0 n c,
      holdR v0 xs n c
      <-> holdR v0 ys n c.
Proof.
  intros xs ys Heq.
  induction n.
  - split; inversion 1; constructor.
  - intro c.
    split;
    (inversion 1 as [|? ? Hv Hhold|? ? Hv];
     (rewrite Heq in Hv || rewrite <- Heq in Hv);
     [ apply IHn in Hhold; now constructor
     | apply holdR_present with (1:=Hv) ]).
Qed.

Lemma fbyR_holdR:
  forall v0 xs n c,
    fbyR v0 xs n (present c)
    -> holdR v0 xs n c.
Proof.
  inversion 1; intuition.
Qed.

Lemma sem_held_equations_corres:
  forall G H H' eqs,
    sem_equations G H eqs
    -> sem_held_equations H H' eqs
    -> (forall x n c,
           Is_defined_in x eqs
           -> sem_var H x n (present c)
           -> sem_var H' x n (present c)).
Proof.
  induction eqs as [|eq]; [inversion 3|].
  intros Hs Hsh x n c Hdef Hsv.
  apply Forall_cons2 in Hs; destruct Hs as [Hseq Hseqs];
  apply Forall_cons2 in Hsh; destruct Hsh as [Hsheq Hsheqs];
  apply Is_defined_in_cons in Hdef; destruct Hdef as [Hdef|Hdef];
  [ | destruct Hdef as [Hndef Hdef];
      apply (IHeqs Hseqs Hsheqs _ _ _ Hdef Hsv) ].
  destruct eq as [| |y v0 lae]; inversion Hdef; subst;
  inversion_clear Hsheq as [? ? HH|? ? ? HH|? ? ? ys Hys HH];
  apply HH; try apply Hsv.

  inversion_clear Hseq as [| |? xs ? ? Hxs Hfby].
  assert (forall n, xs n = ys n) as Hxsys by
        (intro n0;
         specialize Hys with n0;
         specialize Hxs with n0 (xs n0);
         apply sem_laexp_det with H n0 lae;
         (apply Hxs; reflexivity) || apply Hys).
  apply Hfby in Hsv.
  rewrite <- (holdR_ext _ _ Hxsys).
  apply fbyR_holdR with (1:=Hsv).
Qed.

Section StreamGenerators.

  Variable H: history.
  Variable arbitrary : stream.

  Definition const_eqb (c1: const) (c2: const) : bool :=
    match (c1, c2) with
    | (Cint z1, Cint z2) => BinInt.Z.eqb z1 z2
    | (Cbool b1, Cbool b2) => Bool.eqb b1 b2
    | _ => false
    end.

  Definition value_eqb (v1: value) (v2: value) : bool :=
    match (v1, v2) with
    | (present c1, present c2) => const_eqb c1 c2
    | (absent, absent) => true
    | _ => false
    end.

  Fixpoint str_clock (ck: clock) (n: nat) : bool :=
    match ck with
    | Cbase => true
    | Con ck' x c => match PM.find x H with
                     | None => false
                     | Some xs => andb (str_clock ck' n)
                                       (value_eqb (xs n) (present (Cbool c)))
                     end
    end.

  Fixpoint str_lexp (e: lexp) (n: nat) : value :=
    match e with
    | Econst c => present c
    | Evar x => match PM.find x H with
                | Some xs => xs n
                | None => absent
                end
    | Ewhen e' x c => match PM.find x H with
                      | Some xs => match xs n with
                                   | present (Cbool b) =>
                                     if Bool.eqb b c
                                     then str_laexp e' n
                                     else absent
                                   | _ => absent
                                   end
                      | None => absent
                      end
    end
  with str_laexp (e: laexp) (n: nat) : value :=
    match e with
    | LAexp ck e => if str_clock ck n then str_lexp e n else absent
    end.

  Lemma str_clock_spec:
    forall ck n c,
      sem_clock H ck n c
      -> str_clock ck n = c.
  Proof.
    induction ck.
    inversion 1; intuition.
    intros n c.
    inversion_clear 1;
      repeat progress (simpl;
         match goal with
         | H:sem_var _ _ _ _ |- _ => inversion_clear H
         | H: PM.find _ _ = _ |- _ => rewrite H
         | H: _ = present (Cbool ?b) |- _ => (rewrite H; destruct b)
         | H: sem_clock _ _ _ _ |- _ => (apply IHck in H; rewrite H)
         | H: b <> _ |- _ => (apply Bool.not_true_is_false in H
                              || apply Bool.not_false_is_true in H;
                              rewrite H)
         | _ => (cbv; reflexivity)
         end).
    destruct (PM.find i H); cbv; reflexivity.
  Qed.

  Lemma str_lexp_spec:
    forall e n v,
      sem_lexp H e n v
      -> str_lexp e n = v.
  Proof.
    induction e using lexp_mult
    with (P:=fun e => forall n v, sem_laexp H e n v -> str_laexp e n = v);
    inversion 1;
    repeat progress (simpl;
           match goal with
           | H:sem_lexp _ _ _ _ |- _ => (apply IHe in H; rewrite H)
           | H:sem_laexp _ _ _ _ |- _ => (apply IHe in H; rewrite H)
           | H:sem_clock _ _ _ _ |- _ => (apply str_clock_spec in H; rewrite H)
           | H:sem_var _ _ _ _ |- _ => (inversion_clear H as [xs Hfind Hxsn];
                                        rewrite Hfind; rewrite Hxsn)
           | |- (if Bool.eqb ?b1 ?b2 then _ else _) = _ =>
             try destruct b1; try destruct b2; simpl; intuition
           | _ => intuition
           end).
  Qed.

  Lemma str_laexp_spec:
    forall e n v,
      sem_laexp H e n v
      -> str_laexp e n = v.
  Proof.
    inversion_clear 1; simpl;
    repeat progress
           match goal with
           | H:sem_clock _ _ _ _ |- _ => (apply str_clock_spec in H; rewrite H)
           | H:sem_lexp _ _ _ _ |- _ => (apply str_lexp_spec in H; rewrite H)
           | _ => intuition
           end.
  Qed.

End StreamGenerators.

Definition hold_history (H: history) : history -> list equation -> history :=
  List.fold_right
    (fun eq H' =>
       match eq with
       | EqFby x v0 e => PM.add x (fun n=>present (hold v0 (str_laexp H e) n)) H'
       | EqApp x _ _ => H'
       | EqDef x _ => H'
       end).

Lemma hold_injection:
  forall xs ys c n,
    (forall n, xs n = ys n)
    -> hold c xs n = hold c ys n.
Proof.
  intros xs ys c n Heq.
  induction n.
  auto.
  case_eq (xs n).
  intro Habs.
  assert (ys n = absent) as Habs' by (rewrite Heq in Habs; intuition).
  unfold hold.
  rewrite Habs. rewrite Habs'.
  fold hold.
  apply IHn.

  intros v Habs.
  assert (ys n = present v) as Habs' by (rewrite Heq in Habs; intuition).
  unfold hold.
  rewrite Habs. rewrite Habs'.
  reflexivity.
Qed.

Lemma Some_injection:
  forall A (x:A) (y:A), x = y <-> Some x = Some y.
Proof.
  split; intro H; [rewrite H|injection H]; auto.
Qed.

Lemma present_injection:
  forall x y, x = y <-> present x = present y.
Proof.
  split; intro H; [rewrite H|injection H]; auto.
Qed.

Lemma sem_var_gso:
  forall x y xs n v H,
    x <> y
    -> (sem_var (PM.add x xs H) y n v <-> sem_var H y n v).
Proof.
  split; inversion_clear 1;
  repeat progress match goal with
                  | H:?xs _ = _ |- _ => apply Sv with xs
                  | H:PM.find _ _ = Some _ |- _ => rewrite <- H
                  | |- context [PM.find _ (PM.add _ _ _)] => rewrite PM.gso
                  end; intuition.
Qed.

(* An alternative lemma would be:
   sem_held_equations H H' (filter_dup_defs eqs) -> sem_held_equations H H' eqs
   which should hold since the H in sem_equations/sem_held_equations requires
   that multiple definitions of the same variable be coherent. But proving
   this stronger result is much harder than just assuming something that
   should anyway be true: there are no duplicate definitions in eqs.

   Note, however, that this requires a stronger definition of Is_well_sch. *)
Lemma not_in_add_to_sem_held_equations:
  forall x xs eqs H H',
    ~Is_defined_in x eqs
    -> sem_held_equations H H' eqs
    -> sem_held_equations H (PM.add x xs H') eqs.
Proof.
  induction eqs as [|eq].
  intuition (apply List.Forall_nil).
  intros H H' Hndef Hsem.
  apply not_Is_defined_in_cons in Hndef; destruct Hndef as [Hndef0 Hndef1].
  unfold sem_held_equations in Hsem.
  apply Forall_cons2 in Hsem; destruct Hsem as [Hsem0 Hsem1].
  apply (IHeqs _ _ Hndef1) in Hsem1.
  destruct eq; [ apply not_Is_defined_in_eq_EqDef in Hndef0
               | apply not_Is_defined_in_eq_EqApp in Hndef0
               | apply not_Is_defined_in_eq_EqFby in Hndef0 ];
  apply List.Forall_cons; try apply Hsem1;
  inversion_clear Hsem0 as [? ? Hsv|? ? ? Hsv|? ? ? ys Hlae Hsv];
  try constructor;
  intros;
  try (apply sem_var_gso with (1:=Hndef0); apply Hsv; assumption).
  apply SHEqFby with (1:=Hlae).
  intros; rewrite <- Hsv; split; intro HH.
  apply sem_var_gso with (1:=Hndef0) in HH; assumption.
  apply sem_var_gso with (1:=Hndef0); assumption.
Qed.

Inductive no_dup_defs : list equation -> Prop :=
| NoDupDefs_nil : no_dup_defs nil
| NoDupDefs_cons : forall eq eqs,
                     (forall x, Is_defined_in_eq x eq
                                -> ~Is_defined_in x eqs)
                     -> no_dup_defs eqs
                     -> no_dup_defs (eq::eqs).

(*
   eqs = [ EqDef x y; EqFby y (Cint 0) (Econst (Cint 1)) ]
   eqs' = eqFby x (Cint 0) (Econst (Cint 1)) :: eqs

   Both eqs and eqs' have a coherent semantics (sem_equations G H _),
   but their respective hold semantics differ (for eqs', x is always present).
*)
Lemma sem_held_equations_existence:
  forall G H eqs,
    sem_equations G H eqs
    -> no_dup_defs eqs
    -> sem_held_equations H (hold_history H H eqs) eqs
       /\ (forall y n c,
              sem_var H y n (present c)
              -> sem_var (hold_history H H eqs) y n (present c)).
Proof.
  intros G H eqs Hsem Hndups.
  induction eqs as [|eq].
  - intuition constructor.
  - apply Forall_cons2 in Hsem; destruct Hsem as [Hsem Hsems].
    apply IHeqs in Hsems; [clear IHeqs
                          | inversion_clear Hndups; assumption ].
    destruct Hsems as [Hsems Hvars].
    destruct eq.

    split; [apply Forall_cons2|intuition];
    split; [constructor; apply Hvars|intuition].

    split; [apply Forall_cons2|intuition];
    split; [constructor; apply Hvars|intuition].

    split.

    (* show: sem_var -> sem_var *)
    Focus 2.
    intros y n c0 Hvar.
    pose proof (Hvars _ _ _ Hvar) as Hvar'.
    destruct (ident_eq_dec i y) as [Hiy|Hniy]; [rewrite Hiy|].
    2:(inversion_clear Hvar'; apply Sv with xs; simpl; try rewrite PM.gso; auto).
    simpl.
    eapply Sv.
    rewrite PM.gss.
    rewrite <-Some_injection.
    reflexivity.
    simpl.
    apply present_injection.
    inversion_clear Hsem.
    rewrite Hiy in *.
    apply H1 in Hvar.
    rewrite hold_injection with _ xs _ _.
    apply hold_rel.
    apply fbyR_holdR.
    exact Hvar.
    intro n0.
    specialize H0 with n0 (xs n0).
    assert (sem_laexp H l n0 (xs n0)) as Hsl by (apply H0; reflexivity).
    apply str_laexp_spec in Hsl.
    exact Hsl.

    (* show sem_held_equations *)

    simpl.
    apply Forall_cons2.
    split.
    inversion_clear Hsem.
    apply SHEqFby with xs.
    intro n; apply H0 with (v:=xs n); reflexivity.
    intros n c0.
    split.
    inversion_clear 1.
    rewrite PM.gss in H3.
    injection H3.
    intro.
    rewrite <-H2 in H4.
    injection H4.
    intro.
    apply hold_rel.
    rewrite <-H5.
    apply hold_injection.
    intro n0.
    specialize H0 with n0 (xs n0).
    assert (xs n0 = xs n0) as Hlae by reflexivity.
    apply H0 in Hlae.
    apply str_laexp_spec in Hlae.
    rewrite Hlae.
    reflexivity.
    intro Hhold.
    apply hold_rel in Hhold.
    eapply Sv.
    rewrite PM.gss.
    rewrite <-Some_injection.
    reflexivity.
    simpl.
    apply present_injection.
    rewrite hold_injection with _ xs _ _.
    apply Hhold.
    intro n0.
    specialize H0 with n0 (xs n0).
    assert (sem_laexp H l n0 (xs n0)) as Hsl by (apply H0; reflexivity).
    apply str_laexp_spec in Hsl.
    exact Hsl.

    apply not_in_add_to_sem_held_equations.
    inversion_clear Hndups as [|? ? Hndups'].
    apply Hndups'.
    constructor.
    apply Hsems.
Qed.

Lemma sem_held_equations_exist:
  forall G H eqs,
    sem_equations G H eqs
    -> no_dup_defs eqs
    -> exists H', sem_held_equations H H' eqs.
Proof.
  intros H H' eqs Hsems Hndups.
  apply sem_held_equations_existence in Hsems.
  destruct Hsems as [Hsems].
  now (eexists; apply Hsems).
  assumption.
Qed.

(* TODO: Is there a more direct way to negate PS.mem_spec?
         I.e., without creating a distinct lemma. *)
Lemma mem_spec_false:
  forall s x, PS.mem x s = false <-> ~PS.In x s.
Proof.
  split.
  intros Hmem Hin.
  apply PS.mem_spec in Hin.
  rewrite Hin in Hmem.
  discriminate.
  intro Hnin.
  apply Bool.not_true_iff_false.
  intro Hnmem.
  rewrite PS.mem_spec in Hnmem.
  contradiction.
Qed.

Local Ltac split_env_assumption :=
  match goal with
  | Henv: context Is_free_in_lexp [_], Hsem: sem_var _ ?y _ _
    |- _ => apply Henv in Hsem; [destruct Hsem |solve [auto]]; clear Henv
  | Henv: context Is_free_in_clock [_], Hsem: sem_var _ ?y _ _
    |- _ => apply Henv in Hsem; [destruct Hsem |solve [auto]]; clear Henv
  end.

Lemma exp_eval_tovar:
  forall x v menv env memories,
    exp_eval menv env (tovar memories x) v
    <-> (exp_eval menv env (State x) v /\ PS.In x memories)
        \/ (exp_eval menv env (Var x) v /\ ~PS.In x memories).
Proof.
  split; intro Heval;
  destruct In_dec with x memories as [Hxm|Hxm];
    pose proof Hxm as Hxmt;
    apply PS.mem_spec in Hxmt || apply mem_spec_false in Hxmt;
    unfold tovar in *;
    rewrite Hxmt in *;
    intuition.
Qed.

(* Note that the converse:
       Is_present_in memories menv env ck -> sem_clock H ck n true
   cannot be shown, since the present/absent status of memories is lost
   in menv/env. In other words, all elements of menv are always present,
   so Is_present_in may be true when the corresponding clock is not
   true under H (since it's elements may not be present on the "dataflow
   side"). *)
Lemma clock_correct_true:
  forall H n memories menv env ck,
    (forall x c, Is_free_in_clock x ck
                 -> sem_var H x n (present c)
                 -> (~PS.In x memories -> PM.find x env = Some c)
                    /\ (PS.In x memories -> find_mem x menv = Some c))
    -> sem_clock H ck n true
    -> Is_present_in memories menv env ck.
Proof.
  Hint Constructors Is_present_in.
  Hint Constructors sem_clock.
  Hint Constructors Is_free_in_clock.
  Hint Constructors exp_eval.
  intros H n memories menv env.
  induction ck as [|? ? x]; [ intuition | ].
  intro Henv.
  inversion_clear 1.
  constructor. apply IHck; auto.
  intros.
  split_env_assumption.
  apply exp_eval_tovar;
    destruct In_dec with x memories;
    intuition.
Qed.

Lemma clock_correct_false:
  forall H n memories menv env ck,
    (forall x c, Is_free_in_clock x ck
                 -> sem_var H x n (present c)
                 -> (~PS.In x memories -> PM.find x env = Some c)
                    /\ (PS.In x memories -> find_mem x menv = Some c))
    -> sem_clock H ck n false
    -> ~Is_present_in memories menv env ck.
Proof.
  Hint Constructors Is_present_in.
  Hint Constructors sem_clock.
  Hint Constructors Is_free_in_clock.
  intros H n memories menv env.
  induction ck as [|? ? x]; [inversion 2|].
  intro Henv.
  inversion_clear 1 as [| |? ? ? ? Hclk'|? ? ? ? ? Hclk' Hvar].
  apply IHck in Hclk'; auto.
  inversion_clear 1; contradiction.
  inversion_clear 1 as [|? ? ? Hipi Heval].
  split_env_assumption.
  repeat progress
         match goal with
         | H:_ \/ _ |- _ => destruct H
         | H:_ /\ _ |- _ => destruct H
         | H:exp_eval _ _ (tovar _ _ ) _ |- _ => apply exp_eval_tovar in H
         | H:exp_eval _ _ (State _) _ |- _ => inversion_clear H
         | H:exp_eval _ _ (Var _) _ |- _ => inversion_clear H
         | H: find_mem _ _ = Some _ |- _ => rewrite H in *
         | H: PM.find _ _ = Some _ |- _ => rewrite H in *
         | Hin: PS.In _ _, Hmenv: PS.In _ _ -> _ |- _ => apply Hmenv in Hin
         | Hin: ~PS.In _ _, Henv: ~PS.In _ _ -> _ |- _ => apply Henv in Hin
         | H: Some _ = Some _ |- _ => solve [ injection H; auto ]
         end.
Qed.

Lemma lexp_correct:
  forall H memories menv env n c e,
    sem_lexp H e n (present c)
    -> (forall x c, Is_free_in_lexp x e
                    -> sem_var H x n (present c)
                    -> (~PS.In x memories -> PM.find x env = Some c)
                       /\ (PS.In x memories -> find_mem x menv = Some c))
    -> exp_eval menv env (translate_lexp memories e) c.
Proof.
  Hint Constructors exp_eval.
  intros H memories menv env n c.
  induction e as [c0 e IH|c0|y|e IH y yb] using lexp_mult
  with (P:=fun e =>
          sem_laexp H e n (present c)
          -> (forall x c, Is_free_in_laexp x e
                          -> sem_var H x n (present c)
                          -> (~PS.In x memories -> PM.find x env = Some c)
                             /\ (PS.In x memories -> find_mem x menv = Some c))
          -> exp_eval menv env (translate_laexp memories e) c);
    inversion 1; intros;
    try apply IH; try apply econst; auto.
  split_env_assumption;
    unfold translate_lexp;
    destruct (PS.mem y memories) eqn:Hm;
    rewrite PS.mem_spec in Hm || rewrite mem_spec_false in Hm;
    auto.
Qed.

Lemma laexp_correct:
  forall H memories menv env n c e,
    sem_laexp H e n (present c)
    -> (forall x c, Is_free_in_laexp x e
                    -> sem_var H x n (present c)
                    -> (~PS.In x memories -> PM.find x env = Some c)
                       /\ (PS.In x memories -> find_mem x menv = Some c))
    -> exp_eval menv env (translate_laexp memories e) c.
Proof.
  intros H memories menv env n c e Hsem Henv.
  destruct e as [ck ce].
  inversion_clear Hsem as [? ? ? ? Hlexp ?|].
  change (exp_eval menv env (translate_lexp memories ce) c).
  apply (lexp_correct _ _ _ _ _ _ _ Hlexp); auto.
Qed.

(* TODO: Tidy this proof *)
Lemma cexp_correct:
  forall H memories menv env menv' env' n c x e,
    sem_cexp H e n (present c)
    -> (forall x c, Is_free_in_cexp x e
                    -> sem_var H x n (present c)
                    -> (~PS.In x memories -> PM.find x env = Some c)
                       /\ (PS.In x memories -> find_mem x menv = Some c))
    -> stmt_eval menv env (translate_cexp memories x e) (menv', env')
    -> env' = PM.add x c env.
Proof.
  intros H memories menv env menv' env' n c x.
  induction e as [ck e IH|b et IHt ef IHf|e] using cexp_mult
  with (P:=fun e =>
             sem_caexp H e n (present c)
             -> (forall x c,
                    Is_free_in_caexp x e
                    -> sem_var H x n (present c)
                    -> (~PS.In x memories -> PM.find x env = Some c)
                       /\ (PS.In x memories -> find_mem x menv = Some c))
             -> stmt_eval menv env (translate_caexp memories x e) (menv', env')
             -> env' = PM.add x c env).
  - (* CAexp *) inversion 1; auto.
  - (* Emerge *)
    inversion_clear 1; inversion_clear 2;
    solve [
        apply IHt; auto
      | apply IHf; auto
      | split_env_assumption;
        repeat progress
               match goal with
               | H:_ \/ _ |- _ => destruct H
               | H:_ /\ _ |- _ => destruct H
               | H:exp_eval _ _ (tovar _ _ ) _ |- _ => apply exp_eval_tovar in H
               | H:exp_eval _ _ (State _) _ |- _ => inversion_clear H
               | H:exp_eval _ _ (Var _) _ |- _ => inversion_clear H
               | H: find_mem _ _ = Some _ |- _ => rewrite H in *
               | H: PM.find _ _ = Some _ |- _ => rewrite H in *
               | Hin: PS.In _ _, Hmenv: PS.In _ _ -> _ |- _ => apply Hmenv in Hin
               | Hin: ~PS.In _ _, Henv: ~PS.In _ _ -> _ |- _ => apply Henv in Hin
               | H: Some _ = Some _ |- _ => repeat injection H;
                                            discriminate || auto
               end
      ].
  - (* Eexp *)
    inversion 1; inversion 2; subst;
    repeat progress match goal with
    | H:sem_lexp _ _ _ _ |- _ => eapply lexp_correct in H; [|now auto]
    | H1:exp_eval _ _ _ _, H2:exp_eval _ _ _ _ |- _ =>
                                 eapply (exp_eval_det _ _ _ _ _ H1) in H2; subst
    | _ => reflexivity
    end.
Qed.

Lemma caexp_correct:
  forall H memories menv env menv' env' n c x e,
    sem_caexp H e n (present c)
    -> (forall x c, Is_free_in_caexp x e
                    -> sem_var H x n (present c)
                    -> (~PS.In x memories -> PM.find x env = Some c)
                       /\ (PS.In x memories -> find_mem x menv = Some c))
    -> stmt_eval menv env (translate_caexp memories x e) (menv', env')
    -> env' = PM.add x c env.
Proof.
  intros H memories menv env menv' env' n c x e Hsem Henv Hstmt.
  destruct e as [ck ce].
  inversion_clear Hsem as [? ? ? ? Hlexp ?|].
  change (stmt_eval menv env (translate_cexp memories x ce) (menv', env'))
    in Hstmt.
  apply cexp_correct with (1:=Hlexp) (3:=Hstmt); auto.
Qed.

Local Ltac resolve_env_assumption :=
  intro x; intros; split; intros;
  match goal with
  | Hws: Is_well_sch (PS.add ?input _) _ |- _ =>
    destruct (ident_eq_dec x input);
      repeat progress
             match goal with
             | H:   ~PS.In x _,
               Hin: x=input,
               Hws: Is_well_sch _ (_ :: _) |- _ =>
                 subst;
                 apply Is_well_sch_free_variable_in_mems with input _ _ _ in Hws;
                 [ apply not_Is_defined_in_not_Is_variable_in in Hws
                 | auto | apply PS.add_spec; auto ]

             | H:   ~PS.In x _,
               Hin: x<>input,
               Hws: Is_well_sch _ (_ :: _) |- _ =>
                 apply Is_well_sch_free_variable with x _ _ _ in Hws;
                 [ | auto | intro HH; apply PS.add_spec in HH; intuition ]

             | H:   PS.In x _,
               Hws: Is_well_sch _ (_ :: _),
               Hm:  forall x : ident, ~Is_memory_in _ _ -> _ |- _ =>
                 apply Is_well_sch_free_variable_in_mems with x _ _ _ in Hws;
                 [ apply not_Is_defined_in_not_Is_memory_in in Hws;
                   apply Hm in Hws; rewrite Hws | | apply PS.add_spec ]; auto

             | H0:~Is_variable_in _ _,
               H1: stmt_eval _ _ _ _ |- _ =>
                 apply (stmt_eval_translate_eqns_env_inv _ _ _ _ _ _ H1) in H0;
                 rewrite H0

             | H:forall c:const, sem_var _ _ _ _ <-> PM.find ?x ?env = _
                                 |- PM.find ?x ?env = _ => now (apply H)

             | Hv: forall x' : ident,
                 Is_variable_in x' ?eqs ->
                                forall c' : const,
                                  sem_var ?H x' ?n (present c')
                                  <-> PM.find x' ?env = Some c',
               Hs: sem_var ?H ?x ?n (present ?c)
               |-  PM.find ?x ?env = Some ?c => apply Hv; [now auto|apply Hs]

             | Hin: PS.In ?x ?mems,
               Hm: forall x,
                   PS.In x ?mems ->
                         forall c : const,
                           sem_var ?H' x ?n (present c)
                           <-> find_mem x ?menv = Some c
               |- find_mem ?x ?menv = Some ?c => apply Hm with (1:=Hin)

             | Hs: sem_equations ?G ?H ?eqs,
               Hh: sem_held_equations ?H ?H' ?eqs,
               Hv: sem_var ?H ?x ?n ?v,
               Hd: forall x' : ident, PS.In x' ?mems -> Is_memory_in x' ?eqs,
               Hm: PS.In ?x ?mems
               |- sem_var ?H' ?x ?n ?v =>
                    apply Hd in Hm;
                    apply Is_memory_in_defined_in in Hm;
                    now apply sem_held_equations_corres
                          with (1:=Hs) (2:=Hh) (3:=Hm) (4:=Hv)

             | H:x=input |- _ => now (subst; contradiction)
             end
  end.


(* Notes:
   1. The assumption sem_equations must be shown for a set of equations.
      TODO: lemma showing that a well-typed and well-clocked set of
            equations has a semantics.

   2. The assumption stmt_eval (translate_eqns mems eqs) implies that an
      execution exists and thus that exp_eval's evar and estate find some
      value for each required variable.
      This is somehow backwards; it should be an obligation to show that
      an execution exists. This is something assured indirectly in the
      lemma below where we require not just that evar and estate find
      some value, but also that it is the correct value.
 *)

Import List.ListNotations.
Open Scope list_scope.

Lemma List_shift_first:
  forall (A:Set) ll (x : A) lr,
    ll ++ (x :: lr) = (ll ++ [x]) ++ lr.
Proof.
  induction ll as [|? ? IH]; [auto|intros].
  rewrite <- List.app_comm_cons.
  rewrite IH.
  now do 2 rewrite List.app_comm_cons.
Qed.

Lemma List_shift_away:
  forall (A:Set) alleqs (eq : A) eqs,
    (exists oeqs, alleqs = oeqs ++ (eq :: eqs))
    -> exists oeqs', alleqs = oeqs' ++ eqs.
Proof.
  intros A alleqs eq eqs Hall.
  destruct Hall as [oeqs Hall].
  exists (oeqs ++ [eq]).
  rewrite Hall.
  now rewrite List_shift_first.
Qed.

Lemma Forall_app:
  forall A (P: A -> Prop) ll rr,
    List.Forall P (ll ++ rr) <-> (List.Forall P ll /\ List.Forall P rr).
Proof.
  intros A P ll rr.
  induction ll as [|x ll IH]; [intuition|].
  rewrite Forall_cons2.
  rewrite and_assoc.
  rewrite <-IH.
  rewrite <-List.app_comm_cons.
  now rewrite Forall_cons2.
Qed.

Lemma sem_equations_app2:
  forall G H oeqs eqs,
    sem_equations G H (oeqs ++ eqs)
    -> sem_equations G H eqs.
Proof.
  intros G H oeqs eqs H0.
  apply Forall_app in H0; intuition.
Qed.

Lemma sem_held_equations_app2:
  forall H H' oeqs eqs,
    sem_held_equations H H' (oeqs ++ eqs)
    -> sem_held_equations H H' eqs.
Proof.
  intros H H' oeqs eqs H0.
  apply Forall_app in H0; intuition.
Qed.

Lemma sem_held_equations_cons:
  forall H H' eq eqs,
    sem_held_equations H H' (eq :: eqs)
    <-> sem_held_equation H H' eq /\ sem_held_equations H H' eqs.
Proof.
  split; intro Hs.
  apply Forall_cons2 in Hs; auto.
  apply Forall_cons2; auto.
Qed.

Lemma find_mem_gss:
  forall y c m, find_mem y (add_mem y c m) = Some c.
Proof.
  intros. apply PM.gss.
Qed.

Lemma find_mem_gso:
  forall x y c m, x <> y -> find_mem x (add_mem y c m) = find_mem x m.
Proof.
  intros. apply PM.gso. assumption.
Qed.

Lemma Is_memory_in_EqFby:
  forall y v0 lae eqs,
    Is_memory_in y (EqFby y v0 lae :: eqs).
Proof.
  intros. repeat constructor.
Qed.

Lemma is_step_correct:
  forall (G: global)
         (H: history)
         (H': history)
         (input: ident)
         (mems: PS.t)
         (alleqs: list equation),

    sem_equations G H alleqs
    -> sem_held_equations H H' alleqs
    -> (forall x:ident, PS.In x mems -> Is_memory_in x alleqs)

    -> forall (eqs: list equation)
              (n: nat)
              (menv: memoryEnv)
              (menv': memoryEnv)
              (env: valueEnv)
              (env': valueEnv),

    Is_well_sch (PS.add input mems) eqs
    -> (exists oeqs, alleqs = oeqs ++ eqs)
    -> stmt_eval menv env (translate_eqns mems eqs) (menv', env')

    (* NB: PM.find x env' = Some c -> sem_var H x n (present c)
           does not hold if PM.find x env = Some arbitrary_c, since
           x will not be written to when its clock is absent.

           It may just be better to show the direction:
           sem_var H x n (present c) -> PM.find x env' = Some c

           which is enough if the outputs are only sampled when
           they are present (normally the case).

           More discussion/context is needed. *)
    -> (forall x, Is_variable_in x eqs -> PM.find x env = None)

    (* - inputs (assumed) *)
    -> ~Is_memory_in input eqs
    -> (forall c, sem_var H input n (present c) <-> PM.find input env = Some c)

    (* - unwritten memories (assumed) *)
    -> (forall x:ident,
           PS.In x mems ->
           forall c, sem_var H' x n (present c) <-> find_mem x menv = Some c)

    (* - locals (shown) *)
    -> (forall x:ident,
           Is_variable_in x eqs ->
           forall c, sem_var H x n (present c) <-> PM.find x env' = Some c)

    (* - written memories (shown) *)
       /\ (forall x:ident,
              Is_memory_in x eqs ->
              forall c, sem_var H' x (S n) (present c)
                        <-> find_mem x menv' = Some c).
Proof.
  intros until alleqs.
  intros Hsems Hheld Himi.

  induction eqs as [|eq].
  split; intros; match goal with
                 | H:Is_variable_in _ nil |- _ => inversion H
                 | H:Is_memory_in _ nil |- _ => inversion H
                 end.
  intros n menv menv'' env env'' Hwsch Hall Hevals Henv Hin1 Hin2 Humem.

  (* split stmt_eval into two parts *)
  apply stmt_eval_translate_eqns_cons in Hevals;
    destruct Hevals as [menv' Hevals];
    destruct Hevals as [env' Hevals];
    destruct Hevals as [Hevals Heval].

  assert (forall x, Is_variable_in x eqs -> PM.find x env = None) as Henv'
      by (intros; apply Henv; constructor 2; auto).

  apply not_Is_memory_in_cons in Hin1.
  destruct Hin1 as [Hin1 Hin1s].

  specialize (IHeqs _ _ _ _ _
                    (Is_well_sch_cons _ _ _ Hwsch)
                    (List_shift_away _ _ _ _ Hall)
                    Hevals Henv' Hin1s Hin2 Humem).
  destruct IHeqs as [IHeqs1 IHeqs2].
  clear Henv'.

  destruct Hall as [oeqs Hall].
  assert (Hsems' := Hsems); rewrite Hall in Hsems'.
  apply sem_equations_app2 in Hsems'.
  apply sem_equations_cons in Hsems'.
  destruct Hsems' as [Hsem Hsems'].

  split.
  - intros x Hvi c.
    apply Is_variable_in_cons in Hvi; destruct Hvi as [Hvieq|Hivieqs].
    + destruct eq as [y cae|y f lae|]; inversion Hvieq; subst; clear Hvieq.
      * (* Inductive step for EqDef *)
        destruct cae as [ck ce].
        simpl in Heval.
        inversion_clear Hsem as [? ? Hsem'| |];
          specialize Hsem' with n;
          destruct Hsem' as [v Hsem];
          destruct Hsem as [Hsv Hcae].
        pose proof (stmt_eval_translate_eqns_menv_inv _ _ _ _ _ _ Hevals)
          as Hminv.
        apply stmt_eval_Control in Heval;
          destruct Heval as [Heval|Heval];
          destruct Heval as [Hpi Heval].
        { (* Is_present_in ck *)
          inversion Hcae as [? ? ? c' Hcexp Hclk|? ? ? Hcexp Hclk];
          subst; clear Hcae.
          { (* sem_clock H ck n true *)
            apply (cexp_correct _ _ _ _ _ _ _ _ _ _ Hcexp) in Heval.
            2: resolve_env_assumption.
            rewrite Heval; rewrite PM.gss; split.
            intro Hsv';
              assert (present c' = present c) as Heq
                by apply sem_var_det with (1:=Hsv) (2:=Hsv').
            injection Heq as Heq'; subst; reflexivity.
            injection 1 as Heq; rewrite Heq in Hsv; assumption. }
          { (* sem_clock H ck n false *)
            apply clock_correct_false with _ _ mems menv' env' _ in Hclk.
            2: resolve_env_assumption.
            contradiction. }
        }
        { (* ~Is_present_in ck *)
          destruct Heval as [HR1 HR2]; rewrite HR2 in *; clear HR1 HR2.
          inversion Hcae as [ ck' ce' n' c' Hcexp Hclk
                            | ck' ce' n' Hcexp Hclk [HR1 HR2] HR3 HR4].
          { (* sem_clock H ck n true *)
            apply (clock_correct_true H n mems menv' env' ck) in Hclk.
            2: resolve_env_assumption.
            contradiction. }
          { (* sem_clock H ck n false *)
            split.
            { intro Hsv'.
              pose proof (sem_var_det _ _ _ _ _ Hsv Hsv') as Hbad.
              rewrite <- HR4 in Hbad.
              discriminate Hbad. }
            { intro Hfx.
              destruct (Is_variable_in_dec y eqs) as [Hvi|Hvni].
              apply IHeqs1; [apply Hvi | apply Hfx].
              apply (stmt_eval_translate_eqns_env_inv _ _ _ _ _ _ Hevals) in Hvni.
              rewrite Hvni in Hfx.
              rewrite Henv in Hfx.
              discriminate.
              repeat constructor. }
            }
        }
      * (* TODO: Inductive step for EqApp. *) admit.
    + destruct Hivieqs as [H0 H1].
      apply IHeqs1 with (c:=c) in H1; rewrite H1.
      apply not_Is_variable_in_eq with (2:=Heval) in H0.
      rewrite H0; intuition.
  - (* Inductive step for EqFby: y = v0 fby lae *)
    intros x Hmi c.
    apply Is_memory_in_cons in Hmi; destruct Hmi as [Hmieq|Himieqs].
    2:now (destruct Himieqs as [Himieq Himieqs];
           rewrite IHeqs2;
           [ rewrite not_Is_memory_in_eq with (1:=Himieq) (2:=Heval) | auto ]).
    destruct eq as [| |y v0 lae]; inversion Hmieq; subst; clear Hmieq.
    destruct lae as [ck le].
    simpl in Heval.
    pose proof (stmt_eval_translate_eqns_menv_inv _ _ _ _ _ _ Hevals)
      as Hminv.

    assert (Hheld' := Hheld).
    apply sem_held_equations_app2 in Hheld'.
    apply sem_held_equations_cons in Hheld'.
    destruct Hheld' as [Hheld' Hhelds'].
    inversion_clear Hheld' as [| |? ? ? ls Hlae Hsv].
    specialize Hlae with n.

    apply stmt_eval_Control in Heval;
      destruct Heval as [Heval|Heval];
      destruct Heval as [Hpi Heval].
    { (* Is_present_in ck *)
      inversion Heval as [|? ? ec ? Hexp Hmenv''| | | | |]; subst.
      rewrite find_mem_gss.
      inversion Hlae as [? ? ? ? Hlexp Hclk H1 H2 Hlsn|? ? ? Hlexp Hclk]; subst.
      { (* sem_clock H ck n true *)
        rewrite Hsv; clear Hsv.
        assert (exp_eval menv' env'' (translate_lexp mems le) c0) as Hexp'
          by (apply (lexp_correct _ _ _ _ _ _ _ Hlexp); resolve_env_assumption).
        apply (exp_eval_det _ _ _ _ _ Hexp) in Hexp'.
        rewrite Hexp' in *; clear Hexp'.
        symmetry in Hlsn.
        apply holdR_present with v0 _ _ _ in Hlsn.
        split.
        - intro Hlsn'.
          apply hold_rel in Hlsn.
          apply hold_rel in Hlsn'.
          subst; reflexivity.
        - injection 1.
          intro HR; rewrite HR in Hlsn; auto. }
      { (* sem_clock H ck n false *)
        apply clock_correct_false with _ _ mems menv' env'' _ in Hclk.
        2: resolve_env_assumption; apply IHeqs1; auto.
        contradiction. } }
    { (* ~Is_present_in ck *)
      destruct Heval as [HR1 HR2]; rewrite HR1 in *; clear HR1 HR2.
      inversion Hlae as [? ? ? ? Hlexp Hclk H1 H2 Hlsn
                        | ? ? ? Hlexp Hclk H0 H2 Hlsn]; subst.
      { (* sem_clock H ck n true *)
        apply (clock_correct_true H n mems menv' env' ck) in Hclk.
        2: resolve_env_assumption.
        contradiction. }
      { (* sem_clock H ck n false *)
        Hint Constructors Is_memory_in_eq.
        Hint Immediate Is_memory_in_EqFby.
        destruct Is_memory_in_dec with y eqs as [Hxin|Hxin];
        [ now apply IHeqs2 with (1:=Hxin) | ].
        apply Hminv in Hxin.
        rewrite Hxin; clear Hxin.
        assert (PS.In y mems) as Hymems.
        { apply Is_wsch_Is_memory_in_mems with _ y _ in Hwsch; [|now auto].
          apply PS.add_spec in Hwsch.
          destruct Hwsch as [Hwsch|Hwsch]; [|now auto].
          rewrite Hwsch in Hin1.
          exfalso; auto. }
        rewrite <- Humem with (1:=Hymems).
        split.
        - intro HH.
          apply Hsv in HH.
          inversion_clear HH as [|? ? Hlsn' HholdR|? ? Hlsn'];
            [ apply Hsv in HholdR; exact HholdR
            | rewrite Hlsn' in Hlsn; discriminate ].
        - intro HH.
          symmetry in Hlsn.
          apply holdR_absent with v0 _ c _ in Hlsn;
            [ apply Hsv in Hlsn; exact Hlsn
            | apply Hsv; exact HH ].
      }
    }
Qed.

Lemma stmt_eval_translate_eqn_init_shift:
  forall eqs iacc menv env menv' env',
    stmt_eval menv env
              (List.fold_left translate_eqn_init eqs iacc)
              (menv', env')
    <->
    exists menv'' env'',
      stmt_eval menv env
                (List.fold_left translate_eqn_init eqs Skip)
                (menv'', env'')
      /\
      stmt_eval menv'' env'' iacc (menv', env').
Proof.
  Hint Constructors stmt_eval.
  induction eqs as [|eq eqs IH].
  - split; [ now eauto | ].
    intro H; do 2 destruct H.
    destruct H as [H0 H1].
    inversion_clear H0; apply H1.
  - intros.
    split.
    + intro H0.
      apply IH in H0.
      destruct H0 as [menv'' [env'' [H0 H1]]].
      destruct eq; [now eauto|now eauto|].
      inversion_clear H1.
      exists menv1; exists env1.
      split; try (simpl; apply IH); eauto.
    + intros.
      destruct eq;
        [now (apply IH; auto)|now (apply IH; auto)|].
      apply IH.
      simpl in H.
      destruct H as [menv'' [env'' [H0 H1]]].
      apply IH in H0.
      destruct H0 as [menv0 [env0 [H2 H3]]].
      exists menv0; exists env0.
      split; [now auto|].
      inversion_clear H3.
      inversion H0; subst.
      econstructor; eauto.
Qed.

Lemma is_step_initialized:
  forall (G: global)
         (H: history)
         (H': history)
         (mems: PS.t)
         (eqs: list equation)
         (menv: memoryEnv)
         (menv': memoryEnv)
         (env: valueEnv)
         (env': valueEnv),
    sem_equations G H eqs
    -> sem_held_equations H H' eqs
    -> stmt_eval menv env (translate_eqns_init eqs) (menv', env')
    -> (forall x:ident,
           Is_memory_in x eqs ->
           forall c, sem_var H' x 0 (present c) <-> find_mem x menv' = Some c).
Proof. (* TODO: Tidy up this proof *)
  induction eqs as [|eq]; [ inversion 4 | ].
  intros menv menv' env env' Hsem Hheld Heval x Himi c.
  apply sem_equations_cons in Hsem;
    destruct Hsem as [Hsem Hsems].
  apply sem_held_equations_cons in Hheld;
    destruct Hheld as [Hheld Hhelds].
  destruct eq;
    (apply Is_memory_in_cons in Himi;
     destruct Himi as [Himi|Himi];
     [inversion Himi|destruct Himi as [Hnimi Himi]];
     try apply IHeqs with (1:=Hsems) (2:=Hhelds) (3:=Heval) (4:=Himi)).
  - subst.
    unfold translate_eqns_init in Heval.
    simpl in Heval.
    apply stmt_eval_translate_eqn_init_shift in Heval.
    destruct Heval as [menv'' [env'' [Hevals Heval]]].
    inversion Heval; subst.
    repeat progress
           match goal with
           | H:stmt_eval _ _ Skip _ |- _ => inversion H; subst; clear H
           | H:stmt_eval _ _ (AssignSt _ _) _ |- _ => inversion H; subst; clear H
           end.
    rewrite find_mem_gss.
    inversion Hheld; subst.
    split.
    intro HH.
    apply H5 in HH.
    inversion HH; subst.
    inversion_clear H4.
    reflexivity.

    intro HH.
    injection HH.
    intro.
    apply H5.
    inversion H4. subst.
    constructor.
  - unfold translate_eqns_init in Heval.
    simpl in Heval.
    apply stmt_eval_translate_eqn_init_shift in Heval.
    destruct Heval as [menv'' [env'' [Hevals Heval]]].
    change (stmt_eval menv env (translate_eqns_init eqs) (menv'', env'')) in Hevals.
    apply IHeqs with (1:=Hsems) (2:=Hhelds) (3:=Hevals) (c:=c) in Himi.
    rewrite Himi.
    inversion_clear Heval.
    repeat progress
           match goal with
           | H:stmt_eval _ _ Skip _ |- _ => inversion H; subst; clear H
           | H:stmt_eval _ _ (AssignSt _ _) _ |- _ => inversion H; subst; clear H
           end.
    assert (x<>i) as Hxni by (contradict Hnimi; subst; constructor).
    rewrite find_mem_gso with (1:=Hxni).
    intuition.
Qed.

(* TODO: lemma to 'close the loop' on is_step_correct.
         Induction on n (the number of the instant). *)

