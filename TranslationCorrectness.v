Require Import Rustre.Common.
Require Import Rustre.DataflowSyntax.

(** ** Predicates *)

(* Working: Tim *)

Require Coq.MSets.MSets.

Module PS := Coq.MSets.MSetPositive.PositiveSet.

(* ** Definitions on dataflow equations *)

Fixpoint memory_eq (mems: PS.t) (eq: equation) : PS.t :=
  match eq with
  | EqFby x _ _ => PS.add x mems
  | _ => mems
  end.

Definition memories (eqs: list equation) : PS.t :=
  List.fold_left memory_eq eqs PS.empty.

Fixpoint defined_eq (defs: PS.t) (eq: equation) : PS.t :=
  match eq with
  | EqDef x _   => PS.add x defs
  | EqApp x _ _ => PS.add x defs
  | EqFby x _ _ => PS.add x defs
  end.

Definition defined (eqs: list equation) : PS.t :=
  List.fold_left defined_eq eqs PS.empty.

Fixpoint freevar_lexp' (e: lexp) (fvs: PS.t) : PS.t :=
  match e with
    | Econst c => fvs
    | Evar x => PS.add x fvs
    | Ewhen ae c x => freevar_laexp' ae fvs
  end
with freevar_laexp' (lae: laexp) (fvs: PS.t) : PS.t :=
  match lae with
    | LAexp ck e => freevar_lexp' e fvs
  end.

Fixpoint freevar_caexp' (cae: caexp) (fvs: PS.t) : PS.t :=
  match cae with
  | CAexp ck ce => freevar_cexp' ce fvs
  end
with freevar_cexp' (ce: cexp) (fvs: PS.t) : PS.t :=
  match ce with
  | Emerge x t f => PS.add x (freevar_caexp' f (freevar_caexp' t fvs))
  | Eexp e => freevar_lexp' e fvs
  end.

Definition freevar_lexp e := freevar_lexp' e PS.empty.
Definition freevar_laexp lae := freevar_laexp' lae PS.empty.
Definition freevar_caexp cae := freevar_caexp' cae PS.empty.

(* TODO: Big question: how do we get from the scheduling property on graphs
                       to this predicate?
         (Membership in memories or not, should follow from the definition
          of 'memories' above.) *)
Inductive sch_eqs (memories: PS.t) : PS.t -> PS.t -> list equation -> Prop :=
| SchEqDef:
    forall written notwritten x e eqs,
      ~ (PS.In x memories) ->
      PS.Subset (PS.diff  (freevar_caexp e) memories) written ->
      PS.Subset (PS.inter (freevar_caexp e) memories) notwritten ->  
      sch_eqs memories (PS.add x written) (PS.remove x notwritten) eqs ->
      sch_eqs memories written notwritten (EqDef x e :: eqs)
| SchEqApp:
    forall written notwritten x f e eqs,
      ~ (PS.In x memories) ->
      PS.Subset (PS.diff  (freevar_laexp e) memories) written ->
      PS.Subset (PS.inter (freevar_laexp e) memories) notwritten ->  
      sch_eqs memories (PS.add x written) (PS.remove x notwritten) eqs ->
      sch_eqs memories written notwritten (EqApp x f e :: eqs)
| SchEqFby:
    forall written notwritten x v0 e eqs,
      PS.In x memories ->
      PS.Subset (PS.diff  (freevar_laexp e) memories) written ->
      PS.Subset (PS.inter (freevar_laexp e) memories) notwritten ->
      sch_eqs memories (PS.add x written) (PS.remove x notwritten) eqs ->
      sch_eqs memories written notwritten (EqFby x v0 e :: eqs).

(* ** Definitions on imperative statements *)

Require Import Rustre.Minimp.

(* TODO:
   - Assume we are given a list of dataflow equations eqs satisfying
        sch_eqs (memories eqs) PS.empty (defined eqs) eqs
   - Show that the step function generated by translate_eqs is correct,
     i.e., that its semantics correspond to the 'held semantics' of the
     original dataflow equations.
   - The 'held semantics' use holdR rather than fbyR for defining 'fby'.
   - Basic invariant for a single pass (to show by induction along the list
     of dataflow equations/sequence of conditional assignments):
        forall x,
             (PS.In x (PS.inter memories written) -> M x = H x (S n))
          /\ (PS.In x (PS.diff memories written) -> M x = H x n)
          /\ (PS.In x (PS.diff written memories) ->
              H x n = present c -> p x = c)

   - Afterward, this must be extended to run (i.e., forall n from 0).
   - and we must switch back to the standard fby semantics for instants
     where a clock is active.
 *)














(* TODO: Do we really need these definitions? We should be able to extract
         the relevant information from the definitions above via the
         translation functions. *)
Fixpoint freevar_exp (fvs: PS.t) (e: exp) : PS.t :=
  match e with
  | Var x => PS.add x fvs
  | Const c => fvs
  end.
    
Fixpoint freevar_stmt (fvs: PS.t) (s: stmt) : PS.t :=
   match s with
   | Assign i e => freevar_exp fvs e
   | AssignSt i e => freevar_exp fvs e
   | Ifte i s1 s2 => freevar_stmt (freevar_stmt (PS.add i fvs) s1) s2
   | Step_ap i f e => freevar_exp fvs e
   | Comp s1 s2 => freevar_stmt (freevar_stmt fvs s1) s2
   | Skip => fvs
   end.



