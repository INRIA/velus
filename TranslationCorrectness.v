Require Import List.
Import List.ListNotations.
Open Scope list_scope.

Require Import Rustre.Common.
Require Import Rustre.DataflowSyntax.
Require Import Rustre.DataflowNatSemantics.
Require Import Rustre.DataflowNatMSemantics.
Require Import Rustre.SynchronousNat.
Require Import Rustre.WellFormed.

(* ** Definitions on imperative statements *)

Require Import Rustre.Minimp.
Require Import PArith.
Require Import Rustre.Translation.


(* TODO:
   - Assume we are given a list of dataflow equations eqs satisfying
        sch_eqs (memories eqs) PS.empty (defined eqs) eqs
   - Show that the step function generated by translate_eqs is correct,
     i.e., that its semantics correspond to the 'held semantics' of the
     original dataflow equations.
   - The 'held semantics' use holdR rather than fbyR for defining 'fby'.
   - Basic invariant for a single pass (to show by induction along the list
     of dataflow equations/sequence of conditional assignments):
        forall x,
             (PS.In x (PS.inter memories written) -> M x = H x (S n))
          /\ (PS.In x (PS.diff memories written) -> M x = H x n)
          /\ (PS.In x (PS.diff written memories) ->
              H x n = present c -> p x = c)

   - Afterward, this must be extended to run (i.e., forall n from 0).
   - and we must switch back to the standard fby semantics for instants
     where a clock is active.
 *)

Example eqn1_well_sch: Is_well_sch (PS.add 1 (memories eqns1)) eqns1.
Proof.
  assert (well_sch (PS.add 1 (memories eqns1)) eqns1 = true) as HW by apply eq_refl.
  pose proof (well_sch_spec (PS.add 1 (memories eqns1)) eqns1) as HS.
  rewrite HW in HS.
  assumption.
Qed.

Example eqn2_well_sch: Is_well_sch (PS.add 1 (memories eqns2)) eqns2.
Proof.
  assert (well_sch (PS.add 1 (memories eqns2)) eqns2 = true) as HW by apply eq_refl.
  pose proof (well_sch_spec (PS.add 1 (memories eqns2)) eqns2) as HS.
  rewrite HW in HS.
  assumption.
Qed.

Lemma exp_eval_tovar_Cbool_dec:
  forall menv env mems c v,
    {exp_eval menv env (tovar mems c) (Cbool v)}
    + {~exp_eval menv env (tovar mems c) (Cbool v)}.
Proof.
  Ltac no_match := right; inversion_clear 1; try unfold find_mem in *;
                   match goal with
                   | H: PM.find _ _ = _ |- _ => rewrite H in *; discriminate
                   end.
  intros menv env mems c v.
  unfold tovar.
  destruct (PS.mem c mems).
  - case_eq (find_mem c menv).
    + intro c0; destruct c0.
      * no_match.
      * destruct b; destruct v; (left; apply estate; assumption) || no_match.
    + no_match.
  - case_eq (PM.find c env).
    + intro c0; destruct c0.
      * no_match.
      * destruct b; destruct v; (left; apply evar; assumption) || no_match.
    + no_match.
Qed.

Inductive Is_present_in (mems: PS.t) (menv: memoryEnv) (env: constEnv)
  : clock -> Prop :=
| IsCbase: Is_present_in mems menv env Cbase
| IsCon:
    forall ck c v,
      Is_present_in mems menv env ck
      -> exp_eval menv env (tovar mems c) (Cbool v)
      -> Is_present_in mems menv env (Con ck c v).

Lemma Is_present_in_dec:
  forall mems menv env ck,
    {Is_present_in mems menv env ck}+{~Is_present_in mems menv env ck}.
Proof.
  intros.
  induction ck.
  - left; constructor.
  - destruct IHck.
    + destruct (exp_eval_tovar_Cbool_dec menv env mems i b); destruct b;
      (left; constructor; assumption) || right; inversion_clear 1; auto.
    + right; inversion_clear 1; auto.
Qed.

Inductive Is_absent_in (mems: PS.t) (menv: memoryEnv) (env: constEnv)
  : clock -> Prop :=
| IsAbs1:
    forall ck c v,
      Is_absent_in mems menv env ck
      -> Is_absent_in mems menv env (Con ck c v)
| IsAbs2:
    forall ck c v1 v2,
         Is_present_in mems menv env ck
      -> exp_eval menv env (tovar mems c) (Cbool v1)
      -> v2 <> v1
      -> Is_absent_in mems menv env (Con ck c v2).

Lemma Is_absent_in_disj:
  forall mems menv env ck c v,
    Is_absent_in mems menv env (Con ck c v)
    -> (Is_absent_in mems menv env ck
        \/ (forall v', exp_eval menv env (tovar mems c) (Cbool v')
                       -> v' <> v)).
Proof.
  intros mems menv env ck c v.
  inversion_clear 1 as [|? ? ? ? Hp Hexp Hneq]; intuition.
  right; intros v' Hexp'.
  intro HR; rewrite <-HR in *; clear HR.
  apply Hneq.
  pose proof (exp_eval_det _ _ _ _ _ Hexp Hexp') as Heq.
  injection Heq; intuition.
Qed.

Lemma exp_eval_tovar:
  forall x v menv env memories,
    exp_eval menv env (tovar memories x) v
    <-> (exp_eval menv env (State x) v /\ PS.In x memories)
        \/ (exp_eval menv env (Var x) v /\ ~PS.In x memories).
Proof.
  split; intro Heval;
  destruct In_dec with x memories as [Hxm|Hxm];
    pose proof Hxm as Hxmt;
    apply PS.mem_spec in Hxmt || apply mem_spec_false in Hxmt;
    unfold tovar in *;
    rewrite Hxmt in *;
    intuition.
Qed.

Lemma stmt_eval_translate_eqns_cons:
  forall prog mems menv env menv' env' eq eqs,
    stmt_eval prog menv env (translate_eqns mems (eq :: eqs)) (menv', env')
    <->
    (exists menv'' env'',
        stmt_eval prog menv env (translate_eqns mems eqs) (menv'', env'')
        /\ stmt_eval prog menv'' env'' (translate_eqn mems eq) (menv', env')).
Proof. (* TODO: redo proof *)
  split.
  - intro H.
    unfold translate_eqns in H.
    simpl in H.
    apply stmt_eval_fold_left_shift in H.
    destruct H as [menv'' [env'' [H1 H2]]].
    exists menv'', env''.
    split; [now apply H1|].
    inversion_clear H2.
    inversion H0.
    subst.
    exact H.
  - intro H.
    destruct H as [menv'' [env'' [H1 H2]]].
    unfold translate_eqns.
    simpl.
    apply stmt_eval_fold_left_shift.
    exists menv'', env''.
    split; [now apply H1|].
    eapply Icomp. apply H2.
    apply Iskip.
Qed.

Lemma stmt_eval_Control_fwd:
  forall prog menv env mems c s menv' env',
    stmt_eval prog menv env (Control mems c s) (menv', env')
    -> (Is_present_in mems menv env c
        /\ stmt_eval prog menv env s (menv', env'))
       \/ (Is_absent_in mems menv env c
           /\ menv' = menv /\ env' = env).
Proof.
  Hint Constructors Is_present_in Is_absent_in.
  intros prog menv env mems c s menv' env' Hs.
  revert s Hs.
  induction c; [now intuition|].
  intros s Hs.
  simpl in Hs.
  destruct b;
    specialize (IHc _ Hs); clear Hs;
    destruct IHc as [[Hp Hs]|[Hp [Hmenv Henv]]];
    try inversion_clear Hs;
  (left; now intuition)
   || (right;
        repeat progress
               match goal with
               | H: stmt_eval _ _ _ Skip _ |- _ => inversion H; subst; clear H
               | Hp: Is_present_in _ _ _ _,
                     He: exp_eval _ _ _ _ |- Is_absent_in _ _ _ _
                 => apply IsAbs2 with (1:=Hp) (2:=He)
               | _ => intuition
               end).
Qed.

Lemma stmt_eval_Control:
  forall prog mems menv env ck stmt,
    (Is_absent_in mems menv env ck
     -> stmt_eval prog menv env (Control mems ck stmt) (menv, env))
    /\
    (forall menv' env',
       Is_present_in mems menv env ck
       -> stmt_eval prog menv env stmt (menv', env')
       -> stmt_eval prog menv env (Control mems ck stmt) (menv', env')).
Proof.
  intros prog mems menv env ck.
  induction ck; intro s; split.
  - now inversion 1.
  - intros menv' env' Hp Hs; exact Hs.
  - inversion_clear 1 as [? ? ? Hp|? ? ? ? Hp Hexp Hneq];
    destruct b;
    try (now apply IHck with (1:=Hp));
    apply not_eq_sym in Hneq;
      (apply Bool.not_true_is_false in Hneq
       || apply Bool.not_false_is_true in Hneq);
      subst;
      apply IHck with (1:=Hp);
      (apply Iifte_false with (1:=Hexp)
       || apply Iifte_true with (1:=Hexp));
      constructor.
  - inversion_clear 1 as [|? ? ? Hp Hexp];
    intro Hs;
    destruct b;
    apply IHck with (1:=Hp);
    [ now apply Iifte_true with (1:=Hexp) (2:=Hs)
    | now apply Iifte_false with (1:=Hexp) (2:=Hs) ].
Qed.

Lemma stmt_eval_Control_absent:
  forall prog mems menv env ck stmt,
    Is_absent_in mems menv env ck
    -> stmt_eval prog menv env (Control mems ck stmt) (menv, env).
Proof.
  apply stmt_eval_Control.
Qed.

Lemma stmt_eval_Control_present:
  forall prog mems menv env ck stmt menv' env',
    Is_present_in mems menv env ck
    -> stmt_eval prog menv env stmt (menv', env')
    -> stmt_eval prog menv env (Control mems ck stmt) (menv', env').
Proof.
  apply stmt_eval_Control.
Qed.

Lemma stmt_eval_translate_cexp_menv_inv:
  forall prog menv env mems x menv' env' ce,
    stmt_eval prog menv env (translate_cexp mems x ce) (menv', env')
    -> menv' = menv.
Proof.
  intros prog menv env mems x menv' env'.
  induction ce using cexp_mult
  with (P := (fun cae : caexp =>
           stmt_eval prog menv env (translate_caexp mems x cae) (menv', env') ->
           menv' = menv));
  (apply IHce || inversion_clear 1); auto.
Qed.

Lemma stmt_eval_translate_cexp_env_add:
  forall prog menv env mems x menv' env' ce,
    stmt_eval prog menv env (translate_cexp mems x ce) (menv', env')
    -> exists c, env' = PM.add x c env.
Proof.
  intros prog menv env mems x menv' env'.
  induction ce using cexp_mult
  with (P := (fun cae : caexp =>
          stmt_eval prog menv env (translate_caexp mems x cae) (menv', env') ->
          exists c, env' = PM.add x c env));
    (apply IHce || inversion_clear 1); auto.
  exists v; rewrite <- H1; intuition.
Qed.

Lemma not_Is_memory_in_eq:
  forall prog x eq menv env mems menv' env',
    ~Is_memory_in_eq x eq
    -> stmt_eval prog menv env (translate_eqn mems eq) (menv', env')
    -> find_mem x menv' = find_mem x menv.
Proof. (* TODO: Tidy proof *)
  intros prog x eq menv env mems menv' env' Hneq Heval.
  destruct eq as [y cae|y f lae|y v0 lae].
  - destruct cae.
    simpl in Heval.
    apply stmt_eval_Control_fwd in Heval; destruct Heval as [Heval|Heval];
    destruct Heval as [Heval1 Heval2].
    apply stmt_eval_translate_cexp_menv_inv in Heval2.
    rewrite Heval2. intuition.
    destruct Heval2 as [Hmenv]; rewrite Hmenv; intuition.
  - destruct lae.
    simpl in Heval.
    apply stmt_eval_Control_fwd in Heval; destruct Heval as [Heval|Heval];
    destruct Heval as [Hipi Heval].
    inversion_clear Heval.
    rewrite <- H2.
    reflexivity.
    destruct Heval as [Hmenv Henv]; rewrite Hmenv; intuition.
  - apply not_Is_memory_in_eq_EqFby in Hneq.
    unfold translate_eqn in Heval.
    destruct lae.
    apply stmt_eval_Control_fwd in Heval; destruct Heval as [Heval|Heval];
    destruct Heval as [Hipi Heval].
    inversion_clear Heval.
    rewrite <- H0.
    unfold find_mem, add_mem.
    simpl; rewrite PM.gso; [intuition | apply Hneq].
    destruct Heval as [Hmenv Henv]; rewrite Hmenv; intuition.
Qed.

Lemma not_Is_instance_in_eq:
  forall prog x eq menv env mems menv' env',
    ~Is_instance_in_eq x eq
    -> stmt_eval prog menv env (translate_eqn mems eq) (menv', env')
    -> find_obj x menv' = find_obj x menv.
Proof. (* TODO: Tidy proof *)
  intros prog x eq menv env mems menv' env' Hneq Heval.
  destruct eq as [y cae|y f lae|y v0 lae].
  - destruct cae.
    simpl in Heval.
    apply stmt_eval_Control_fwd in Heval; destruct Heval as [Heval|Heval];
    destruct Heval as [Heval1 Heval2].
    apply stmt_eval_translate_cexp_menv_inv in Heval2.
    rewrite Heval2. intuition.
    destruct Heval2 as [Hmenv]; rewrite Hmenv; intuition.
  - destruct lae.
    simpl in Heval.
    apply stmt_eval_Control_fwd in Heval; destruct Heval as [Heval|Heval];
    destruct Heval as [Hipi Heval].
    + inversion_clear Heval.
      rewrite <- H2.
      destruct (ident_eq_dec x y) as [Hxy|Hxny].
      * rewrite Hxy in Hneq; exfalso; apply Hneq; constructor.
      * rewrite find_obj_gso; [reflexivity|assumption].
    + destruct Heval as [HR1 HR2]; rewrite HR1; reflexivity.
  - unfold translate_eqn in Heval.
    destruct lae.
    apply stmt_eval_Control_fwd in Heval; destruct Heval as [Heval|Heval];
    destruct Heval as [Hipi Heval].
    inversion_clear Heval.
    rewrite <- H0.
    unfold find_obj, add_mem.
    reflexivity.
    destruct Heval as [Hmenv Henv]; rewrite Hmenv; intuition.
Qed.

Lemma not_Is_variable_in_eq:
  forall prog x eq menv env mems menv' env',
    ~Is_variable_in_eq x eq
    -> stmt_eval prog menv env (translate_eqn mems eq) (menv', env')
    -> PM.find x env' = PM.find x env.
Proof.
  intros prog x eq menv env mems menv' env' Hnd Heval.
  destruct eq as [y e|y f e|y v0 e];
  try apply not_Is_variable_in_eq_EqDef in Hnd.
  - (unfold translate_eqn in Heval;
     destruct e;
     apply stmt_eval_Control_fwd in Heval; destruct Heval as [Heval|Heval];
     destruct Heval as [Hipi Heval]; [
       apply stmt_eval_translate_cexp_env_add in Heval;
       destruct Heval; rewrite H;
       rewrite PM.gso; [intuition | apply Hnd]
     | destruct Heval as [Hmenv Henv]; rewrite Henv; intuition]).
  - simpl in Heval; destruct e.
    apply stmt_eval_Control_fwd in Heval; destruct Heval as [Heval|Heval];
    destruct Heval as [Heval1 Heval2].
    inversion_clear Heval2.
    rewrite <- H3.
    rewrite PM.gso; [reflexivity|].
    intro Hxy; apply Hnd; rewrite Hxy; constructor.
    destruct Heval2 as [Hmenv Henv]; rewrite Henv; intuition.
  - simpl in Heval; destruct e.
    apply stmt_eval_Control_fwd in Heval; destruct Heval as [Heval|Heval];
    destruct Heval as [Heval1 Heval2].
    inversion Heval2; intuition.
    destruct Heval2 as [Hmenv Henv]; rewrite Henv; intuition.
Qed.

Lemma stmt_eval_translate_eqns_menv_inv:
  forall prog menv env mems eqs menv' env',
    stmt_eval prog menv env (translate_eqns mems eqs) (menv', env')
    -> (forall x, ~Is_memory_in x eqs ->
                  find_mem x menv' = find_mem x menv).
Proof.
  induction eqs as [ |eq].
  + inversion_clear 1; reflexivity.
  + intros menv' env' Heval x Hnmem.
    apply not_Is_memory_in_cons in Hnmem.
    destruct Hnmem as [H0 H1].
    apply stmt_eval_translate_eqns_cons in Heval.
    destruct Heval as [menv'' Heval];
      destruct Heval as [env'' Heval];
      destruct Heval as [Heval0 Heval1].
    apply IHeqs with (x:=x) (2:=H1) in Heval0.
    apply not_Is_memory_in_eq with (1:=H0) in Heval1.
    rewrite Heval1, Heval0.
    reflexivity.
Qed.

Lemma stmt_eval_translate_eqns_minst_inv:
  forall prog menv env mems eqs menv' env',
    stmt_eval prog menv env (translate_eqns mems eqs) (menv', env')
    -> (forall x, ~Is_instance_in x eqs ->
                  find_obj x menv' = find_obj x menv).
Proof.
  induction eqs as [ |eq].
  + inversion_clear 1; reflexivity.
  + intros menv' env' Heval x Hnmem.
    apply not_Is_instance_in_cons in Hnmem.
    destruct Hnmem as [H0 H1].
    apply stmt_eval_translate_eqns_cons in Heval.
    destruct Heval as [menv'' Heval];
      destruct Heval as [env'' Heval];
      destruct Heval as [Heval0 Heval1].
    apply IHeqs with (x:=x) (2:=H1) in Heval0.
    apply not_Is_instance_in_eq with (1:=H0) in Heval1.
    rewrite Heval1, Heval0.
    reflexivity.
Qed.

Lemma stmt_eval_translate_eqns_env_inv:
  forall prog menv env mems eqs menv' env',
    stmt_eval prog menv env (translate_eqns mems eqs) (menv', env')
    -> (forall x, ~Is_variable_in x eqs ->
                  PM.find x env' = PM.find x env).
Proof.
  induction eqs as [ |eq].
  + inversion_clear 1; reflexivity.
  + intros menv' env' Heval x Hndef.
    apply not_Is_variable_in_cons in Hndef.
    destruct Hndef as [H0 H1].
    apply stmt_eval_translate_eqns_cons in Heval.
    destruct Heval as [menv'' Heval];
      destruct Heval as [env'' Heval];
      destruct Heval as [Heval0 Heval1].
    apply IHeqs with (x:=x) (2:=H1) in Heval0.
    apply not_Is_variable_in_eq with (1:=H0) in Heval1.
    rewrite Heval1, Heval0.
    reflexivity.
Qed.

Local Ltac split_env_assumption :=
  match goal with
  | Henv: context Is_free_in_lexp [_], Hsem: sem_var _ ?y _ _
    |- _ => apply Henv in Hsem; [destruct Hsem |solve [auto]]; clear Henv
  | Henv: context Is_free_in_clock [_], Hsem: sem_var _ ?y _ _
    |- _ => apply Henv in Hsem; [destruct Hsem |solve [auto]]; clear Henv
  end.

Lemma clock_correct_true:
  forall H n memories menv env ck,
    (forall x c, Is_free_in_clock x ck
                 -> sem_var H x n (present c)
                 -> (~PS.In x memories -> PM.find x env = Some c)
                    /\ (PS.In x memories -> find_mem x menv = Some c))
    -> sem_clock H ck n true
    -> Is_present_in memories menv env ck.
Proof.
  Hint Constructors Is_present_in.
  Hint Constructors sem_clock.
  Hint Constructors Is_free_in_clock.
  Hint Constructors exp_eval.
  intros H n memories menv env.
  induction ck as [|? ? x]; [ intuition | ].
  intro Henv.
  inversion_clear 1.
  constructor. apply IHck; auto.
  intros.
  split_env_assumption.
  apply exp_eval_tovar;
    destruct In_dec with x memories;
    intuition.
Qed.

Lemma get_exp_eval_tovar:
  forall x mems menv env v,
    (~ PS.In x mems -> PM.find x env = Some v)
    -> (PS.In x mems -> find_mem x menv = Some v)
    -> exp_eval menv env (tovar mems x) v.
Proof.
  intros x mems menv env v Hvar Hmem.
  unfold tovar.
  destruct (In_dec x mems) as [Hin|Hnin].
  - specialize (Hmem Hin).
    apply PS.mem_spec in Hin; rewrite Hin.
    constructor; exact Hmem.
  - specialize (Hvar Hnin).
    apply mem_spec_false in Hnin; rewrite Hnin.
    constructor; exact Hvar.
Qed.

Lemma clock_correct_false:
  forall H n memories menv env ck,
    (forall x c, Is_free_in_clock x ck
                 -> sem_var H x n (present c)
                 -> (~PS.In x memories -> PM.find x env = Some c)
                    /\ (PS.In x memories -> find_mem x menv = Some c))
    -> sem_clock H ck n false
    -> Is_absent_in memories menv env ck.
Proof.
  Hint Constructors Is_absent_in sem_clock Is_free_in_clock exp_eval.
  intros H n memories menv env.
  induction ck as [|? ? x]; [ now inversion 2 | ].
  intro Henv.
  inversion_clear 1.
  constructor; apply IHck; now auto.
  apply clock_correct_true
  with (memories:=memories) (menv:=menv) (env:=env) in H1;
    [|now auto].
  apply IsAbs2 with (1:=H1) (3:=H3).
  split_env_assumption.
  destruct In_dec with x memories as [Hin|Hin];
    match goal with
    | H:~PS.In _ _ -> _, Hin:~PS.In _ _ |- _ => specialize (H Hin)
    | H:PS.In _ _ -> _, Hin:PS.In _ _ |- _ => specialize (H Hin)
    end;
    apply PS.mem_spec in Hin || apply mem_spec_false in Hin;
    unfold tovar;
    rewrite Hin;
    intuition.
Qed.

Lemma lexp_correct:
  forall H memories menv env n c e,
    sem_lexp H e n (present c)
    -> (forall x c, Is_free_in_lexp x e
                    -> sem_var H x n (present c)
                    -> (~PS.In x memories -> PM.find x env = Some c)
                       /\ (PS.In x memories -> find_mem x menv = Some c))
    -> exp_eval menv env (translate_lexp memories e) c.
Proof.
  Hint Constructors exp_eval.
  intros H memories menv env n c.
  induction e as [c0 e IH|c0|y|e IH y yb] using lexp_mult
  with (P:=fun e =>
          sem_laexp H e n (present c)
          -> (forall x c, Is_free_in_laexp x e
                          -> sem_var H x n (present c)
                          -> (~PS.In x memories -> PM.find x env = Some c)
                             /\ (PS.In x memories -> find_mem x menv = Some c))
          -> exp_eval menv env (translate_laexp memories e) c);
    inversion 1; intros;
    try apply IH; try apply econst; auto.
  split_env_assumption;
    unfold translate_lexp;
    destruct (PS.mem y memories) eqn:Hm;
    rewrite PS.mem_spec in Hm || rewrite mem_spec_false in Hm;
    auto.
Qed.

Lemma laexp_correct:
  forall H memories menv env n c e,
    sem_laexp H e n (present c)
    -> (forall x c, Is_free_in_laexp x e
                    -> sem_var H x n (present c)
                    -> (~PS.In x memories -> PM.find x env = Some c)
                       /\ (PS.In x memories -> find_mem x menv = Some c))
    -> exp_eval menv env (translate_laexp memories e) c.
Proof.
  intros H memories menv env n c e Hsem Henv.
  destruct e as [ck ce].
  inversion_clear Hsem as [? ? ? ? Hlexp ?|].
  change (exp_eval menv env (translate_lexp memories ce) c).
  apply (lexp_correct _ _ _ _ _ _ _ Hlexp); auto.
Qed.

Lemma cexp_correct:
  forall H memories prog menv env n c x e,
    sem_cexp H e n (present c)
    -> (forall x c, Is_free_in_cexp x e
                    -> sem_var H x n (present c)
                    -> (~PS.In x memories -> PM.find x env = Some c)
                       /\ (PS.In x memories -> find_mem x menv = Some c))
    -> stmt_eval prog menv env (translate_cexp memories x e)
                                                        (menv, PM.add x c env).
Proof.
  intros H memories prog menv env n c x.
  induction e as [ck e IH|b et IHt ef IHf|e] using cexp_mult
  with (P:=fun e =>
             sem_caexp H e n (present c)
             -> (forall x c,
                    Is_free_in_caexp x e
                    -> sem_var H x n (present c)
                    -> (~PS.In x memories -> PM.find x env = Some c)
                       /\ (PS.In x memories -> find_mem x menv = Some c))
             -> stmt_eval prog menv env (translate_caexp memories x e)
                          (menv, PM.add x c env)).
  - (* CAexp *) inversion 1; auto.
  - (* Emerge *)
    inversion_clear 1; intro Henv.
    + apply Iifte_true.
      split_env_assumption.
      apply get_exp_eval_tovar; now auto.
      apply IHt; now auto.
    + apply Iifte_false.
      split_env_assumption.
      apply get_exp_eval_tovar; now auto.
      apply IHf; now auto.
  - (* Eexp *)
    inversion_clear 1; intro Henv.
    unfold translate_cexp.
    econstructor.
    eapply lexp_correct; [eassumption|now auto].
    reflexivity.
Qed.

Lemma caexp_correct:
  forall H memories prog menv env n c x e,
    sem_caexp H e n (present c)
    -> (forall x c, Is_free_in_caexp x e
                    -> sem_var H x n (present c)
                    -> (~PS.In x memories -> PM.find x env = Some c)
                       /\ (PS.In x memories -> find_mem x menv = Some c))
    -> stmt_eval prog menv env (translate_caexp memories x e)
                                                  (menv, PM.add x c env).
Proof.
  intros H memories prog menv env n c x e Hsem Henv.
  destruct e as [ck ce].
  inversion_clear Hsem as [? ? ? ? Hlexp ?|].
  change (stmt_eval prog menv env (translate_cexp memories x ce)
                     (menv, PM.add x c env)).
  apply cexp_correct with (1:=Hlexp); now auto.
Qed.

(* Notes:
   1. The assumption sem_equations must be shown for a set of equations.
      TODO: lemma showing that a well-typed and well-clocked set of
            equations has a semantics.

   2. The assumption stmt_eval (translate_eqns mems eqs) implies that an
      execution exists and thus that exp_eval's evar and estate find some
      value for each required variable.
      This is somehow backwards; it should be an obligation to show that
      an execution exists. This is something assured indirectly in the
      lemma below where we require not just that evar and estate find
      some value, but also that it is the correct value.
 *)

Inductive Memory_Corres (G: global) (n: nat) :
       ident -> memory -> memoryEnv -> Prop :=
| MemC:
    forall f M menv i o eqs,
      find_node f G = Some(mk_node f i o eqs)
      -> List.Forall (Memory_Corres_eq G n M menv) eqs
      -> Memory_Corres G n f M menv

with Memory_Corres_eq (G: global) (n: nat) :
       memory -> memoryEnv -> equation -> Prop :=
| MemC_EqDef:
    forall M menv x cae,
      Memory_Corres_eq G n M menv (EqDef x cae)
| MemC_EqApp:
    forall M menv x f lae,
      (forall Mo, mfind_inst x M = Some Mo
                  -> (exists omenv,
                         find_obj x menv = Some omenv
                         /\ Memory_Corres G n f Mo omenv))
      -> Memory_Corres_eq G n M menv (EqApp x f lae)
| MemC_EqFby:
    forall M menv x v0 lae,
      (forall ms, mfind_mem x M = Some ms
                  -> find_mem x menv = Some (ms n))
      -> Memory_Corres_eq G n M menv (EqFby x v0 lae).

Section Memory_Corres_mult.
  Variables (G: global) (n: nat).

  Variable P : ident -> memory -> memoryEnv -> Prop.
  Variable Peq : memory -> memoryEnv -> equation -> Prop.

  Hypothesis EqDef_case: forall M menv x cae,
      Peq M menv (EqDef x cae).

  Hypothesis EqApp_case: forall M menv x f lae,
      (forall Mo (Hmfind: mfind_inst x M = Some Mo),
          (exists omenv, find_obj x menv = Some omenv /\ P f Mo omenv))
      -> Peq M menv (EqApp x f lae).

  Hypothesis EqFby_case: forall M menv x v0 lae,
      (forall ms, mfind_mem x M = Some ms
                  -> find_mem x menv = Some (ms n))
      -> Peq M menv (EqFby x v0 lae).

  Hypothesis MemC_case:
    forall f M menv i o eqs
           (Hfind : find_node f G = Some (mk_node f i o eqs)),
      Forall (Peq M menv) eqs
      -> P f M menv.

  Fixpoint Memory_Corres_mult (f    : ident)
                              (M    : memory)
                              (menv : memoryEnv)
                              (Hmc  : Memory_Corres G n f M menv)
                              {struct Hmc} : P f M menv :=
    match Hmc in (Memory_Corres _ _ f M menv) return (P f M menv) with
    | MemC f M menv i o eqs Hfind Heqs =>
        MemC_case f M menv i o eqs Hfind
          (* Turn: Forall (Memory_Corres_eq G n M menv) eqs
             into: Forall (Peq M menv) eqs *)
          ((fix map (eqs : list equation)
                    (Heqs: Forall (Memory_Corres_eq G n M menv) eqs) :=
              match Heqs in Forall _ fs return (Forall (Peq M menv) fs)
              with
              | Forall_nil => Forall_nil _
              | Forall_cons eq eqs Heq Heqs' =>
                Forall_cons eq (Memory_Corres_eq_mult M menv eq Heq)
                            (map eqs Heqs')
              end) eqs Heqs)
    end

  with Memory_Corres_eq_mult (M     : memory)
                             (menv  : memoryEnv)
                             (eq    : equation)
                             (Hmceq : Memory_Corres_eq G n M menv eq)
                             {struct Hmceq} : Peq M menv eq.
  refine(
    match Hmceq in (Memory_Corres_eq _ _ M menv eq) return (Peq M menv eq)
    with
    | MemC_EqDef M menv x cae => EqDef_case M menv x cae
    | MemC_EqApp M menv x f lae Hmc =>
        EqApp_case M menv x f lae
                   (fun (Mo     : memory)
                        (Hmfind : mfind_inst x M = Some Mo) => _)
    | MemC_EqFby M menv x v0 lae Hfind => EqFby_case M menv x v0 lae Hfind
    end).
  specialize (Hmc Mo Hmfind).
  destruct Hmc as [omenv [Hfindo Hmc]].
  exists omenv.
  apply Memory_Corres_mult in Hmc.
  split; [exact Hfindo|exact Hmc].
  Defined.

End Memory_Corres_mult.

Lemma Memory_Corres_eq_node_tl:
  forall node G eq n M menv,
    Ordered_nodes (node::G)
    -> ~Is_node_in_eq node.(n_name) eq
    -> (Memory_Corres_eq (node::G) n M menv eq
        <-> Memory_Corres_eq G n M menv eq).
Proof.
  intros node G eqs n M menv Hord Hini.
  split; intro Hmc; revert M menv eqs Hmc Hini.
  - induction 1 as [|? ? ? ? ? Hfind| |? ? ? ? ? ? Hfindn IH]
      using Memory_Corres_eq_mult
      with (P:=fun f M menv=>
                 node.(n_name) <> f ->
                 Memory_Corres G n f M menv);
    intro HH; try constructor.
    + intros Mo Hmfind.
      specialize (Hfind _ Hmfind).
      destruct Hfind as [omenv [Hfindo IH]].
      exists omenv.
      split; [exact Hfindo|].
      apply IH.
      intro Hneq; rewrite <-Hneq in HH.
      apply HH; repeat constructor.
    + trivial.
    + simpl in Hfindn.
      apply ident_eqb_neq in HH.
      rewrite HH in Hfindn.
      econstructor; [exact Hfindn|].
      apply find_node_later_not_Is_node_in with (2:=Hfindn) in Hord.
      simpl in Hord; clear Hfindn.
      apply Is_node_in_Forall in Hord.
      apply Forall_Forall with (1:=Hord) in IH.
      apply Forall_impl with (2:=IH).
      intuition.
  - induction 1 as [|? ? ? ? ? Hfind| |? ? ? ? ? ? Hfindn IH]
      using Memory_Corres_eq_mult
      with (P:=fun f M menv=>
                 node.(n_name) <> f ->
                 Memory_Corres (node::G) n f M menv);
      intro HH; try constructor.
    + intros Mo Hmfind.
      specialize (Hfind _ Hmfind).
      destruct Hfind as [omenv [Hfindo IH]].
      exists omenv.
      split; [exact Hfindo|].
      apply IH.
      intro Hneq; rewrite <-Hneq in HH.
      apply HH; repeat constructor.
    + intuition.
    + apply find_node_later_not_Is_node_in with (2:=Hfindn) in Hord.
      rewrite <-find_node_tl with (1:=HH) in Hfindn.
      econstructor; [exact Hfindn|].
      apply Is_node_in_Forall in Hord.
      apply Forall_Forall with (1:=Hord) in IH.
      apply Forall_impl with (2:=IH).
      intuition.
Qed.

Lemma Memory_Corres_eqs_node_tl:
  forall node G eqs n M menv,
    Ordered_nodes (node::G)
    -> ~Is_node_in node.(n_name) eqs
    -> (Forall (Memory_Corres_eq (node::G) n M menv) eqs
        <-> Forall (Memory_Corres_eq G n M menv) eqs).
Proof.
  induction eqs as [|eq eqs IH]; [now intuition|].
  intros n M menv Hord Hnini.
  apply not_Is_node_in_cons in Hnini.
  destruct Hnini as [Hnini Hninis].
  split;
    intro HH; apply Forall_cons2 in HH; destruct HH as [HH HHs];
    apply Forall_cons;
    (apply Memory_Corres_eq_node_tl with (1:=Hord) (2:=Hnini) (3:=HH)
     || apply IH with (1:=Hord) (2:=Hninis) (3:=HHs)).
Qed.

Lemma Memory_Corres_node_tl:
  forall f node G n M menv,
    Ordered_nodes (node :: G)
    -> node.(n_name) <> f
    -> (Memory_Corres (node :: G) n f M menv <-> Memory_Corres G n f M menv).
Proof.
  intros f node G n M menv Hord Hnf.
  split;
    inversion_clear 1;
    econstructor;
    repeat progress
         match goal with
         | Hf: find_node ?f (_ :: ?G) = Some _ |- _ =>
           rewrite find_node_tl with (1:=Hnf) in Hf
         | |- find_node ?f (_ :: ?G) = Some _ =>
           rewrite find_node_tl with (1:=Hnf)
         | Hf: find_node ?f ?G = Some _ |- find_node ?f ?G = Some _ => exact Hf
         | H:Forall (Memory_Corres_eq _ _ _ _) _
           |- Forall (Memory_Corres_eq _ _ _ _) _ =>
           apply Memory_Corres_eqs_node_tl with (1:=Hord) (3:=H)
         | Hf: find_node ?f ?G = Some _ |- ~Is_node_in _ _ =>
           apply find_node_later_not_Is_node_in with (1:=Hord) (2:=Hf)
         end.
Qed.

Lemma Is_memory_in_Memory_Corres_eqs:
  forall G n M menv x eqs,
    Is_memory_in x eqs
    -> Forall (Memory_Corres_eq G n M menv) eqs
    -> (forall ms, mfind_mem x M = Some ms
                   -> find_mem x menv = Some (ms n)).
Proof.
  induction eqs as [|eq eqs IH]; [now inversion 1|].
  intros Himi Hmc ms.
  apply Is_memory_in_cons in Himi.
  inversion_clear Hmc as [|? ? Hmceq Hmceqs].
  destruct Himi as [Himeqs|[Himeq Himeqs]];
    [|now apply IH with (1:=Himeqs) (2:=Hmceqs)].
  destruct eq; inversion_clear Himeqs.
  inversion_clear Hmceq; auto.
Qed.

Lemma Memory_Corres_eqs_add_mem:
  forall G M menv n y ms eqs,
    mfind_mem y M = Some ms
    -> Forall (Memory_Corres_eq G n M menv) eqs
    -> Forall (Memory_Corres_eq G n M (add_mem y (ms n) menv)) eqs.
Proof.
  induction eqs as [|eq eqs IH]; [now auto|].
  intros Hmfind Hmc.
  apply Forall_cons2 in Hmc.
  destruct Hmc as [Hmc0 Hmc1].
  apply Forall_cons; [|apply IH with (1:=Hmfind) (2:=Hmc1)].
  destruct eq; repeat constructor.
  - intros Mo Hifind.
    inversion_clear Hmc0 as [|? ? ? ? ? Hmc|].
    specialize (Hmc _ Hifind).
    destruct Hmc as [omenv HH].
    exists omenv.
    exact HH.
  - intros ms' Hmfind'.
    destruct (ident_eq_dec i y) as [He|Hne].
    + rewrite He in *.
      rewrite Hmfind in Hmfind'.
      injection Hmfind'; intro H; rewrite <- H; clear H.
      rewrite find_mem_gss; reflexivity.
    + rewrite find_mem_gso with (1:=Hne).
      inversion_clear Hmc0 as [| |? ? ? ? ? Hmc].
      now apply Hmc with (1:=Hmfind').
Qed.

(* Unfortunately, a similar lemma to Memory_Corres_eqs_add_mem but for add_obj
   does not seem to hold without extra conditions:

     Lemma Memory_Corres_eqs_add_obj:
       forall G n M menv y Mo g omenv eqs,
         mfind_inst y M = Some Mo
         -> Memory_Corres G n g Mo omenv
         -> Memory_Corres_eqs G n M menv eqs
         -> Memory_Corres_eqs G n M (add_obj y omenv menv) eqs.

   Consider the equations:
      [ x = f y; x = g y; ... ]
   It is possible for this system to have an m-semantics if both f and g have
   the same input/output behaviour, but also possible for the memory structures
   of f and g to differ from one another. In this case, we end up having as
   hypothesis
        Memory_Corres G n g Mo omenv
   and the goal
        Memory_Corres G n f Mo omenv *)

Lemma Memory_Corres_eqs_add_obj:
  forall G n M menv eqs y omenv,
    Forall (Memory_Corres_eq G n M menv) eqs
    -> ~Is_instance_in y eqs
    -> Forall (Memory_Corres_eq G n M (add_obj y omenv menv)) eqs.
Proof.
  induction eqs as [|eq eqs IH]; [now constructor|].
  intros y omenv Hmce Hniii.
  apply Forall_cons2 in Hmce.
  destruct Hmce as [Hmce0 Hmce1].
  apply not_Is_instance_in_cons in Hniii.
  destruct Hniii as [Hniii0 Hniii1].
  apply Forall_cons; [|now apply IH with (1:=Hmce1) (2:=Hniii1)].
  destruct eq; constructor; try constructor.
  - intros Mo Hmfind.
    destruct (ident_eq_dec i y) as [Hiy|Hniy].
    + rewrite Hiy in Hniii0; exfalso; apply Hniii0; constructor.
    + inversion_clear Hmce0 as [|? ? ? ? ? Hfindo|].
      specialize (Hfindo _ Hmfind).
      destruct Hfindo as [omenv' [Hfindo Hmc]].
      exists omenv'.
      split; [|exact Hmc].
      rewrite find_obj_gso; [|exact Hniy].
      exact Hfindo.
  - intros ms Hmfind.
    inversion_clear Hmce0 as [| |? ? ? ? ? HH].
    rewrite find_mem_add_obj.
    apply HH with (1:=Hmfind).
Qed.

Lemma Memory_Corres_unchanged:
  forall G f n ls M ys menv,
    Welldef_global G
    -> msem_node G f ls M ys
    -> ls n = absent
    -> Memory_Corres G n f M menv
    -> Memory_Corres G (S n) f M menv.
Proof.
  intros G f n ls M ys menv Hwdef Hmsem Habs.
  revert menv.
  induction Hmsem as [|H M y f M' lae ls ys Hmfind Hls Hys Hmsem IH
                      |H M ms y ls v0 lae Hmfind Hms0 Hls Hy
                      |f xs M ys i o eqs Hf Heqs IH]
  using msem_node_mult
  with (P := fun H M eq Hsem =>
               forall menv,
                 rhs_absent H n eq
                 -> Memory_Corres_eq G n M menv eq
                 -> Memory_Corres_eq G (S n) M menv eq).
  - constructor.
  - intros Hrhsa Hmceq.
    constructor.
    intros Mo Hmfind'.
    rewrite Hmfind in Hmfind'.
    injection Hmfind'; intro Heq; rewrite <-Heq; clear Heq Hmfind'.
    inversion_clear Hmceq as [|? ? ? ? ? Hmc'|].
    specialize (Hmc' _ Hmfind).
    destruct Hmc' as [omenv [Hfindo Hmc]].
    exists omenv.
    split; [exact Hfindo|].
    apply IH with (2:=Hmc).
    inversion_clear Hrhsa as [|? ? ? Hlaea|].
    now apply sem_laexp_det with (1:=(Hls n)) (2:=Hlaea).
  - rename Habs into menv.
    intros Hdefabs Hmceq.
    constructor.
    intros ms0 Hmfind0.
    rewrite Hmfind in Hmfind0.
    injection Hmfind0; intro Heq; rewrite <-Heq; clear Heq Hmfind0 ms0.
    inversion_clear Hmceq as [| |? ? ? ? ? Hmenv].
    apply Hmenv in Hmfind.
    rewrite Hmfind.
    inversion_clear Hdefabs as [| |? ? ? Hlaea].
    apply sem_laexp_det with (1:=(Hls n)) in Hlaea.
    specialize Hy with n.
    rewrite Hlaea in Hy.
    destruct Hy as [Hmseq H0].
    rewrite Hmseq.
    reflexivity.
  - intros menv Hmc.
    inversion_clear Hmc as [? ? ? i' o' eqs' Hf' Hmceqs].
    rewrite Hf in Hf'.
    injection Hf';
      intros HR1 HR2 HR3;
      rewrite <-HR1, <-HR2, <-HR3 in *;
      clear i' o' eqs' Hf' HR1 HR2 HR3.
    clear Heqs.
    destruct IH as [H [Hxs [Hys [Habs' [Hout HH]]]]].
    apply Habs' in Habs.
    apply Forall_Forall with (1:=Habs) in HH.
    apply Forall_Forall with (1:=Hmceqs) in HH.
    clear Habs Hmceqs.
    econstructor; [exact Hf|].
    apply Forall_impl with (2:=HH); clear HH.
    intros eq HH.
    destruct HH as [Hmceq [Habseq [Hmsem HH]]].
    now apply HH with (1:=Habseq) (2:=Hmceq).
Qed.

Lemma Is_memory_in_msem_var:
  forall G H M n x eqs c,
    Is_memory_in x eqs
    -> sem_var H x n (present c)
    -> List.Forall (msem_equation G H M) eqs
    -> (exists ms, mfind_mem x M = Some ms /\ ms n = c).
Proof.
  induction eqs as [|eq eqs IH];
    inversion_clear 1 as [? ? Himi|? ? Himi];
    intros Hsv Hmsem;
    apply Forall_cons2 in Hmsem;
    destruct Hmsem as [Hmeq Hmeqs].
  - destruct eq; inversion Himi; subst.
    inversion_clear Hmeq as [| |? ? ? ? ls ? Ha Hmfind Hms0 Hsemls Hmls].
    exists ms.
    split; [apply Hmfind|].
    specialize Hmls with n.
    destruct (ls n);
      destruct Hmls as [Hms Hsv'];
      apply sem_var_det with (1:=Hsv) in Hsv';
      [discriminate Hsv'|injection Hsv'];
      auto.
  - apply IH; assumption.
Qed.

Lemma find_node_translate_find_class:
  forall f G node,
    find_node f G = Some node
    -> (exists prog',
           find_class f (translate G) = Some (translate_node node, prog')).
Proof.
  induction G as [|nd G IH]; [now inversion 1|].
  intros node Hfind.
  simpl; simpl in Hfind.
  destruct (ident_eqb nd.(n_name) f) eqn:Heq.
  - injection Hfind; intro He; rewrite He in *; clear He Hfind.
    exists (translate G); reflexivity.
  - apply IH in Hfind.
    destruct Hfind as [prog'].
    exists prog'.
    assumption.
Qed.

Local Ltac resolve_env_assumption :=
  intro x; intros; split; intros;
  match goal with
  | Hws: Is_well_sch (PS.add ?input _) _ |- _ =>
    destruct (ident_eq_dec x input);
      repeat progress
             match goal with
             | H: exists _, _ |- _ => destruct H
             | H: _ /\ _ |- _ => destruct H

             | H:   ~PS.In x _,
               Hin: x=input,
               Hws: Is_well_sch _ (_ :: _) |- _ =>
                 subst;
                 apply Is_well_sch_free_variable_in_mems with input _ _ _ in Hws;
                 [ apply not_Is_defined_in_not_Is_variable_in in Hws
                 | auto | apply PS.add_spec; auto ]

             | H1: x = input, H2: PS.In x ?mems |- _ =>
               rewrite H1 in H2; contradiction

             | H:   ~PS.In x _,
               Hin: x<>input,
               Hws: Is_well_sch _ (_ :: _) |- _ =>
                 apply Is_well_sch_free_variable with x _ _ _ in Hws;
                 [ | auto | intro HH; apply PS.add_spec in HH; intuition ]

             | H0:~Is_variable_in _ _,
               H1: stmt_eval _ _ _ _ _ |- _ =>
                 apply (stmt_eval_translate_eqns_env_inv _ _ _ _ _ _ _ H1) in H0;
                 rewrite H0

             | H:forall c:const, sem_var _ _ _ _ <-> PM.find ?x ?env = _
                                 |- PM.find ?x ?env = _ => now (apply H)

             | Hv: forall x' : ident,
                 Is_variable_in x' ?eqs ->
                                forall c' : const,
                                  sem_var ?H x' ?n (present c')
                                  <-> PM.find x' ?env = Some c',
               Hs: sem_var ?H ?x ?n (present ?c)
               |-  PM.find ?x ?env = Some ?c => apply Hv; [now auto|apply Hs]

             | Hin: PS.In ?x ?mems,
               Hm: forall x, PS.In x ?mems -> Is_memory_in x _
               |- find_mem ?x ?menv = Some _ =>
               specialize (Hm _ Hin)

             | H1: Is_memory_in ?x ?eqs,
               H2: sem_var ?H ?x ?n (present ?c),
               H3: List.Forall (msem_equation ?G ?H ?M) ?eqs
               |- find_mem ?x ?menv = Some _ =>
               apply Is_memory_in_msem_var with (1:=H1) (2:=H2) in H3

             | H1: ?ms ?n = ?c |- find_mem ?x ?menv = Some ?c => rewrite <- H1

             | Hin: PS.In ?x ?mems,
               Hwsch: Is_well_sch _ (_ :: _)
               |- find_mem ?x _ = Some _ =>
               inversion_clear Hwsch;
                 match goal with
                 | HH: forall i, ?isfreein i ?e -> ?Pvar /\ ?Pmem,
                   Hf: ?isfreein ?x ?e |- _  => apply HH in Hf; destruct Hf
                 end

             | H1: ?xs ?n = ?c,
               H2: find_mem ?x ?menv = Some (?xs ?n)
               |- find_mem ?x ?menv = Some ?c =>
               rewrite H1 in H2; exact H2

             | Hin: PS.In ?x ?mems,
               HH: PS.In ?x (PS.add _ ?mems) -> _ |- find_mem _ _ = Some _ =>
               eapply or_intror in Hin;
                 apply PS.add_spec in Hin;
                 specialize (HH Hin)

             | Hnd: ~Is_defined_in ?x ?eqs,
               Hstmt: stmt_eval _ _ _ (translate_eqns ?mems ?eqs) (?menv', _)
               |- find_mem ?x ?menv' = _ =>
               apply not_Is_defined_in_not_Is_memory_in in Hnd;
                 apply stmt_eval_translate_eqns_menv_inv with (2:=Hnd) in Hstmt;
                 rewrite Hstmt

             | Himi: Is_memory_in ?x ?all,
               Hmc: Forall (Memory_Corres_eq _ ?n _ ?menv) ?all,
               Hmfind: mfind_mem ?x _ = Some ?vs
               |- find_mem ?x ?menv = Some (?vs ?n) =>
               now apply Is_memory_in_Memory_Corres_eqs
               with (1:=Himi) (2:=Hmc) (3:=Hmfind)
             end
  end.

Lemma not_absent_present:
  forall x, x <> absent <-> exists c, x = present c.
Proof.
  intros x.
  split; intro HH.
  destruct x; [intuition|eauto].
  destruct HH as [c HH]; rewrite HH.
  intro; discriminate.
Qed.

Lemma is_step_correct:
  forall (G: global)
         (H: history)
         (M: memory)
         (mems: PS.t)
         (alleqs : list equation),

    List.Forall (msem_equation G H M) alleqs
    -> (forall x:ident, PS.In x mems -> Is_memory_in x alleqs) (* ?? *)

    -> forall (prog: program)
              (input: ident)
              (eqs: list equation)
              (n: nat)
              (menv: memoryEnv)
              (env: constEnv),
        (exists oeqs, alleqs = oeqs ++ eqs)
        -> Welldef_global G
        -> prog = translate G

        (* - input (assumed) *)
        -> (forall c, sem_var H input n (present c)
                      <-> PM.find input env = Some c)
          (* NB: PM.find x env' = Some c -> sem_var H x n (present c)
                 does not hold if PM.find x env = Some arbitrary_c, since
                 x will not be written to when its clock is absent.

                 It may just be better to show the direction:
                 sem_var H x n (present c) -> PM.find x env' = Some c

                 which is enough if the outputs are only sampled when
                 they are present (normally the case).

                 More discussion/context is needed. *)
        -> (forall x, Is_variable_in x eqs -> PM.find x env = None)
        -> ~PS.In input mems
        -> ~ Is_defined_in input eqs

        (* - execution of translated equations *)
        -> Is_well_sch (PS.add input mems) eqs
        -> (forall x:ident, PS.In x mems -> Is_memory_in x alleqs)

        (* - instantiated nodes (assumed) *)
        -> (forall f fnode xs M ys prog' fclass menv env,
               find_node f G = Some fnode
               -> msem_node G f xs M ys
               -> Memory_Corres G n f M menv
               -> find_class f prog = Some (fclass, prog')
               -> env = match xs n with
                        | absent => empty
                        | present c => PM.add (c_input fclass) c empty
                        end
               -> exists menv' env',
                   stmt_eval prog' menv env (c_step fclass) (menv', env')
                   /\ (forall c, ys n = present c
                                 <-> PM.find (c_output fclass) env' = Some c)
                   /\ Memory_Corres G (S n) f M menv')

        (* - unwritten memories (assumed) *)
        -> List.Forall (Memory_Corres_eq G n M menv) alleqs

        (* - locals (shown) *)
        -> (exists menv' env',
               stmt_eval prog menv env (translate_eqns mems eqs) (menv', env')
               /\ (forall x, Is_variable_in x eqs
                             -> forall c : const, sem_var H x n (present c)
                                                  <-> PM.find x env' = Some c)
               (* - written memories (shown) *)
               /\ List.Forall (Memory_Corres_eq G (S n) M menv') eqs).
Proof.
  intros until alleqs.
  intros Hsems Himi.

  (* Induction on equations: translate_eqns [] = Skip *)
  induction eqs as [|eq];
    [ intros; exists menv, env;
      split; [unfold translate_eqns; constructor|];
      split; intros; [ match goal with
                       | H:Is_variable_in _ nil |- _ => inversion H
                       end | now constructor ]| ].
  intros n menv env Hall Hwdef Hprog Hin Henv Hin1 Hin2 Hwsch Hmeq Hnode Hmc.

  assert (exists menv' env',
             stmt_eval prog menv env (translate_eqns mems eqs) (menv', env')
             /\ (forall x, Is_variable_in x eqs
                           -> forall c, sem_var H x n (present c)
                                        <-> PM.find x env' = Some c)
             /\ List.Forall (Memory_Corres_eq G (S n) M menv') eqs) as IHeqs'.
  { eapply IHeqs.
    - apply List_shift_away with (1:=Hall).
    - exact Hwdef.
    - exact Hprog.
    - exact Hin.
    - intros; apply Henv; constructor 2; auto.
    - exact Hin1.
    - apply not_Is_defined_in_cons with (1:=Hin2).
    - apply Is_well_sch_cons with (1:=Hwsch).
    - exact Hmeq.
    - exact Hnode.
    - exact Hmc. }

  clear IHeqs.
  destruct IHeqs' as [menv' [env' [Hstmt [IHeqs0 IHeqs1]]]].

  destruct Hall as [oeqs Hall].
  assert (Hsems' := Hsems); rewrite Hall in Hsems'.

  apply Forall_app in Hsems'.
  destruct Hsems' as [H0 Hsems']; clear H0.
  apply Forall_cons2 in Hsems'.
  destruct Hsems' as [Hsem Hsems'].

  inversion Hsem as [H0 M0 y cae Hvar HR1 HR2 HR3
                    |H0 M0 y f Mo lae ls xs Hmfind Hlae Hvar Hmsem HR1 HR2 HR3
                    |H0 M0 ms y ls v0 lae Hmfind Hms0 Hlae Hvar HR1 HR2 HR3];
    (rewrite <-HR3 in *; clear HR1 HR2 HR3 H0 M0);
    specialize Hvar with n.
  - (* Case EqDef: y = cae *)
    exists menv'. (* the memory does not change *)
    destruct Hvar as [v [Hsv Hcae]].
    assert (forall x c,
               Is_free_in_caexp x cae
               -> sem_var H x n (present c)
               -> (~ PS.In x mems -> PM.find x env' = Some c)
                  /\ (PS.In x mems -> find_mem x menv' = Some c))
      as Hcae' by resolve_env_assumption.
    destruct v.
    + (* y = absent *)
      exists env'.
      inversion Hcae as [|? ? n0 Hcexp Hclk HR1 HR2];
        rewrite <-HR1 in *; clear HR1 HR2 n0.
      split; [|split].
      * apply stmt_eval_translate_eqns_cons.
        exists menv', env'.
        split; [exact Hstmt|].
        apply stmt_eval_Control_absent.
        apply clock_correct_false with (2:=Hclk); now auto.
      * intros x Hivi c.
        destruct (Is_variable_in_dec x eqs) as [Hvin|Hvin];
          [now apply IHeqs0 with (1:=Hvin)|].
        apply stmt_eval_translate_eqns_env_inv with (2:=Hvin) in Hstmt.
        rewrite Hstmt.
        inversion_clear Hivi as [? ? Hivi'|];
          [|unfold Is_variable_in in Hvin; contradiction].
        inversion_clear Hivi'.
        split; intro Hsv'.
        apply sem_var_det with (1:=Hsv) in Hsv'; discriminate.
        assert (PM.find y env = None).
        apply Henv; now repeat constructor.
        rewrite Hsv' in *; discriminate.
      * repeat constructor; assumption.
    + (* y = present *)
      exists (PM.add y v env').
      inversion Hcae as [? ? n0 v0 Hcexp Hclk HR1 HR2 HR3|];
        rewrite <-HR1 in *; clear HR1 HR2 HR3 n0 v0.
      split; [|split].
      * apply stmt_eval_translate_eqns_cons.
        exists menv', env'.
        split; [exact Hstmt|].
        apply stmt_eval_Control_present.
        apply clock_correct_true with (2:=Hclk); now auto.
        apply cexp_correct with (1:=Hcexp); now auto.
      * intros x Hivi c.
        inversion_clear Hivi as [? ? Hivi'|]; [inversion_clear Hivi'|].
        { rewrite PM.gss; split; intro HH.
          - apply sem_var_det with (1:=Hsv) in HH.
            injection HH; intro Heq; rewrite Heq; reflexivity.
          - injection HH; intro Heq; rewrite <-Heq; exact Hsv. }
        { destruct (ident_eq_dec x y) as [Hxy|Hnxy].
          - rewrite Hxy in *; clear Hxy.
            rewrite PM.gss.
            split.
            * intro Hsv'; apply sem_var_det with (1:=Hsv) in Hsv'.
              injection Hsv'; intro Heq; rewrite Heq; reflexivity.
            * intro Hsv'.
              injection Hsv'; intro Heq; rewrite Heq in Hsv; exact Hsv.
          - rewrite (PM.gso _ _ Hnxy).
            apply IHeqs0; assumption. }
      * repeat constructor; assumption.
  - (* Case EqApp: y = f lae *)
    specialize Hlae with n.
    (* used variables are defined *)
    assert (forall x c,
               Is_free_in_laexp x lae
               -> sem_var H x n (present c)
               -> (~ PS.In x mems -> PM.find x env' = Some c)
                  /\ (PS.In x mems -> find_mem x menv' = Some c))
      as Hlae' by resolve_env_assumption.
    (* memory correspondence before execution *)
    rewrite Hall in Hmc.
    apply Forall_app in Hmc.
    destruct Hmc as [Hmc0 Hmc]; clear Hmc0.
    apply Forall_cons2 in Hmc.
    destruct Hmc as [Hmceq Hmceqs].
    inversion_clear Hmceq as [|? ? ? ? ? Hmc0|].
    specialize (Hmc0 _ Hmfind).
    destruct Hmc0 as [omenv [Hfindo Hmc0]].
    (* dataflow semantics *)
    assert (Hmsem':=Hmsem).
    inversion_clear Hmsem' as [? ? ? ? i o neqs Hfind Hnsem].
    destruct Hnsem as [Hn [Hlsn [Hxsn [Habs [Hout Hnsem]]]]].
    specialize Hlsn with n;
      specialize Hxsn with n;
      specialize Habs with n;
      specialize Hout with n.
    (* no other instance *)
    assert (~Is_instance_in y eqs) as Hniii
        by (inversion_clear Hwsch; assumption).
    destruct (ls n) eqn:Hls.
    + (* y = absent *)
      exists menv', env'.
      specialize (Habs (eq_refl absent)).
      assert (xs n = absent) as Hout'
          by (apply Hout; reflexivity); clear Hout.
      inversion Hlae as [|? ? n0 Hlexp Hclk HR1 HR2];
        rewrite <-HR1 in *; clear HR1 HR2 n0.
      split; [|split].
      * apply stmt_eval_translate_eqns_cons.
        exists menv', env'.
        split; [exact Hstmt|].
        apply stmt_eval_Control_absent.
        apply clock_correct_false with (2:=Hclk); now auto.
      * intros x Hivi c.
        destruct (Is_variable_in_dec x eqs) as [Hvin|Hvin];
          [now apply IHeqs0 with (1:=Hvin)|].
        apply stmt_eval_translate_eqns_env_inv with (2:=Hvin) in Hstmt.
        rewrite Hstmt.
        inversion_clear Hivi as [? ? Hivi'|];
          [|unfold Is_variable_in in Hvin; contradiction].
        inversion Hivi' as [|x' f' e HR1 [HR2 HR3 HR4]];
          rewrite HR2 in *; clear HR1 HR2 HR3 HR4 x' f' e Hivi'.
        split; intro Hsv'.
        { inversion_clear Hsv' as [xs' Hfind' Hxs'].
          inversion_clear Hvar as [xs'' Hfind'' Hxs''].
          rewrite Hfind' in Hfind''.
          injection Hfind''; intro HR1; rewrite <-HR1 in *; clear HR1 Hfind''.
          rewrite Hxs'' in *.
          rewrite Hout' in Hxs'; discriminate. }
        { assert (PM.find y env = None) as Hnone
              by (apply Henv; repeat constructor).
          rewrite Hnone in Hsv'.
          discriminate. }
      * apply Forall_cons; [|now apply IHeqs1].
        constructor.
        intros Mo' Hmfind'.
        rewrite Hmfind in Hmfind'.
        injection Hmfind'; intro He; rewrite <-He in *; clear He Hmfind'.
        exists omenv.
        rewrite stmt_eval_translate_eqns_minst_inv with (1:=Hstmt) (2:=Hniii).
        split; [exact Hfindo|].
        now apply Memory_Corres_unchanged
        with (1:=Hwdef) (2:=Hmsem) (3:=Hls) (4:=Hmc0).
    + (* y = present *)
      pose proof (find_node_translate_find_class _ _ _ Hfind) as Hfindc.
      destruct Hfindc as [prog' Hfindc].
      assert (
          let fclass := translate_node (mk_node f i o neqs) in
          exists omenv' oenv',
            stmt_eval prog' omenv (PM.add i.(v_name) v empty)
                      (c_step fclass) (omenv', oenv')
            /\ (forall c,
                   xs n = present c
                   <-> PM.find (c_output fclass) oenv' = Some c)
            /\ Memory_Corres G (S n) f Mo omenv') as Hnode'.
      { eapply Hnode with (1:=Hfind) (2:=Hmsem) (3:=Hmc0).
        - rewrite Hprog; exact Hfindc.
        - rewrite Hls; reflexivity. }
      clear Hnode.
      simpl in *.
      destruct Hnode' as [omenv' [oenv' [Hnstmt [Hnout Hnmc]]]].
      assert (xs n <> absent) as Hxsp
          by (intro HH; apply Hout in HH; discriminate).
      apply not_absent_present in Hxsp.
      destruct Hxsp as [c Hxsc].
      exists (add_obj y omenv' menv'), (PM.add y c env').
      inversion Hlae as [? ? n' v' Hlexp Hclk HR1 HR2 HR3|];
        rewrite <-HR1 in *; clear HR1 HR2 HR3 n' v'.
      split; [|split].
      * apply stmt_eval_translate_eqns_cons.
        exists menv', env'.
        split; [exact Hstmt|].
        apply stmt_eval_Control_present.
        apply clock_correct_true with (2:=Hclk); now auto.
        apply lexp_correct
        with (memories:=mems) (menv:=menv') (env:=env') in Hlexp;
          [|now auto].
        rewrite Hprog in *.
        rewrite <-stmt_eval_translate_eqns_minst_inv
        with (1:=Hstmt) (2:=Hniii) in Hfindo.
        eapply Istep with (1:=Hfindo) (2:=Hlexp);
          [|reflexivity|reflexivity].
        eapply Iestep with (1:=Hfindc) (2:=Hnstmt).
        now apply Hnout with (1:=Hxsc).
      * intros x Hivi c'.
        inversion_clear Hivi as [? ? Hivi'|]; [inversion_clear Hivi'|].
        { rewrite PM.gss; split; intro HH.
          - apply sem_var_det with (1:=Hvar) in HH.
            rewrite Hxsc in HH.
            injection HH; intro Heq; rewrite Heq; reflexivity.
          - injection HH; intro Heq; rewrite <-Heq.
            rewrite <-Hxsc; exact Hvar. }
        { destruct (ident_eq_dec x y) as [Hxy|Hnxy].
          - rewrite Hxy in *; clear Hxy.
            rewrite PM.gss.
            split.
            * intro Hvar'; apply sem_var_det with (1:=Hvar) in Hvar'.
              rewrite Hxsc in Hvar'.
              injection Hvar'; intro Heq; rewrite Heq; reflexivity.
            * intro Hsv'.
              injection Hsv'; intro Heq; rewrite <-Heq in *.
              rewrite Hxsc in Hvar; exact Hvar.
          - rewrite (PM.gso _ _ Hnxy).
            apply IHeqs0; assumption. }
      * apply Forall_cons.
        2:now apply Memory_Corres_eqs_add_obj with (1:=IHeqs1) (2:=Hniii).
        constructor.
        intros Mo' Hmfind'.
        rewrite Hmfind in Hmfind'.
        injection Hmfind'; intro Heq; rewrite <-Heq in *; clear Heq Hmfind'.
        exists omenv'.
        split; [rewrite find_obj_gss; reflexivity|exact Hnmc].
  - (* Case EqFby: y = v0 fby lae *)
    specialize Hlae with n.
    assert (forall x c,
               Is_free_in_laexp x lae
               -> sem_var H x n (present c)
               -> (~ PS.In x mems -> PM.find x env' = Some c)
                  /\ (PS.In x mems -> find_mem x menv' = Some c))
      as Hlae' by resolve_env_assumption.
    destruct (ls n) eqn:Hls;
      destruct Hvar as [Hms Hvar].
    + (* y = absent *)
      exists menv', env'.
      inversion Hlae as [|? ? n0 Hlexp Hclk HR1 HR2];
        rewrite <-HR1 in *; clear HR1 HR2 n0.
      split; [|split].
      * apply stmt_eval_translate_eqns_cons.
        exists menv', env'.
        split; [exact Hstmt|].
        apply stmt_eval_Control_absent.
        apply clock_correct_false with (2:=Hclk); now auto.
      * intros x Hivi c.
        destruct (Is_variable_in_dec x eqs) as [Hvin|Hvin];
          [now apply IHeqs0 with (1:=Hvin)|].
        apply stmt_eval_translate_eqns_env_inv with (2:=Hvin) in Hstmt.
        rewrite Hstmt.
        inversion_clear Hivi as [? ? Hivi'|];
          [|unfold Is_variable_in in Hvin; contradiction].
        inversion_clear Hivi'.
      * constructor.
        2:assumption.
        constructor.
        intros ms0' Hmfind'.
        rewrite Hmfind in Hmfind'.
        injection Hmfind'; intro Heq; rewrite <-Heq in *; clear Heq Hmfind'.
        destruct (Is_memory_in_dec y eqs) as [Hxin|Hxin];
          [(* If we already updated x, we're good. *)
           now apply Is_memory_in_Memory_Corres_eqs with (1:=Hxin) (2:=IHeqs1)|].
        (* Otherwise our memory is untouched and we don't touch it either *)
        rewrite Hall in Hmc.
        apply Forall_app in Hmc.
        destruct Hmc as [H0 Hmc]; clear H0.
        apply Forall_cons2 in Hmc.
        destruct Hmc as [Hmc H0]; clear H0.
        inversion_clear Hmc as [| |? ? ? ? ? Hfindc].
        rewrite Hms.
        apply stmt_eval_translate_eqns_menv_inv with (2:=Hxin) in Hstmt.
        rewrite Hstmt.
        apply Hfindc with (1:=Hmfind).
    + (* y = present *)
      exists (add_mem y v menv'), env'.
      inversion Hlae as [? ? n' v' Hlexp Hclk HR1 HR2 HR3|];
        rewrite <-HR1 in *; clear HR1 HR2 HR3 n' v'.
      split; [|split].
      * apply stmt_eval_translate_eqns_cons.
        exists menv', env'.
        split; [exact Hstmt|].
        apply stmt_eval_Control_present.
        apply clock_correct_true with (2:=Hclk); now auto.
        econstructor.
        apply lexp_correct with (1:=Hlexp); now auto.
        reflexivity.
      * intros x Hivi c.
        inversion_clear Hivi as [? ? Hivi'|]; [now inversion_clear Hivi'|].
        apply IHeqs0.
        assumption.
      * rewrite <-Hms.
        apply Forall_cons.
        2:now apply Memory_Corres_eqs_add_mem with (1:=Hmfind) (2:=IHeqs1).
        constructor.
        intros ms' Hmfind'.
        rewrite Hmfind in Hmfind'.
        injection Hmfind'; intro Heq; rewrite <-Heq in *; clear Hmfind' Heq.
        now apply find_mem_gss.
Qed.

(* TODO: rework using (a simplified version of) msem_node_mult *)
Lemma is_node_correct:
  forall (G: global)
         (f: ident)
         (fnode: node)
         (xs: stream)
         (M: memory)
         (ys: stream)

         (prog': program)
         (fclass: class)
         (n: nat)
         (menv: memoryEnv)
         (env: constEnv),

    Welldef_global G
    -> find_node f G = Some fnode
    -> msem_node G f xs M ys
    -> Memory_Corres G n f M menv

    -> find_class f (translate G) = Some(fclass, prog')
    -> env = (match xs n with
	      | present c => PM.add fclass.(c_input) c empty
	      | absent => empty
             end)

    -> (exists menv' env',
           stmt_eval prog' menv env fclass.(c_step) (menv', env')
           /\ (forall c, ys n =present c
                         <-> PM.find (fclass.(c_output)) env' = Some c)
           /\ Memory_Corres G (S n) f M menv').
Proof.
  (* TODO: Develop a version of msem_node_mult that works for eqs? *)
  induction G as [|node G IH]; [now inversion 4|].
  intros f fnode xs M ys prog' fclass n menv env.
  intros Hwd Hfind Hmsem Hmc Hfcls Henv.
  assert (Ordered_nodes (node::G)) as Hord
      by apply Welldef_global_Ordered_nodes with (1:=Hwd).

  simpl in Hfind,Hfcls.
  destruct (ident_eqb (n_name node) f) eqn:Hfeq.

  Focus 2.
  { apply Welldef_global_cons in Hwd.
    assert (node.(n_name) <> f) as Hfneq
        by apply Pos.eqb_neq with (1:=Hfeq).
    rewrite Memory_Corres_node_tl with (1:=Hord) (2:=Hfneq) in Hmc.
    apply msem_node_cons with (1:=Hord) (3:=Hfneq) in Hmsem.
    apply IH with (1:=Hwd) (2:=Hfind) (3:=Hmsem) (4:=Hmc) (6:=Henv) (ys:=ys)
      in Hfcls.
    destruct Hfcls as [menv' [env' [Hstmt [Hout Hmc']]]].
    exists menv',env'.
    rewrite Memory_Corres_node_tl with (1:=Hord) (2:=Hfneq).
    intuition. }
  Unfocus.

  injection Hfcls; intros HR1 HR2; rewrite <-HR1,<-HR2 in *; clear HR1 HR2 Hfcls.
  injection Hfind; intro HR1; rewrite HR1 in *; clear HR1 Hfind.

  inversion_clear Hmsem as [? ? ? ? i o eqs Hfind Hsem].
  simpl in Hfind.
  rewrite Hfeq in Hfind; clear Hfeq.
  injection Hfind; intro HR1; rewrite HR1 in *; clear HR1 Hfind.
  simpl in *.

  destruct Hsem as [H [Hi [Ho [Hclk [Hsout Hsem]]]]].
  specialize Hi with n.
  specialize Ho with n.

  inversion_clear Hwd as [|? ? Hwd' neqs ni no Hwsch Hin2 Hout Hnode Hnd Hfind'].
  rename Hwd' into Hwd.
  simpl in *.
  unfold neqs, ni, no in *; clear neqs ni no.

  assert (
      exists menv' env',
        stmt_eval (translate G) menv env
                  (translate_eqns (memories eqs) eqs) (menv', env')
        /\ (forall x, Is_variable_in x eqs ->
                     forall c, sem_var H x n (present c)
                               <-> PM.find x env' = Some c)
        /\ Forall (Memory_Corres_eq G (S n) M menv') eqs) as His_step_correct.
  {
    eapply is_step_correct with (mems:=memories eqs) (env:=env) (menv:=menv)
                                (input:=i.(v_name)) (prog:=translate G).
    (* TODO: Tidy this up... *)
    - apply Forall_msem_equation_global_tl
      with (1:=Hord) (2:=Hnd) (3:=Hnode) (4:=Hsem).
    - intros; apply Is_memory_in_memories; assumption.
    - exists []; trivial.
    - exact Hwd.
    - reflexivity.
    - intro c.
      rewrite Henv.
      split; intro HH.
      apply (sem_var_det _ _ _ _ _ Hi) in HH; rewrite HH; apply PM.gss.
      destruct (xs n) as [|v Hxs];
        [ rewrite PM.gempty in HH; discriminate |].
      rewrite PM.gss in HH; injection HH; intro HR1;
      rewrite HR1 in *; exact Hi.
    - rewrite Henv.
      intros x Hivi.
      destruct (xs n); [rewrite PM.gempty;reflexivity|].
      rewrite PM.gso; [rewrite PM.gempty;reflexivity|].
      apply Is_variable_in_Is_defined_in in Hivi.
      intro Hx; rewrite Hx in *.
      contradiction.
    - rewrite Is_memory_in_memories.
      apply not_Is_defined_in_not_Is_memory_in in Hin2.
      exact Hin2.
    - exact Hin2.
    - exact Hwsch.
    - intro; apply Is_memory_in_memories.
    - apply (fun f fnode xs M ys prog' fclass menv env Hfind Hmsem
             => IH f fnode xs M ys prog' fclass n menv env Hwd Hfind Hmsem).
    - inversion_clear Hmc as [? ? ? ? ? ? Hf Hmeqs].
      simpl in Hf.
      rewrite ident_eqb_refl in Hf.
      injection Hf; intros Heq0 Heq1 Heq2;
      rewrite <-Heq0, <-Heq1, <-Heq2 in *;
      clear Heq0 Heq1 Heq2 Hf.
      apply Memory_Corres_eqs_node_tl with (1:=Hord) (2:=Hnode) (3:=Hmeqs).
  }
  clear IH.
  destruct His_step_correct as [menv' [env' [Hstmt [Hvar' Hmc']]]].
  exists menv',env'.
  split; [rewrite ps_from_list_gather_eqs_memories; exact Hstmt|].
  split.
  - intro c.
    apply Hvar' with (c:=c) in Hout.
    rewrite <- Hout.
    split; intro HH;
      [ rewrite HH in Ho; exact Ho
      | now apply sem_var_det with (1:=Ho) (2:=HH) ].
  - econstructor.
    + simpl; rewrite Pos.eqb_refl; reflexivity.
    + apply Memory_Corres_eqs_node_tl with (1:=Hord) (2:=Hnode) (3:=Hmc').
Qed.

Lemma stmt_eval_translate_reset_eqn_shift:
  forall prog eqs iacc menv env menv' env',
    stmt_eval prog menv env
              (List.fold_left translate_reset_eqn eqs iacc)
              (menv', env')
    <->
    exists menv'' env'',
      stmt_eval prog menv env
                (List.fold_left translate_reset_eqn eqs Skip)
                (menv'', env'')
      /\
      stmt_eval prog menv'' env'' iacc (menv', env').
Proof.
  Hint Constructors stmt_eval.
  induction eqs as [|eq eqs IH].
  - split; [ now eauto | ].
    intro H; do 2 destruct H.
    destruct H as [H0 H1].
    inversion_clear H0; apply H1.
  - intros.
    split.
    + intro H0.
      apply IH in H0.
      destruct H0 as [menv'' [env'' [H0 H1]]].
      destruct eq; [now eauto| |];
      inversion_clear H1;
      exists menv1; exists env1;
      split; try (simpl; apply IH); eauto.
    + intros.
      destruct eq; [ now (apply IH; auto) | |];
      (apply IH;
       simpl in H;
       destruct H as [menv'' [env'' [H0 H1]]];
       apply IH in H0;
       destruct H0 as [menv0 [env0 [H2 H3]]];
       exists menv0; exists env0;
       split; [now auto|];
       inversion_clear H3;
       inversion H0; subst;
       econstructor; eauto).
Qed.

Lemma stmt_eval_translate_reset_eqns_cons:
  forall prog menv env (eq:equation) eqs P,
    (exists menv'' env'',
        stmt_eval prog menv env
                  (translate_reset_eqns (eq :: eqs)) (menv'', env'')
        /\ P menv'' env'')
    <->
    (exists menv' env' menv'' env'',
        stmt_eval prog menv env (translate_reset_eqns eqs) (menv', env')
        /\ stmt_eval prog menv' env'
                     (translate_reset_eqn Skip eq) (menv'', env'')
        /\ P menv'' env'').
Proof.
  split.
  - intro H.
    destruct H as [menv'' [env'' H]].
    unfold translate_reset_eqns in H.
    simpl in H.
    destruct H as [H HP].
    apply stmt_eval_translate_reset_eqn_shift in H.
    destruct H as [menv' [env' [H1 H2]]].
    exists menv', env', menv'', env''.
    now intuition.
  - intro H.
    destruct H as [menv' [env' [menv'' [env'' [H1 [H2 HP]]]]]].
    unfold translate_reset_eqns.
    simpl.
    exists menv'', env''.
    intuition.
    apply stmt_eval_translate_reset_eqn_shift.
    exists menv', env'.
    intuition.
Qed.

(* TODO: rework using (a simplified version of) msem_node_mult *)
(* This lemma is stated with Welldef_global rather than simply Ordered_nodes
   since the former gives Is_well_sch for each set of node equations within
   the global environment. In turn, Is_well_sch guarantees that any EqApp
   equation is unique, i.e., given x = EqApp f e, there is no other instance
   of x. This greatly simplifies the induction where it must be shown from

   that

   The case of EqFby is simpler due to the lemma Memory_Corres_eqs_add_mem.
   The comment following this lemma explains why there can be no corresponding
   Memory_Corres_eqs_add_obj lemma. *)
Lemma is_node_reset_correct:
  forall (G: global)
         (f: ident)
         (xs: stream)
         (M: memory)
         (ys: stream)
         (fnode: node)

         (prog': program)
         (fclass: class)
         (menv: memoryEnv)
         (env: constEnv),

       Welldef_global G
    -> msem_node G f xs M ys
    -> find_node f G = Some fnode

    -> find_class f (translate G) = Some(fclass, prog')
    -> (exists menv' env',
           stmt_eval prog' menv env fclass.(c_reset) (menv', env')
           /\ Memory_Corres G 0 f M menv').
Proof.
  induction G as [|node G IH]; [now inversion 1|].
  intros until env.
  intros Hwdef Hmsem Hfindn Hfindc.

  assert (Hfindn':=Hfindn).
  pose proof (Welldef_global_Ordered_nodes _ Hwdef) as Hord.
  pose proof (find_node_not_Is_node_in _ _ _ Hord Hfindn) as Hnni.
  pose proof (find_node_translate_find_class _ _ _ Hfindn) as HH.
  destruct HH as [prog'' Hfindc'].
  rewrite Hfindc in Hfindc'.
  injection Hfindc';
    intros HR1 HR2; rewrite <-HR1,HR2 in *; clear HR1 HR2 Hfindc' prog''.
  simpl in Hfindc, Hfindn'.
  destruct (ident_eqb (n_name node) f) eqn:Heqb;
    [ apply Pos.eqb_eq in Heqb | apply Pos.eqb_neq in Heqb ].
  - injection Hfindn'; intro HR1; rewrite <-HR1 in *; clear HR1 Hfindn'.
    injection Hfindc; intros HR1; rewrite <-HR1 in *; clear HR1 Hfindc.
    destruct node as [f' i o eqs].
    simpl in Heqb.
    rewrite Heqb in *; clear Heqb.
    cut (exists menv' env',
            stmt_eval (translate G) menv env (translate_reset_eqns eqs)
                      (menv', env')
            /\ Forall (Memory_Corres_eq G 0 M menv') eqs).
    { destruct 1 as [menv' [env' [Hstmt Hmc]]].
      exists menv', env'.
      split; [exact Hstmt|].
      econstructor; [exact Hfindn|].
      apply Memory_Corres_eqs_node_tl with (1:=Hord) (2:=Hnni).
      exact Hmc. }
    simpl in *.
    inversion_clear Hmsem as [? ? ? ? i' o' eqs' Hfind HH].
    simpl in Hfind; rewrite ident_eqb_refl in Hfind.
    injection Hfind; intros HR1 HR2 HR3; rewrite <-HR1,<-HR2,<-HR3 in *;
    clear HR1 HR2 HR3 Hfind f' i' o' eqs'.
    destruct HH as [H [Hxs [Hys [Habs [Hout Hmsem]]]]].
    apply Forall_msem_equation_global_tl with (1:=Hord) (3:=Hnni) in Hmsem.
    2:(intros f' Hini'; apply find_node_Exists; inversion_clear Hord;
       apply H1 in Hini'; now intuition).
    clear Hxs Hys Habs Hout Hfindn Hord.
    assert (exists mems, Is_well_sch mems eqs) as Hwsch
        by (inversion_clear Hwdef; exists (PS.add ni (memories eqs0)); intuition).
    destruct Hwsch as [mems Hwsch].
    apply Welldef_global_cons in Hwdef.
    induction eqs as [|eq eqs IHeqs]; [exists menv, env; now intuition|].
    apply not_Is_node_in_cons in Hnni.
    destruct Hnni as [Hnni Hnnis].
    apply Forall_cons2 in Hmsem; destruct Hmsem as [Hmsem Hmsems].
    specialize (IHeqs Hnnis Hmsems (Is_well_sch_cons _ _ _ Hwsch)); clear Hnnis.
    destruct IHeqs as [menv' [env' [Hstmt Hmc]]].
    rewrite stmt_eval_translate_reset_eqns_cons.
    exists menv', env'.
    destruct eq as [|y g lae|y v0 lae].
    + (* EqDef *)
      exists menv', env'.
      split; [exact Hstmt|].
      repeat constructor.
      exact Hmc.
    + (* EqApp *)
      inversion_clear Hmsem as [|? ? ? ? Mo ? xs' ys' Hmfind Hxs' Hys' Hmsem'|].
      assert (Hmsem'':=Hmsem').
      inversion_clear Hmsem'' as [? ? ? ? ? ? ? Hfindn HH].
      pose proof (find_node_translate_find_class _ _ _ Hfindn) as Hfindc.
      destruct Hfindc as [prog'' Hfindc].
      specialize (IH _ _ _ _ _ _ _ mempty empty Hwdef Hmsem' Hfindn Hfindc).
      destruct IH as [omenv [oenv [Hstmtn Hmcn]]].
      exists (add_obj y omenv menv'), env'.
      split; [exact Hstmt|].
      split.
      * econstructor; [|now econstructor].
        econstructor; [|reflexivity].
        econstructor; [exact Hfindc|].
        exact Hstmtn.
      * inversion_clear Hwsch.
        repeat constructor;
          [|apply Memory_Corres_eqs_add_obj with (1:=Hmc); assumption].
        intros M' Hmfind'.
        rewrite Hmfind in Hmfind'.
        injection Hmfind'; intro HR; rewrite <-HR; clear HR Hmfind' M'.
        exists omenv.
        split; [now apply find_obj_gss|now intuition].
    + (* EqFby *)
      exists (add_mem y v0 menv'), env'.
      split; [exact Hstmt|].
      split.
      * econstructor; [|now econstructor].
        econstructor; [|reflexivity].
        now constructor.
      * inversion_clear Hmsem as [| |? ? ? ? ? ? ? Hmfind Hms Hlae Hls].
        rewrite <-Hms in *.
        repeat constructor;
          [| now apply Memory_Corres_eqs_add_mem with (1:=Hmfind) (2:=Hmc)].
        intros ms' Hmfind'.
        rewrite Hmfind in Hmfind'.
        injection Hmfind'; intro HR; rewrite HR in *; clear HR Hmfind'.
        rewrite find_mem_gss.
        reflexivity.
  - apply Welldef_global_cons in Hwdef.
    apply msem_node_cons with (1:=Hord) (3:=Heqb) in Hmsem.
    specialize (IH _ _ _ _ _ _ _ menv env Hwdef Hmsem Hfindn' Hfindc).
    destruct IH as [menv' [env' [Hstmt Hmc]]].
    exists menv', env'.
    split; [exact Hstmt|].
    now apply Memory_Corres_node_tl with (1:=Hord) (2:=Heqb) (3:=Hmc).
Qed.

Lemma is_translate_correct:
  forall (G: global)
         (f: ident)
         (xs: stream)
         (ys: stream)
         (ci: const)
         (r: ident)
         (obj: ident)
         (n: nat),
    Welldef_global G
    -> sem_node G f xs ys
    -> (forall n, xs n = present ci)
    -> (exists menv env,
           stmt_eval (translate G) mempty empty
             (Comp (Reset_ap f obj)
                   (Repeat (S n) (Step_ap r f obj (Const ci)))) (menv, env)
           /\ (forall co, ys n = present co <-> PM.find r env = Some co)).
Proof.
  (* TODO: Ugly, dumb proof. How to streamline / beautify all these
           inversions and rewrites. *)
  intros until n.
  intros Hwdef Hsem Hxs.
  apply sem_msem_node with (1:=Hwdef) in Hsem.
  destruct Hsem as [M Hmsem].
  assert(Hmsem':=Hmsem).
  inversion_clear Hmsem' as [? ? ? ? ? ? ? Hfindn Hmsem''].
  destruct Hmsem'' as [H [Hi [Ho [Hclk [Habs Hmsem']]]]].
  pose proof (find_node_translate_find_class _ _ _ Hfindn) as Hfindc.
  destruct Hfindc as [prog' Hfindc].
  pose proof (is_node_reset_correct _ _ _ _ _ _ _ _
                                    mempty empty Hwdef Hmsem Hfindn Hfindc) as Hreset.
  destruct Hreset as [menv' [env' [Hstmtr Hmc0]]].
  simpl in Hstmtr.
  cut (exists menv env,
          stmt_eval (translate G) mempty empty
                    (Comp (Reset_ap f obj) (Repeat (S n)
                                               (Step_ap r f obj (Const ci))))
                    (menv, env)
          /\ (forall co, ys n = present co <-> PM.find r env = Some co)
          /\ (exists omenv, find_obj obj menv = Some omenv
                            /\ Memory_Corres G (S n) f M omenv)).
  destruct 1 as [menv [env [Hstmt [Hout Hmc]]]]; exists menv, env; now intuition.
  induction n.
  - specialize Hxs with 0%nat.
    pose proof (is_node_correct _ _ _ _ _ _ _ _ _ _ (PM.add i.(v_name) ci empty)
                                Hwdef Hfindn Hmsem Hmc0 Hfindc) as Hstmt.
    rewrite Hxs in Hstmt; specialize (Hstmt (eq_refl _)); simpl in Hstmt.
    destruct Hstmt as [menv'' [env'' [Hstmt [Hout Hmc]]]].
    assert (ys 0%nat <> absent) as Hyna
        by (intro HH; apply Habs in HH; rewrite Hxs in HH; discriminate).
    apply not_absent_present in Hyna.
    destruct Hyna as [yc Hyna].
    exists (add_obj obj menv'' (add_obj obj menv' mempty)).
    exists (PM.add r yc empty).
    split; [|split].
    + (* TODO: automate! *)
      econstructor.
      econstructor; [|reflexivity].
      econstructor; [exact Hfindc|exact Hstmtr].
      econstructor.
      econstructor.
      econstructor.
      apply find_obj_gss.
      econstructor.
      econstructor.
      exact Hfindc.
      apply Hstmt.
      apply Hout.
      apply Hyna.
      reflexivity.
      reflexivity.
    + (* TODO: automate *)
      intuition.
      rewrite H0 in Hyna.
      injection Hyna; intro; subst.
      apply PM.gss.
      rewrite PM.gss in H0.
      injection H0; intro; subst.
      exact Hyna.
    + exists menv''.
      intuition.
      apply find_obj_gss.
  - destruct IHn as [menv'' [env'' [Hstmts [H0 Hmc]]]]; clear H0.
    destruct Hmc as [omenv [Hfindo Hmc]].
    inversion_clear Hstmts.
    specialize Hxs with (S n).
    pose proof (is_node_correct _ _ _ _ _ _ _ _ _ _ (PM.add i.(v_name) ci empty)
                                Hwdef Hfindn Hmsem Hmc Hfindc) as Hstmt.
    rewrite Hxs in Hstmt; specialize (Hstmt (eq_refl _)); simpl in Hstmt.
    destruct Hstmt as [menv''' [env''' [Hstmt [Hout Hmc']]]].
    assert (ys (S n) <> absent) as Hyna
        by (intro HH; apply Habs in HH; rewrite Hxs in HH; discriminate).
    apply not_absent_present in Hyna.
    destruct Hyna as [yc Hyna].
    exists (add_obj obj menv''' menv'').
    exists (PM.add r yc env'').
    split; [|split].
    + (* TODO: automate! *)
      econstructor.
      exact H0.
      econstructor.
      exact H1.
      econstructor.
      exact Hfindo.
      econstructor.
      econstructor.
      exact Hfindc.
      apply Hstmt.
      apply Hout.
      apply Hyna.
      reflexivity.
      reflexivity.
    + (* TODO: automate! *)
      intuition.
      rewrite H2 in Hyna.
      injection Hyna; intro; subst.
      apply PM.gss.
      rewrite PM.gss in H2.
      injection H2; intro; subst.
      exact Hyna.
    + exists menv'''.
      intuition.
      apply find_obj_gss.
Qed.

Lemma is_translate_even_more_correct:
  forall (G: global)
         (f: ident)
         (xs: stream)
         (ys: stream)
         (ci: const)
         (r: ident)
         (obj: ident)
         (n: nat)
         (menv: memoryEnv)
         (env: constEnv),
    Welldef_global G
    -> sem_node G f xs ys
    -> (forall n, xs n = present ci)
    -> stmt_eval (translate G) mempty empty
                 (Comp (Reset_ap f obj)
                       (Repeat (S n) (Step_ap r f obj (Const ci)))) (menv, env)
    -> (forall co, ys n = present co <-> PM.find r env = Some co).
Proof.
  intros G f xs ys ci r obj n menv env Hwdef Hsem Hin Hstmt.
  pose proof (is_translate_correct G f xs ys ci r obj n Hwdef Hsem Hin) as Hc.
  destruct Hc as [menv2 [env2 [Hstmt2 Hout]]].
  apply stmt_eval_det with (1:=Hstmt) in Hstmt2.
  injection Hstmt2; intros; subst.
  now apply Hout.
Qed.

