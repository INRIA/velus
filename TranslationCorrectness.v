Require Import Rustre.Common.
Require Import Rustre.DataflowSyntax.

(** ** Predicates *)

(* Working: Tim *)
(* Some comments: inversion H  ~>  inversion_clear H to avoid equalities
                  apply H1. apply H2.  ~>  apply H1, H2.
                  applying hypotheses from the context  ~> auto can do it
                  unfold machin in H2 rather than generalize H; unfold machin; intro H'
                    (even not necessary as Coq can perform apply or rewrite up to some unfolding)
*)

(* TODO: Big question: how do we get from the scheduling property on graphs
                       to this predicate?
         (Membership in memories or not, should follow from the definition
          of 'memories' above.) *)
Inductive sch_eqs (memories: PS.t) : PS.t -> PS.t -> list equation -> Prop :=
| SchEqDef:
    forall written notwritten x e eqs,
      ~ (PS.In x memories) ->
      (forall i, freevar_caexp e i ->
                 (PS.In i memories -> PS.In i notwritten)
                 /\ (~PS.In i memories -> PS.In i written)) ->
      sch_eqs memories (PS.add x written) (PS.remove x notwritten) eqs ->
      sch_eqs memories written notwritten (EqDef x e :: eqs)
| SchEqApp:
    forall written notwritten x f e eqs,
      ~ (PS.In x memories) ->
      (forall i, freevar_laexp e i ->
                 (PS.In i memories -> PS.In i notwritten)
                 /\ (~PS.In i memories -> PS.In i written)) ->
      sch_eqs memories (PS.add x written) (PS.remove x notwritten) eqs ->
      sch_eqs memories written notwritten (EqApp x f e :: eqs)
| SchEqFby:
    forall written notwritten x v0 e eqs,
      PS.In x memories ->
      (forall i, freevar_laexp e i ->
                 (PS.In i memories -> PS.In i notwritten)
                 /\ (~PS.In i memories -> PS.In i written)) ->
      sch_eqs memories (PS.add x written) (PS.remove x notwritten) eqs ->
      sch_eqs memories written notwritten (EqFby x v0 e :: eqs).

(* ** Definitions on imperative statements *)

Require Import Rustre.Minimp.
Require Import Rustre.Translation.
Require Import Rustre.DataflowNatSemantics.
Require Import Rustre.SynchronousNat.

(* TODO:
   - Assume we are given a list of dataflow equations eqs satisfying
        sch_eqs (memories eqs) PS.empty (defined eqs) eqs
   - Show that the step function generated by translate_eqs is correct,
     i.e., that its semantics correspond to the 'held semantics' of the
     original dataflow equations.
   - The 'held semantics' use holdR rather than fbyR for defining 'fby'.
   - Basic invariant for a single pass (to show by induction along the list
     of dataflow equations/sequence of conditional assignments):
        forall x,
             (PS.In x (PS.inter memories written) -> M x = H x (S n))
          /\ (PS.In x (PS.diff memories written) -> M x = H x n)
          /\ (PS.In x (PS.diff written memories) ->
              H x n = present c -> p x = c)

   - Afterward, this must be extended to run (i.e., forall n from 0).
   - and we must switch back to the standard fby semantics for instants
     where a clock is active.
 *)

Lemma pm_in_dec: forall A i m, PM.In (A:=A) i m \/ ~PM.In (A:=A) i m.
Proof.
  unfold PM.In.
  unfold PM.MapsTo.
  intros A i m.
  case (PM.find i m).
  eauto.
  right; intro; destruct H; discriminate H.
Qed.

Lemma ps_in_dec: forall i m, {PS.In i m}+{~PS.In i m}.
Proof.
  intros i m.
  unfold PS.In.
  case (PS.mem i m); auto.
Qed.

Lemma translate_lexp_correct:
  forall H memories n c menv env le,
    sem_lexp H le n (present c) ->
    (forall i c, PM.find i (H n) = Some (present c) ->
                 freevar_lexp le i ->
                 (PS.In i memories -> find_mem i menv = Some c)
                 /\ (~PS.In i memories -> PM.find i env = Some c)) ->
    exp_eval menv env (translate_lexp memories le) c.
Proof.
  intros H memories n c menv env.
  (* TODO: is there a better way to do this?:
    => Yes (marginally): use [induction ... using ...].
       but Coq cannot guess the second predicate
       so either you need to provide it (saving only half the space)
       or you can use [einduction] and fill it in later. *)
  induction le using lexp_mult
  with (P := fun lae =>
               sem_laexp H lae n c ->
               (forall i c0,
                   PM.find i (H n) = Some (present c0) ->
                   freevar_laexp lae i ->
                   (PS.In i memories -> find_mem i menv = Some c0) /\
                   (~ PS.In i memories -> PM.find i env = Some c0)) ->
               exp_eval menv env (translate_laexp memories lae) c).
(*
  einduction le using lexp_mult.
*)
(*
  apply (lexp_mult
           (fun lae : laexp =>
               sem_laexp H lae n c ->
               (forall (i : BinNums.positive) (c0 : const),
                   PM.find i (H n) = Some (present c0) ->
                   freevar_laexp lae i ->
                   (PS.In i memories -> find_mem i menv = Some c0) /\
                   (~ PS.In i memories -> PM.find i env = Some c0)) ->
               exp_eval menv env (translate_laexp memories lae) c)
           (fun le : lexp =>
              sem_lexp H le n c ->
              (forall (i : BinNums.positive) (c0 : const),
                  PM.find i (H n) = Some (present c0) ->
                  freevar_lexp le i ->
                  (PS.In i memories -> find_mem i menv = Some c0) /\
                  (~ PS.In i memories -> PM.find i env = Some c0)) ->
              exp_eval menv env (translate_lexp memories le) c)).
*)
  (* TODO: How to make this proof shorter? *)
  - intros H1 H2.
    apply IHle.
    now inversion_clear H1.
    intros.
    apply H2; trivial.
    now apply freeLAexp.
  - intros H0 ?.
    inversion_clear H0.
    apply econst.
  - intros.
    inversion_clear H0.
    inversion_clear H2.
    apply (fun h => H1 _ _ h (FreeEvar i)) in H0.
    destruct H0.
    destruct (ps_in_dec i memories) as [Hin | Hout].
    + unfold translate_lexp.
      rewrite Hin.
      apply estate; auto.
    + unfold translate_lexp.
      rewrite (Bool.not_true_is_false _ Hout).
      apply evar; auto.
  - intros.
    inversion_clear H0.
    apply (IHle H3).
    intros.
    apply (H1 _ _ H0 (FreeEwhen _ _ _ _ H4)).
Qed.

Lemma translate_laexp_correct:
  forall H memories lae n c menv env,
    sem_laexp H lae n (present c) ->
    (forall i c, PM.find i (H n) = Some (present c) ->
                 freevar_laexp lae i ->                 
                 (PS.In i memories -> find_mem i menv = Some c)
                 /\ (~PS.In i memories -> PM.find i env = Some c)) ->
    exp_eval menv env (translate_laexp memories lae) c.
Proof.
  intros H memories lae n c menv env H1 H2.
  case_eq lae.
  intros c0 l H3.
  change (exp_eval menv env (translate_lexp memories l) c).
  inversion H1.
  rewrite H3 in H5.
  injection H5.
  intros H8 H9.
  rewrite H8 in H0.
  generalize H0 H2.
  intros.
  apply (translate_lexp_correct _ _ _ _ _ _ _ H10).
  intros.
  apply (H11 _ _ H12).
  rewrite H3.
  apply (freeLAexp _ _ _ H13).
Qed.

Lemma translate_caexp_menv_unchanged:
  forall memories cae x menv env menv' env',
    stmt_eval menv env (translate_caexp memories x cae) (menv', env') ->
    menv = menv'.
Proof.
  intros memories cae.
  apply (caexp_mult
           (fun c : caexp =>
              forall (x : ident) (menv : memoryEnv) (env : valueEnv)
                     (menv' : memoryEnv) (env' : valueEnv),
                stmt_eval menv env (translate_caexp memories x c) (menv', env') ->
                menv = menv')
           (fun c : cexp =>
              forall (x : ident) (menv : memoryEnv) (env : valueEnv)
                     (menv' : memoryEnv) (env' : valueEnv),
                stmt_eval menv env (translate_cexp memories x c) (menv', env') ->
                menv = menv')).
  - intros.
    apply (H _ _ _ _ _ H0).
  - intros.
    change (stmt_eval menv env
                      (Ifte (tovar memories i)
                              (translate_caexp memories x c)
                              (translate_caexp memories x c0))
                      (menv', env')) in H1.
    inversion H1.
    apply (H _ _ _ _ _ H8).
    apply (H0 _ _ _ _ _ H8).
  - intros.
    inversion H.
    reflexivity.
Qed.

Lemma exp_eval_det:
  forall menv env e v1 v2,
    exp_eval menv env e v1 ->
    exp_eval menv env e v2 ->
    v1 = v2.
Proof.
  induction e;
    intros v1 v2 H1 H2;
    inversion H1 as [xa va Hv1|xa va Hv1|xa va Hv1];
    inversion H2 as [xb vb Hv2|xb vb Hv2|xb vb Hv2];
    rewrite Hv1 in Hv2;
    ( injection Hv2; trivial ) || apply Hv2.
Qed.
    
Lemma translate_cexp_correct:
  forall H memories ce n c menv env menv' env' x,
    sem_cexp H ce n (present c) ->
    (forall i c, PM.find i (H n) = Some (present c) ->
                 freevar_cexp ce i ->                 
                 (PS.In i memories -> find_mem i menv = Some c)
                 /\ (~PS.In i memories -> PM.find i env = Some c)) ->
    stmt_eval menv env (translate_cexp memories x ce) (menv', env') ->
    env' = PM.add x c env.
Proof.
  intros H memories ce.
  apply (cexp_mult
           (fun cae : caexp =>
              forall (n : nat) (c0 : const) (menv : memoryEnv) 
                     (env : PM.t const) (menv' : memoryEnv) (env' : valueEnv) 
                     (x : ident),
                sem_caexp H cae n c0 ->
                (forall (i : BinNums.positive) (c1 : const),
                    PM.find i (H n) = Some (present c1) ->
                    freevar_caexp cae i ->
                    (PS.In i memories -> find_mem i menv = Some c1) /\
                    (~ PS.In i memories -> PM.find i env = Some c1)) ->
                stmt_eval menv env (translate_caexp memories x cae) (menv', env') ->
                env' = PM.add x c0 env)           
           (fun ce : cexp =>
              forall (n : nat) (c0 : const) (menv : memoryEnv) 
                     (env : PM.t const) (menv' : memoryEnv) (env' : valueEnv) 
                     (x : ident),
                sem_cexp H ce n c0 ->
                (forall (i : BinNums.positive) (c1 : const),
                    PM.find i (H n) = Some (present c1) ->
                    freevar_cexp ce i ->
                    (PS.In i memories -> find_mem i menv = Some c1) /\
                    (~ PS.In i memories -> PM.find i env = Some c1)) ->
                stmt_eval menv env (translate_cexp memories x ce) (menv', env') ->
                env' = PM.add x c0 env)).
  - intros.
    inversion H1.
    apply (H0 _ _ menv _ menv' _ _ H6).
    intros.
    apply (H2 _ _ H10).
    apply (FreeCAexp _ _ _ H11).
    apply H3.
 - intros.
    change (stmt_eval menv env
                      (Ifte (tovar memories i)
                              (translate_caexp memories x c)
                              (translate_caexp memories x c0))
                      (menv', env')) in H4.
    unfold tovar in H4.
    destruct (ps_in_dec i memories) as [Hin | Hout].
   + assert (Hin' := Hin).
      unfold PS.In in Hin'.
      rewrite Hin' in H4.
      inversion H2.
      * inversion H4.
        { apply (fun x => H0 _ _ _ _ _ _ _ H11 x H18).
          intros.
          apply (H3 _ _ H19 (FreeEmerge_true _ _ _ _ H20)). }
        { inversion H10.
          destruct (H3 _ _ H19 (FreeEmerge_cond _ _ _)).
          apply H20 in Hin.
          inversion H14.
          rewrite H23 in Hin.
          discriminate Hin. }
      * inversion H4. (* Duplicate proof above with order inversed. *)
        { inversion H10.
          destruct (H3 _ _ H19 (FreeEmerge_cond _ _ _)).
          apply H20 in Hin.
          inversion H14.
          rewrite H23 in Hin.
          discriminate Hin. }
        { apply (fun x => H1 _ _ _ _ _ _ _ H11 x H18).
          intros.
          apply (H3 _ _ H19 (FreeEmerge_false _ _ _ _ H20)). }

   + assert (Hout' := Hout). (* TODO: m.m. of above *)
      unfold PS.In in Hout'.
      apply Bool.not_true_is_false in Hout'.
      rewrite Hout' in H4.
      inversion H2.
      * inversion H4.
        { apply (fun x => H0 _ _ _ _ _ _ _ H11 x H18).
          intros.
          apply (H3 _ _ H19 (FreeEmerge_true _ _ _ _ H20)). }
        { inversion H10.
          destruct (H3 _ _ H19 (FreeEmerge_cond _ _ _)).
          apply H21 in Hout.
          inversion H14.
          rewrite H23 in Hout.
          discriminate Hout. }
      * inversion H4. (* Duplicate proof above with order inversed. *)
        { inversion H10.
          destruct (H3 _ _ H19 (FreeEmerge_cond _ _ _)).
          apply H21 in Hout.
          inversion H14.
          rewrite H23 in Hout.
          discriminate Hout. }
        { apply (fun x => H1 _ _ _ _ _ _ _ H11 x H18).
          intros.
          apply (H3 _ _ H19 (FreeEmerge_false _ _ _ _ H20)). }
 - intros.
   inversion H0.
   apply (translate_lexp_correct _ memories _ _ menv env) in H4.
   + inversion H2.
     rewrite (eq_sym H9) in H10.
     pose proof (exp_eval_det _ _ _ _ _ H4 H10).
     rewrite H13.
     rewrite H12.
     reflexivity.
   + intros.
     apply H1.
     apply H7.
     apply (FreeEexp _ _ H8).
Qed.

Lemma translate_caexp_correct:
  forall H memories cae n c menv env menv' env' x,
    sem_caexp H cae n (present c) ->
    (forall i c, PM.find i (H n) = Some (present c) ->
                 freevar_caexp cae i ->                 
                 (PS.In i memories -> find_mem i menv = Some c)
                 /\ (~PS.In i memories -> PM.find i env = Some c)) ->
    stmt_eval menv env (translate_caexp memories x cae) (menv', env') ->
    env' = PM.add x c env.
Proof.
  induction cae.
  intros.
  inversion H0.
  change (stmt_eval menv env (translate_cexp memories x c0) (menv', env')) in H2.
  Check (translate_cexp_correct).
  apply (fun x => translate_cexp_correct _ _ _ _ _ _ _ _ _ _ H5 x H2).
  intros.
  apply (H1 _ _ H9).
  apply (FreeCAexp _ _ _ H10).
Qed.

Lemma step_correct:
  forall eqs : list equation,

    (* assumptions *)
    sch_eqs (memories eqs) PS.empty (defined eqs) eqs -> (* written = { input } *)

    (* invariant *)
      forall x,
             (PS.In x (PS.inter memories written) -> M x = H x (S n))
          /\ (PS.In x (PS.diff memories written) -> M x = H x n)
          /\ (PS.In x (PS.diff written memories) ->
              H x n = present c -> p x = c)

    (* meaning of data-flow equations *)

    (* TODO: replace this with the 'hold semantics' *)
    sem_equations G H eqs ->

    (* meaning of imperative code; linked by translation function *)
    s = runCompiler (translate_eqns eqs) ->
    run M R s.(st_instrs) n (R', M') ->

    s.(st_mem)
    s.(st_instrs)

    (* missing: assumptions on input:  n.(n_input).(v_name) *)


Lemma step_correct:
  forall eqs : list equation,

    (* assumptions *)
    sch_eqs (memories eqs) PS.empty (defined eqs) eqs ->

    PS.Subset (memories eqs) mems ->
    PS.Subset (defined eqs) defs ->

    (* invariant *)
      forall x,
             (PS.In x (PS.inter memories written) -> M x = H x (S n))
          /\ (PS.In x (PS.diff memories written) -> M x = H x n)
          /\ (PS.In x (PS.diff written memories) ->
              H x n = present c -> p x = c)  

    (* meaning of data-flow equations *)

               (* TODO: replace this with the 'hold semantics' *)
     sem_equations G H eqs ->


    (* meaning of imperative code; linked by translation function *)
               let s := runCompiler (translate_eqns eqs) in
               s.(st_mem)
                   s.(st_instrs)

             run M R s.(st_instrs) n (R', M')

    (* missing: assumptions on input:  n.(n_input).(v_name) *)

(* Working: *)
Inductive run :
  memoryEnv -> valueEnv -> stmt -> nat -> valueEnv * memoryEnv -> Prop :=
               





(* TODO: Do we really need these definitions? We should be able to extract
         the relevant information from the definitions above via the
         translation functions. *)
Fixpoint freevar_exp (fvs: PS.t) (e: exp) : PS.t :=
  match e with
  | Var x => PS.add x fvs
  | Const c => fvs
  end.
    
Fixpoint freevar_stmt (fvs: PS.t) (s: stmt) : PS.t :=
   match s with
   | Assign i e => freevar_exp fvs e
   | AssignSt i e => freevar_exp fvs e
   | Ifte i s1 s2 => freevar_stmt (freevar_stmt (PS.add i fvs) s1) s2
   | Step_ap i f e => freevar_exp fvs e
   | Comp s1 s2 => freevar_stmt (freevar_stmt fvs s1) s2
   | Skip => fvs
   end.



