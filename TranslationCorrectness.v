
Require Import Rustre.Common.
Require Import Rustre.DataflowSyntax.

(* ** Definitions on imperative statements *)

Require Import Rustre.Minimp.
Require Import PArith.
Require Import Rustre.Translation.
Require Import Rustre.DataflowNatSemantics.
Require Import Rustre.DataflowNatMSemantics.
Require Import Rustre.SynchronousNat.

Import List.ListNotations.
Open Scope list_scope.

(* TODO:
   - Assume we are given a list of dataflow equations eqs satisfying
        sch_eqs (memories eqs) PS.empty (defined eqs) eqs
   - Show that the step function generated by translate_eqs is correct,
     i.e., that its semantics correspond to the 'held semantics' of the
     original dataflow equations.
   - The 'held semantics' use holdR rather than fbyR for defining 'fby'.
   - Basic invariant for a single pass (to show by induction along the list
     of dataflow equations/sequence of conditional assignments):
        forall x,
             (PS.In x (PS.inter memories written) -> M x = H x (S n))
          /\ (PS.In x (PS.diff memories written) -> M x = H x n)
          /\ (PS.In x (PS.diff written memories) ->
              H x n = present c -> p x = c)

   - Afterward, this must be extended to run (i.e., forall n from 0).
   - and we must switch back to the standard fby semantics for instants
     where a clock is active.
 *)

(** ** Predicates *)

(**
   The list of equations should be in reverse order: the first
   equation to execute should be the last in the list.

   The set 'mems' should include any input variables. The relevant
   clause is written:
          (PS.In i mems -> ~Is_defined_in i eqs)

   rather than:
          (PS.In i mems -> ~Is_memory_in i eqs)

   To require that such input variables are not redefined in eqs.
*)
Inductive Is_well_sch (mems: PS.t) : list equation -> Prop :=
| WSchNil: Is_well_sch mems nil
| WSchEqDef:
    forall x e eqs,
      Is_well_sch mems eqs ->
      (forall i, Is_free_in_caexp i e ->
                    (PS.In i mems -> ~Is_defined_in i eqs)
                 /\ (~PS.In i mems -> Is_variable_in i eqs)) ->
      Is_well_sch mems (EqDef x e :: eqs)
| WSchEqApp:
    forall x f e eqs,
      Is_well_sch mems eqs ->
      (forall i, Is_free_in_laexp i e ->
                    (PS.In i mems -> ~Is_defined_in i eqs)
                 /\ (~PS.In i mems -> Is_variable_in i eqs)) ->
      Is_well_sch mems (EqApp x f e :: eqs)
| WSchEqFby:
    forall x v e eqs,
      Is_well_sch mems eqs ->
      PS.In x mems ->
      (forall i, Is_free_in_laexp i e ->
                    (PS.In i mems -> ~Is_defined_in i eqs)
                 /\ (~PS.In i mems -> Is_variable_in i eqs)) ->
      Is_well_sch mems (EqFby x v e :: eqs).

Section Well_sch.

  Variable mems : PS.t.

  (* TODO: rewrite using a strong specification?  *)

  Open Scope bool_scope.

  Definition check_var (memories: PS.t) (variables: PS.t) (x: ident) : bool :=
    if PS.mem x mems
    then negb (PS.mem x memories || PS.mem x variables)
    else PS.mem x variables.

  Lemma check_var_spec:
    forall memories variables x,
      check_var memories variables x = true
      <->
      (PS.In x mems -> ~PS.In x memories /\ ~PS.In x variables)
      /\ (~PS.In x mems -> PS.In x variables).
  Proof.
    (* TODO: how to automate all of this? *)
    intros memories variables x.
    unfold check_var.
    split.
    - intro Hif.
      split; intro Hin.
      + assert (PS.mem x mems = true) as Hin' by auto.
        rewrite Hin' in Hif.
        rewrite Bool.negb_orb in Hif.
        rewrite Bool.andb_true_iff in Hif.
        destruct Hif as [Hm Hv].
        rewrite Bool.negb_true_iff in Hm.
        rewrite Bool.negb_true_iff in Hv.
        apply mem_spec_false in Hm.
        apply mem_spec_false in Hv.
        auto.
      + assert (PS.mem x mems = false) as Hin' by now apply mem_spec_false.
        rewrite Hin' in Hif.
        now rewrite PS.mem_spec in Hif.
    - destruct 1 as [Hin Hnin].
      destruct In_dec with x mems as [H|H];
        [ assert (PS.mem x mems = true) as H' by auto; apply Hin in H
        | (assert (PS.mem x mems = false) as H' by now apply mem_spec_false);
           apply Hnin in H ]; rewrite H'.
      + destruct H as [Hm Hv].
        apply mem_spec_false in Hm.
        apply mem_spec_false in Hv.
        rewrite Hm, Hv.
        auto.
      + auto.
  Qed.

  Definition check_eq (eq: equation) (acc: bool*PS.t*PS.t) : bool*PS.t*PS.t :=
    match acc with
      | (true, memories, variables) =>
        match eq with
          | EqDef x e =>
            (PS.for_all (check_var memories variables) (free_in_caexp e PS.empty),
               memories, PS.add x variables)
          | EqApp x f e =>
            (PS.for_all (check_var memories variables) (free_in_laexp e PS.empty),
               memories, PS.add x variables)
          | EqFby x v e =>
            (PS.mem x mems && PS.for_all (check_var memories variables)
                                        (free_in_laexp e PS.empty),
             PS.add x memories, variables)
        end
      | (false, _, _) => (false, PS.empty, PS.empty)
    end.

  Definition well_sch (eqs: list equation) : bool :=
    fst (fst (List.fold_right check_eq (true, PS.empty, PS.empty) eqs)).

  Lemma not_for_all_spec:
    forall (s : PS.t) (f : BinNums.positive -> bool),
      SetoidList.compat_bool PS.E.eq f ->
      (PS.for_all f s = false <-> ~(PS.For_all (fun x : PS.elt => f x = true) s)).
  Proof.
    intros s f HSL.
    split.
    intros Hfa HFa.
    apply (PS.for_all_spec _ HSL) in HFa.
    rewrite Hfa in HFa.
    discriminate.
    intro HFa.
    apply Bool.not_true_iff_false.
    intro Hfa.
    apply HFa.
    apply (PS.for_all_spec _ HSL).
    assumption.
  Qed.

  Lemma check_var_compat:
    forall memories variables,
      SetoidList.compat_bool PS.E.eq (check_var memories variables).
  Proof.
    intros memories variables x y Heq.
    unfold PS.E.eq in Heq.
    rewrite Heq.
    reflexivity.
  Qed.

  Lemma well_sch_pre_spec:
    forall eqs good memories variables,
      (good, memories, variables)
          = List.fold_right check_eq (true, PS.empty, PS.empty) eqs
      ->
      (good = true -> (Is_well_sch mems eqs
                       /\ (forall x, PS.In x memories <-> Is_memory_in x eqs)
                       /\ (forall x, PS.In x variables <-> Is_variable_in x eqs)))
      /\ (good = false -> ~Is_well_sch mems eqs).
  Proof.
    Hint Constructors Is_well_sch.
    induction eqs as [|eq].
    - simpl; injection 1; intros HRv HRm HRg; subst.
      intuition;
        repeat match goal with
                 | H: PS.In _ PS.empty |- _ => apply PS.empty_spec in H;
                                               contradiction
                 | H: Is_memory_in _ nil |- _ => now inversion H
                 | H: Is_variable_in _ nil |- _ => now inversion H
               end.
    - intros good memories variables HH.
      simpl in HH.
      destruct (List.fold_right check_eq (true, PS.empty, PS.empty) eqs)
        as [[good' memories'] variables'].
      specialize IHeqs with good' memories' variables'.
      pose proof (IHeqs (eq_refl (good', memories', variables'))) as IH;
        clear IHeqs.
      destruct IH as [IHt IHf].
      split; intro Hg; rewrite Hg in *; clear Hg.
      + destruct eq; (* the horror... *)
        (simpl in HH;
         assert (good' = true) as IH
             by (apply Bool.not_false_iff_true;
                 intro Hgf; rewrite Hgf in HH;
                 discriminate);
         rewrite IH in HH;
         apply IHt in IH; clear IHt IHf;
         destruct IH as [Hwsch [Himi Hivi]];
         injection HH;
         intros HRv HRm Hcv;
         rewrite HRv in *; rewrite HRm in *; clear HRv HRm;
         symmetry in Hcv;
         try match goal with
               | H: PS.mem _ _ && _ = true |- _ =>
                 apply Bool.andb_true_iff in H;
                 destruct H as [H1 Hcv];
                 rewrite PS.mem_spec in H1
             end;
         split;
         [ constructor; auto; intros y Hy;
           apply free_in_caexp_spec' in Hy || apply free_in_laexp_spec' in Hy;
           rewrite PS.for_all_spec in Hcv;
           [ | apply check_var_compat];
           apply Hcv in Hy;
           apply check_var_spec in Hy | ];
         intros;
         repeat progress match goal with
          | |- ~Is_defined_in _ _ => apply Is_defined_in_not_mem_not_var
          | H:_ \/ _ |- _ => destruct H; subst
          | H:_ /\ _ |- _ => destruct H
          | |- _ <-> _ => split
          | |- _ /\ _ => split; intros
          | H1:PS.In ?y ?mems -> _, H2:PS.In ?y ?mems |- _ => apply H1 in H2
          | H1:~PS.In ?y ?mems -> _, H2:~PS.In ?y ?mems |- _ => apply H1 in H2
          | H:~PS.In ?x memories' |- ~Is_memory_in ?x _ => intro; apply H
          | H:~PS.In ?x variables' |- ~Is_variable_in _ _ => intro; apply H
          | |- Is_variable_in ?i (EqDef ?i _ :: _) => repeat constructor
          | |- Is_variable_in ?i (EqApp ?i _ _ :: _) => repeat constructor
          | |- Is_memory_in ?i (EqFby ?i _ _ :: _) => repeat constructor
          | H:PS.In _ variables' |- _ => apply Hivi in H
          | H:PS.In _ memories' |- _ => apply Himi in H
          | H:Is_variable_in ?x ?eqs
              |- Is_variable_in ?x (_ :: ?eqs) => constructor 2; apply H
          | H:Is_memory_in ?x ?eqs
              |- Is_memory_in ?x (_ :: ?eqs) => constructor 2; apply H
          | H:Is_variable_in_eq _ _ |- _ => inversion_clear H
          | H:Is_memory_in_eq _ _ |- _ => inversion_clear H
          | H:Is_variable_in _ (_ :: _) |- _ => apply Is_variable_in_cons in H
          | H:Is_memory_in _ (_ :: _) |- _ => apply Is_memory_in_cons in H
          | H:PS.In _ (PS.add _ _) |- _ => apply PS.add_spec in H
          | |- PS.In _ (PS.add _ _) => apply PS.add_spec
          | H:Is_variable_in _ eqs |- _ => apply Hivi in H; now intuition
          | H:Is_memory_in _ eqs |- _ => apply Himi in H; now intuition
          | H1:~PS.In ?x variables',
            H2:Is_variable_in ?x eqs |- _ => apply Hivi in H2; contradiction
          | H1:~PS.In ?x memories',
            H2:Is_memory_in ?x eqs |- _ => apply Himi in H2; contradiction
          | _ => intuition
         end).
      + destruct good'; [clear IHf| inversion 1; apply IHf; auto ].
        pose proof (IHt (eq_refl true)) as IH; clear IHt.
        destruct IH as [Hwsch [Himi Hivi]].
        destruct eq; simpl in HH;
        (injection HH;
         intros HRv HRm Hcv;
         rewrite HRv in *; rewrite HRm in *;
         clear HRv HRm;
         clear HH;
         symmetry in Hcv;
         match goal with
         | Hcv:PS.mem _ _ && _ = false |- _ =>
             apply Bool.andb_false_iff in Hcv;
             destruct Hcv as [Hcv|Hcv];
             [ inversion 1;
               apply mem_spec_false in Hcv;
               contradiction | ]
         | _ => idtac
         end;
         apply not_for_all_spec in Hcv; [|apply check_var_compat];
         intro Hwsch';
         apply Hcv;
         inversion_clear Hwsch' as [|? ? ? Hwsch0 HH
                                    |? ? ? ? Hwsch0 HH
                                    |? ? ? ? Hwsch0 Hi HH];
         intros x Hx;
         apply free_in_caexp_spec in Hx || apply free_in_laexp_spec in Hx;
         destruct Hx as [Hx|Hx]; [ | apply not_In_empty in Hx; contradiction ];
         intros;
         repeat progress
                match goal with
                | |- _ /\ _ => split; intros
                | H: _ /\ _ |- _ => destruct H
                | H: Is_free_in_caexp _ _ |- _ => apply HH in H
                | H: Is_free_in_laexp _ _ |- _ => apply HH in H
                | |- check_var memories' variables' x = true
                                               => apply check_var_spec
                | H1:~PS.In ?x ?mems -> Is_variable_in ?x ?eqs,
                  H2:~PS.In ?x ?mems |- PS.In ?x variables'
                    => apply H1 in H2; apply Hivi in H2; assumption
                | H1:PS.In ?x ?mems -> ~Is_defined_in ?x ?eqs,
                  H2:PS.In ?x ?mems |- _ => apply H1 in H2
                | H:~Is_defined_in ?x ?eqs |- ~PS.In ?x variables'
                    => apply not_Is_defined_in_not_Is_variable_in in H;
                       intro HN; apply Hivi in HN; contradiction
                | H:~Is_defined_in ?x ?eqs |- ~PS.In ?x memories'
                    => apply not_Is_defined_in_not_Is_memory_in in H;
                       intro HN; apply Himi in HN ; contradiction
                end).
  Qed.

  Lemma well_sch_spec:
    forall eqns,
      if well_sch eqns
      then Is_well_sch mems eqns
      else ~Is_well_sch mems eqns.
  Proof.
    intro eqns.
    pose proof (well_sch_pre_spec eqns).
    unfold well_sch.
    destruct (List.fold_right check_eq (true, PS.empty, PS.empty) eqns)
      as [[good memories] variables].
    simpl.
    specialize H with good memories variables.
    pose proof (H (eq_refl _)) as H'; clear H.
    destruct H' as [Ht Hf].
    destruct good;
    intuition.
  Qed.

End Well_sch.

Example eqn1_well_sch: Is_well_sch (PS.add 1 (memories eqns1)) eqns1.
Proof.
  assert (well_sch (PS.add 1 (memories eqns1)) eqns1 = true) as HW by apply eq_refl.
  pose proof (well_sch_spec (PS.add 1 (memories eqns1)) eqns1) as HS.
  rewrite HW in HS.
  assumption.
Qed.

Example eqn2_well_sch: Is_well_sch (PS.add 1 (memories eqns2)) eqns2.
Proof.
  assert (well_sch (PS.add 1 (memories eqns2)) eqns2 = true) as HW by apply eq_refl.
  pose proof (well_sch_spec (PS.add 1 (memories eqns2)) eqns2) as HS.
  rewrite HW in HS.
  assumption.
Qed.

Lemma Is_well_sch_cons:
  forall m eq eqs, Is_well_sch m (eq :: eqs) -> Is_well_sch m eqs.
Proof. inversion 1; auto. Qed.

Lemma Is_well_sch_free_variable:
  forall x eq eqs mems,
    Is_well_sch mems (eq :: eqs)
    -> Is_free_in_equation x eq
    -> ~ PS.In x mems
    -> Is_variable_in x eqs.
Proof.
  intros x eq eqs mems Hwsch Hfree Hnim.
  destruct eq;
    inversion_clear Hwsch as [|? ? ? ? Hp|? ? ? ? ? Hp|? ? ? ? ? ? Hp];
    inversion_clear Hfree as [? ? ? Hc|? ? ? ? Hc|? ? ? ? Hc];
    apply Hp in Hc;
    intuition.
Qed.

Lemma Is_well_sch_free_variable_in_mems:
  forall y eq eqs mems,
    Is_well_sch mems (eq :: eqs)
    -> Is_free_in_equation y eq
    -> PS.In y mems
    -> ~Is_defined_in y eqs.
Proof.
  intros x eq eqs mems Hwsch Hfree Hnim.
  destruct eq;
    inversion_clear Hwsch as [|? ? ? ? Hp|? ? ? ? ? Hp|? ? ? ? ? ? Hp];
    inversion_clear Hfree as [? ? ? Hc|? ? ? ? Hc|? ? ? ? Hc];
    apply Hp in Hc;
    destruct Hc as [Hc0 Hc1];
    apply Hc0 in Hnim;
    apply Hnim.
Qed.

Lemma Is_wsch_is_defined_in:
  forall x eq eqs mems,
    Is_well_sch mems (eq :: eqs) ->
    Is_defined_in x (eq :: eqs) ->
    Is_defined_in_eq x eq
    \/ (~Is_defined_in_eq x eq /\ Is_defined_in x eqs).
Proof.
  intros x eq eqs mems Hwsch Hdef.
  apply List.Exists_cons in Hdef.
  destruct (Is_defined_in_eq_dec x eq); intuition.
Qed.

Lemma Is_wsch_Is_memory_in_mems:
  forall mems x eqs,
    Is_well_sch mems eqs ->
    Is_memory_in x eqs ->
    PS.In x mems.
Proof.
  induction eqs as [|eq]; [inversion 2|].
  intros Hwsch Himi.
  apply Is_memory_in_cons in Himi.
  destruct Himi as [Himi|Himi].
  - destruct eq; inversion_clear Himi; auto.
    inversion_clear Hwsch; auto.
  - apply Is_well_sch_cons in Hwsch.
    destruct Himi as [? Himi].
    auto.
Qed.

Inductive Welldef_global : list node -> Prop :=
| WGnil:
    Welldef_global []
| WGcons:
    forall nd nds,
      Welldef_global nds ->
      let eqs := nd.(n_eqs) in
      let ni := nd.(n_input).(v_name) in
      let no := nd.(n_output).(v_name) in
      Is_well_sch (PS.add ni (memories eqs)) eqs
      -> ~Is_memory_in ni eqs
      -> Is_variable_in no eqs
      -> ~Is_node_in nd.(n_name) eqs
      -> (forall f, Is_node_in f eqs -> find_node f nds <> None)
      -> List.Forall (fun nd'=> nd.(n_name) <> nd'.(n_name)) nds
      -> Welldef_global (nd::nds).

Lemma Welldef_global_cons:
  forall node G,
    Welldef_global (node::G) -> Welldef_global G.
Proof.
  inversion 1; assumption.
Qed.

(* TODO: Write a function 'welldef_global' to decide this. *)

Lemma Welldef_global_Ordered_nodes:
  forall G, Welldef_global G -> Ordered_nodes G.
Proof.
  induction G as [|node G IH]; [constructor|].
  intro Hwdef.
  constructor.
  - apply IH; apply Welldef_global_cons with (1:=Hwdef).
  - intros f Hini.
    inversion Hwdef.
    split; [ intro; subst | ];
    repeat match goal with
           | eqs:=n_eqs node |- _ => unfold eqs in *; clear eqs
           | H1:~Is_node_in _ _, H2:Is_node_in _ _ |- False => contradiction
           | H1: Is_node_in _ _,
             H2: context[Is_node_in _ _ -> find_node _ _ <> None] |- _ =>
             apply H2 in H1; apply find_node_Exists in H1; exact H1
           end.
  - inversion Hwdef; assumption.
Qed.

Inductive Is_present_in (mems: PS.t) (menv: memoryEnv) (env: constEnv)
  : clock -> Prop :=
| IsCbase: Is_present_in mems menv env Cbase
| IsCon:
    forall ck c v,
      Is_present_in mems menv env ck
      -> exp_eval menv env (tovar mems c) (Cbool v)
      -> Is_present_in mems menv env (Con ck c v).

Lemma exp_eval_tovar_Cbool_dec:
  forall menv env mems c v,
    {exp_eval menv env (tovar mems c) (Cbool v)}
    + {~exp_eval menv env (tovar mems c) (Cbool v)}.
Proof.
  Ltac no_match := right; inversion_clear 1; try unfold find_mem in *;
                   match goal with
                   | H: PM.find _ _ = _ |- _ => rewrite H in *; discriminate
                   end.
  intros menv env mems c v.
  unfold tovar.
  destruct (PS.mem c mems).
  - case_eq (find_mem c menv).
    + intro c0; destruct c0.
      * no_match.
      * destruct b; destruct v; (left; apply estate; assumption) || no_match.
    + no_match.
  - case_eq (PM.find c env).
    + intro c0; destruct c0.
      * no_match.
      * destruct b; destruct v; (left; apply evar; assumption) || no_match.
    + no_match.
Qed.

Lemma Is_present_in_dec:
  forall mems menv env ck,
    {Is_present_in mems menv env ck}+{~Is_present_in mems menv env ck}.
Proof.
  intros.
  induction ck.
  - left; constructor.
  - destruct IHck.
    + destruct (exp_eval_tovar_Cbool_dec menv env mems i b); destruct b;
      (left; constructor; assumption) || right; inversion_clear 1; auto.
    + right; inversion_clear 1; auto.
Qed.

Lemma exp_eval_tovar:
  forall x v menv env memories,
    exp_eval menv env (tovar memories x) v
    <-> (exp_eval menv env (State x) v /\ PS.In x memories)
        \/ (exp_eval menv env (Var x) v /\ ~PS.In x memories).
Proof.
  split; intro Heval;
  destruct In_dec with x memories as [Hxm|Hxm];
    pose proof Hxm as Hxmt;
    apply PS.mem_spec in Hxmt || apply mem_spec_false in Hxmt;
    unfold tovar in *;
    rewrite Hxmt in *;
    intuition.
Qed.

Lemma stmt_eval_translate_eqns_cons:
  forall prog mems menv env menv' env' eq eqs,
    stmt_eval prog menv env (translate_eqns mems (eq :: eqs)) (menv', env')
    <->
    (exists menv'' env'',
        stmt_eval prog menv env (translate_eqns mems eqs) (menv'', env'')
        /\ stmt_eval prog menv'' env'' (translate_eqn mems eq) (menv', env')).
Proof. (* TODO: redo proof *)
  split.
  - intro H.
    unfold translate_eqns in H.
    simpl in H.
    apply stmt_eval_fold_left_shift in H.
    destruct H as [menv'' H].
    destruct H as [env'' H].
    exists menv''. exists env''.
    destruct H as [H1 H2].
    split. apply H1.
    inversion_clear H2.
    inversion H0.
    subst.
    exact H.
  - intro H.
    destruct H as [menv'' H].
    destruct H as [env'' H].
    destruct H as [H1 H2].
    unfold translate_eqns.
    simpl.
    apply stmt_eval_fold_left_shift.
    exists menv''. exists env''.
    split. apply H1.
    eapply Icomp. apply H2.
    apply Iskip.
Qed.


Lemma stmt_eval_Control:
  forall prog menv env mems c s menv' env',
    stmt_eval prog menv env (Control mems c s) (menv', env')
    -> (Is_present_in mems menv env c
        /\  stmt_eval prog menv env s (menv', env'))
       \/ (~Is_present_in mems menv env c /\ menv' = menv /\ env' = env).
Proof.
  Hint Constructors Is_present_in.
  intros prog menv env mems c s menv' env' Hs.
  induction c.
  - intuition.
  - destruct (Is_present_in_dec mems menv env (Con c i b)) as [Hp|Hnp];
    [ left | right ];
    destruct b; inversion_clear Hs;
    try match goal with
        | H:stmt_eval _ _ _ (Control _ _ _) _ |- _ => apply IHc in H;
            destruct H; destruct H
        | H:stmt_eval _ _ _ Skip _ |- _ => inversion H
        end;
    try match goal with
        | Hn: ~Is_present_in _ _ _ _, H: Is_present_in _ _ _ _ |- _ =>
          inversion_clear H; contradiction
        end;
    try (inversion_clear Hp;
         match goal with
         | H0: exp_eval _ _ _ (Cbool false),
           H1: exp_eval _ _ _ (Cbool true) |- _ =>
           discriminate (exp_eval_det _ _ _ _ _ H0 H1)
         end);
    try match goal with
        | Hm: menv = _, He: env = _ |- _ => rewrite Hm, He in *
        end;
    auto;
    contradict Hnp; auto.
Qed.

Lemma stmt_eval_translate_cexp_menv_inv:
  forall prog menv env mems x menv' env' ce,
    stmt_eval prog menv env (translate_cexp mems x ce) (menv', env')
    -> menv' = menv.
Proof.
  intros prog menv env mems x menv' env'.
  induction ce using cexp_mult
  with (P := (fun cae : caexp =>
           stmt_eval prog menv env (translate_caexp mems x cae) (menv', env') ->
           menv' = menv));
  (apply IHce || inversion_clear 1); auto.
Qed.

Lemma stmt_eval_translate_cexp_env_add:
  forall prog menv env mems x menv' env' ce,
    stmt_eval prog menv env (translate_cexp mems x ce) (menv', env')
    -> exists c, env' = PM.add x c env.
Proof.
  intros prog menv env mems x menv' env'.
  induction ce using cexp_mult
  with (P := (fun cae : caexp =>
          stmt_eval prog menv env (translate_caexp mems x cae) (menv', env') ->
          exists c, env' = PM.add x c env));
    (apply IHce || inversion_clear 1); auto.
  exists v; rewrite <- H1; intuition.
Qed.

Lemma not_Is_memory_in_eq:
  forall prog x eq menv env mems menv' env',
    ~Is_memory_in_eq x eq
    -> stmt_eval prog menv env (translate_eqn mems eq) (menv', env')
    -> find_mem x menv' = find_mem x menv.
Proof. (* TODO: Tidy proof *)
  intros prog x eq menv env mems menv' env' Hneq Heval.
  destruct eq as [y cae|y f lae|y v0 lae].
  - destruct cae.
    simpl in Heval.
    apply stmt_eval_Control in Heval; destruct Heval as [Heval|Heval];
    destruct Heval as [Heval1 Heval2].
    apply stmt_eval_translate_cexp_menv_inv in Heval2.
    rewrite Heval2. intuition.
    destruct Heval2 as [Hmenv]; rewrite Hmenv; intuition.
  - destruct lae.
    simpl in Heval.
    apply stmt_eval_Control in Heval; destruct Heval as [Heval|Heval];
    destruct Heval as [Hipi Heval].
    inversion_clear Heval.
    rewrite <- H2.
    reflexivity.
    destruct Heval as [Hmenv Henv]; rewrite Hmenv; intuition.
  - apply not_Is_memory_in_eq_EqFby in Hneq.
    unfold translate_eqn in Heval.
    destruct lae.
    apply stmt_eval_Control in Heval; destruct Heval as [Heval|Heval];
    destruct Heval as [Hipi Heval].
    inversion_clear Heval.
    rewrite <- H0.
    unfold find_mem, add_mem.
    simpl; rewrite PM.gso; [intuition | apply Hneq].
    destruct Heval as [Hmenv Henv]; rewrite Hmenv; intuition.
Qed.

Lemma not_Is_variable_in_eq:
  forall prog x eq menv env mems menv' env',
    ~Is_variable_in_eq x eq
    -> stmt_eval prog menv env (translate_eqn mems eq) (menv', env')
    -> PM.find x env' = PM.find x env.
Proof.
  intros prog x eq menv env mems menv' env' Hnd Heval.
  destruct eq as [y e|y f e|y v0 e];
  try apply not_Is_variable_in_eq_EqDef in Hnd.
  - (unfold translate_eqn in Heval;
     destruct e;
     apply stmt_eval_Control in Heval; destruct Heval as [Heval|Heval];
     destruct Heval as [Hipi Heval]; [
       apply stmt_eval_translate_cexp_env_add in Heval;
       destruct Heval; rewrite H;
       rewrite PM.gso; [intuition | apply Hnd]
     | destruct Heval as [Hmenv Henv]; rewrite Henv; intuition]).
  - simpl in Heval; destruct e.
    apply stmt_eval_Control in Heval; destruct Heval as [Heval|Heval];
    destruct Heval as [Heval1 Heval2].
    inversion_clear Heval2.
    rewrite <- H3.
    rewrite PM.gso; [reflexivity|].
    intro Hxy; apply Hnd; rewrite Hxy; constructor.
    destruct Heval2 as [Hmenv Henv]; rewrite Henv; intuition.
  - simpl in Heval; destruct e.
    apply stmt_eval_Control in Heval; destruct Heval as [Heval|Heval];
    destruct Heval as [Heval1 Heval2].
    inversion Heval2; intuition.
    destruct Heval2 as [Hmenv Henv]; rewrite Henv; intuition.
Qed.

Lemma stmt_eval_translate_eqns_menv_inv:
  forall prog menv env mems eqs menv' env',
    stmt_eval prog menv env (translate_eqns mems eqs) (menv', env')
    -> (forall x, ~Is_memory_in x eqs ->
                  find_mem x menv' = find_mem x menv).
Proof.
  induction eqs as [ |eq].
  + inversion_clear 1; reflexivity.
  + intros menv' env' Heval x Hnmem.
    apply not_Is_memory_in_cons in Hnmem.
    destruct Hnmem as [H0 H1].
    apply stmt_eval_translate_eqns_cons in Heval.
    destruct Heval as [menv'' Heval];
      destruct Heval as [env'' Heval];
      destruct Heval as [Heval0 Heval1].
    apply IHeqs with (x:=x) (2:=H1) in Heval0.
    apply not_Is_memory_in_eq with (1:=H0) in Heval1.
    rewrite Heval1, Heval0.
    reflexivity.
Qed.

Lemma stmt_eval_translate_eqns_env_inv:
  forall prog menv env mems eqs menv' env',
    stmt_eval prog menv env (translate_eqns mems eqs) (menv', env')
    -> (forall x, ~Is_variable_in x eqs ->
                  PM.find x env' = PM.find x env).
Proof.
  induction eqs as [ |eq].
  + inversion_clear 1; reflexivity.
  + intros menv' env' Heval x Hndef.
    apply not_Is_variable_in_cons in Hndef.
    destruct Hndef as [H0 H1].
    apply stmt_eval_translate_eqns_cons in Heval.
    destruct Heval as [menv'' Heval];
      destruct Heval as [env'' Heval];
      destruct Heval as [Heval0 Heval1].
    apply IHeqs with (x:=x) (2:=H1) in Heval0.
    apply not_Is_variable_in_eq with (1:=H0) in Heval1.
    rewrite Heval1, Heval0.
    reflexivity.
Qed.

Local Ltac split_env_assumption :=
  match goal with
  | Henv: context Is_free_in_lexp [_], Hsem: sem_var _ ?y _ _
    |- _ => apply Henv in Hsem; [destruct Hsem |solve [auto]]; clear Henv
  | Henv: context Is_free_in_clock [_], Hsem: sem_var _ ?y _ _
    |- _ => apply Henv in Hsem; [destruct Hsem |solve [auto]]; clear Henv
  end.

(* Note that the converse:
       Is_present_in memories menv env ck -> sem_clock H ck n true
   cannot be shown, since the present/absent status of memories is lost
   in menv/env. In other words, all elements of menv are always present,
   so Is_present_in may be true when the corresponding clock is not
   true under H (since it's elements may not be present on the "dataflow
   side"). *)
Lemma clock_correct_true:
  forall H n memories menv env ck,
    (forall x c, Is_free_in_clock x ck
                 -> sem_var H x n (present c)
                 -> (~PS.In x memories -> PM.find x env = Some c)
                    /\ (PS.In x memories -> find_mem x menv = Some c))
    -> sem_clock H ck n true
    -> Is_present_in memories menv env ck.
Proof.
  Hint Constructors Is_present_in.
  Hint Constructors sem_clock.
  Hint Constructors Is_free_in_clock.
  Hint Constructors exp_eval.
  intros H n memories menv env.
  induction ck as [|? ? x]; [ intuition | ].
  intro Henv.
  inversion_clear 1.
  constructor. apply IHck; auto.
  intros.
  split_env_assumption.
  apply exp_eval_tovar;
    destruct In_dec with x memories;
    intuition.
Qed.

Lemma clock_correct_false:
  forall H n memories menv env ck,
    (forall x c, Is_free_in_clock x ck
                 -> sem_var H x n (present c)
                 -> (~PS.In x memories -> PM.find x env = Some c)
                    /\ (PS.In x memories -> find_mem x menv = Some c))
    -> sem_clock H ck n false
    -> ~Is_present_in memories menv env ck.
Proof.
  Hint Constructors Is_present_in.
  Hint Constructors sem_clock.
  Hint Constructors Is_free_in_clock.
  intros H n memories menv env.
  induction ck as [|? ? x]; [inversion 2|].
  intro Henv.
  inversion_clear 1 as [| |? ? ? ? Hclk'|? ? ? ? ? Hclk' Hvar].
  apply IHck in Hclk'; auto.
  inversion_clear 1; contradiction.
  inversion_clear 1 as [|? ? ? Hipi Heval].
  split_env_assumption.
  repeat progress
         match goal with
         | H:_ \/ _ |- _ => destruct H
         | H:_ /\ _ |- _ => destruct H
         | H:exp_eval _ _ (tovar _ _ ) _ |- _ => apply exp_eval_tovar in H
         | H:exp_eval _ _ (State _) _ |- _ => inversion_clear H
         | H:exp_eval _ _ (Var _) _ |- _ => inversion_clear H
         | H: find_mem _ _ = Some _ |- _ => rewrite H in *
         | H: PM.find _ _ = Some _ |- _ => rewrite H in *
         | Hin: PS.In _ _, Hmenv: PS.In _ _ -> _ |- _ => apply Hmenv in Hin
         | Hin: ~PS.In _ _, Henv: ~PS.In _ _ -> _ |- _ => apply Henv in Hin
         | H: Some _ = Some _ |- _ => solve [ injection H; auto ]
         end.
Qed.

Lemma lexp_correct:
  forall H memories menv env n c e,
    sem_lexp H e n (present c)
    -> (forall x c, Is_free_in_lexp x e
                    -> sem_var H x n (present c)
                    -> (~PS.In x memories -> PM.find x env = Some c)
                       /\ (PS.In x memories -> find_mem x menv = Some c))
    -> exp_eval menv env (translate_lexp memories e) c.
Proof.
  Hint Constructors exp_eval.
  intros H memories menv env n c.
  induction e as [c0 e IH|c0|y|e IH y yb] using lexp_mult
  with (P:=fun e =>
          sem_laexp H e n (present c)
          -> (forall x c, Is_free_in_laexp x e
                          -> sem_var H x n (present c)
                          -> (~PS.In x memories -> PM.find x env = Some c)
                             /\ (PS.In x memories -> find_mem x menv = Some c))
          -> exp_eval menv env (translate_laexp memories e) c);
    inversion 1; intros;
    try apply IH; try apply econst; auto.
  split_env_assumption;
    unfold translate_lexp;
    destruct (PS.mem y memories) eqn:Hm;
    rewrite PS.mem_spec in Hm || rewrite mem_spec_false in Hm;
    auto.
Qed.

Lemma laexp_correct:
  forall H memories menv env n c e,
    sem_laexp H e n (present c)
    -> (forall x c, Is_free_in_laexp x e
                    -> sem_var H x n (present c)
                    -> (~PS.In x memories -> PM.find x env = Some c)
                       /\ (PS.In x memories -> find_mem x menv = Some c))
    -> exp_eval menv env (translate_laexp memories e) c.
Proof.
  intros H memories menv env n c e Hsem Henv.
  destruct e as [ck ce].
  inversion_clear Hsem as [? ? ? ? Hlexp ?|].
  change (exp_eval menv env (translate_lexp memories ce) c).
  apply (lexp_correct _ _ _ _ _ _ _ Hlexp); auto.
Qed.

(* TODO: Tidy this proof *)
Lemma cexp_correct:
  forall H memories prog menv env menv' env' n c x e,
    sem_cexp H e n (present c)
    -> (forall x c, Is_free_in_cexp x e
                    -> sem_var H x n (present c)
                    -> (~PS.In x memories -> PM.find x env = Some c)
                       /\ (PS.In x memories -> find_mem x menv = Some c))
    -> stmt_eval prog menv env (translate_cexp memories x e) (menv', env')
    -> env' = PM.add x c env.
Proof.
  intros H memories prog menv env menv' env' n c x.
  induction e as [ck e IH|b et IHt ef IHf|e] using cexp_mult
  with (P:=fun e =>
             sem_caexp H e n (present c)
             -> (forall x c,
                    Is_free_in_caexp x e
                    -> sem_var H x n (present c)
                    -> (~PS.In x memories -> PM.find x env = Some c)
                       /\ (PS.In x memories -> find_mem x menv = Some c))
             -> stmt_eval prog menv env (translate_caexp memories x e)
                          (menv', env')
             -> env' = PM.add x c env).
  - (* CAexp *) inversion 1; auto.
  - (* Emerge *)
    inversion_clear 1; inversion_clear 2;
    solve [
        apply IHt; auto
      | apply IHf; auto
      | split_env_assumption;
        repeat progress
               match goal with
               | H:_ \/ _ |- _ => destruct H
               | H:_ /\ _ |- _ => destruct H
               | H:exp_eval _ _ (tovar _ _ ) _ |- _ => apply exp_eval_tovar in H
               | H:exp_eval _ _ (State _) _ |- _ => inversion_clear H
               | H:exp_eval _ _ (Var _) _ |- _ => inversion_clear H
               | H: find_mem _ _ = Some _ |- _ => rewrite H in *
               | H: PM.find _ _ = Some _ |- _ => rewrite H in *
               | Hin: PS.In _ _, Hmenv: PS.In _ _ -> _ |- _ => apply Hmenv in Hin
               | Hin: ~PS.In _ _, Henv: ~PS.In _ _ -> _ |- _ => apply Henv in Hin
               | H: Some _ = Some _ |- _ => repeat injection H;
                                            discriminate || auto
               end
      ].
  - (* Eexp *)
    inversion 1; inversion 2; subst;
    repeat progress match goal with
    | H:sem_lexp _ _ _ _ |- _ => eapply lexp_correct in H; [|now auto]
    | H1:exp_eval _ _ _ _, H2:exp_eval _ _ _ _ |- _ =>
                                 eapply (exp_eval_det _ _ _ _ _ H1) in H2; subst
    | _ => reflexivity
    end.
Qed.

Lemma caexp_correct:
  forall H memories prog menv env menv' env' n c x e,
    sem_caexp H e n (present c)
    -> (forall x c, Is_free_in_caexp x e
                    -> sem_var H x n (present c)
                    -> (~PS.In x memories -> PM.find x env = Some c)
                       /\ (PS.In x memories -> find_mem x menv = Some c))
    -> stmt_eval prog menv env (translate_caexp memories x e) (menv', env')
    -> env' = PM.add x c env.
Proof.
  intros H memories prog menv env menv' env' n c x e Hsem Henv Hstmt.
  destruct e as [ck ce].
  inversion_clear Hsem as [? ? ? ? Hlexp ?|].
  change (stmt_eval prog menv env (translate_cexp memories x ce) (menv', env'))
    in Hstmt.
  apply cexp_correct with (1:=Hlexp) (3:=Hstmt); auto.
Qed.

(* TODO: Tim: working from here... *)

(*
Local Ltac resolve_env_assumption :=
  intro x; intros; split; intros;
  match goal with
  | Hws: Is_well_sch (PS.add ?input _) _ |- _ =>
    destruct (ident_eq_dec x input);
      repeat progress
             match goal with
             | H:   ~PS.In x _,
               Hin: x=input,
               Hws: Is_well_sch _ (_ :: _) |- _ =>
                 subst;
                 apply Is_well_sch_free_variable_in_mems with input _ _ _ in Hws;
                 [ apply not_Is_defined_in_not_Is_variable_in in Hws
                 | auto | apply PS.add_spec; auto ]

             | H:   ~PS.In x _,
               Hin: x<>input,
               Hws: Is_well_sch _ (_ :: _) |- _ =>
                 apply Is_well_sch_free_variable with x _ _ _ in Hws;
                 [ | auto | intro HH; apply PS.add_spec in HH; intuition ]

             | H:   PS.In x _,
               Hws: Is_well_sch _ (_ :: _),
               Hm:  forall x : ident, ~Is_memory_in _ _ -> _ |- _ =>
                 apply Is_well_sch_free_variable_in_mems with x _ _ _ in Hws;
                 [ apply not_Is_defined_in_not_Is_memory_in in Hws;
                   apply Hm in Hws; rewrite Hws | | apply PS.add_spec ]; auto

             | H0:~Is_variable_in _ _,
               H1: stmt_eval _ _ _ _ _ |- _ =>
                 apply (stmt_eval_translate_eqns_env_inv _ _ _ _ _ _ _ H1) in H0;
                 rewrite H0

             | H:forall c:const, sem_var _ _ _ _ <-> PM.find ?x ?env = _
                                 |- PM.find ?x ?env = _ => now (apply H)

             | Hv: forall x' : ident,
                 Is_variable_in x' ?eqs ->
                                forall c' : const,
                                  sem_var ?H x' ?n (present c')
                                  <-> PM.find x' ?env = Some c',
               Hs: sem_var ?H ?x ?n (present ?c)
               |-  PM.find ?x ?env = Some ?c => apply Hv; [now auto|apply Hs]

             | Hin: PS.In ?x ?mems,
               Hm: forall x,
                   PS.In x ?mems ->
                         forall c : const,
                           sem_var ?H' x ?n (present c)
                           <-> find_mem x ?menv = Some c
               |- find_mem ?x ?menv = Some ?c => apply Hm with (1:=Hin)

             | Hs: sem_equations ?G ?H ?eqs,
               Hh: sem_held_equations ?H ?H' ?eqs,
               Hv: sem_var ?H ?x ?n ?v,
               Hd: forall x' : ident, PS.In x' ?mems -> Is_memory_in x' ?eqs,
               Hm: PS.In ?x ?mems
               |- sem_var ?H' ?x ?n ?v =>
                    apply Hd in Hm;
                    apply Is_memory_in_defined_in in Hm;
                    now apply sem_held_equations_corres
                          with (1:=Hs) (2:=Hh) (3:=Hm) (4:=Hv)

             | H:x=input |- _ => now (subst; contradiction)
             end
  end.
*)

(* Notes:
   1. The assumption sem_equations must be shown for a set of equations.
      TODO: lemma showing that a well-typed and well-clocked set of
            equations has a semantics.

   2. The assumption stmt_eval (translate_eqns mems eqs) implies that an
      execution exists and thus that exp_eval's evar and estate find some
      value for each required variable.
      This is somehow backwards; it should be an obligation to show that
      an execution exists. This is something assured indirectly in the
      lemma below where we require not just that evar and estate find
      some value, but also that it is the correct value.
 *)

Inductive Memory_Corres (G: global) (n: nat) :
       ident -> memory -> memoryEnv -> Prop :=
| MemC:
    forall f M menv i o eqs,
      find_node f G = Some(mk_node f i o eqs)
      -> Memory_Corres_eqs G n M menv eqs
      -> Memory_Corres G n f M menv

with Memory_Corres_eqs (G: global) (n: nat) :
       memory -> memoryEnv -> list equation -> Prop :=
| MemC_nil: forall m menv,
    Memory_Corres_eqs G n m menv []
| MemC_EqDef:
    forall M menv x cae eqs,
      Memory_Corres_eqs G n M menv eqs
      -> Memory_Corres_eqs G n M menv (EqDef x cae::eqs)
| MemC_EqApp:
    forall M menv x f lae eqs,
      (forall Mo omenv, mfind_inst x M = Some Mo
                        -> find_obj x menv = Some omenv
                        -> Memory_Corres G n f Mo omenv)
      -> Memory_Corres_eqs G n M menv eqs
      -> Memory_Corres_eqs G n M menv (EqApp x f lae::eqs)
| MemC_EqFby:
    forall M menv x v0 lae eqs,
      (forall ms, mfind_mem x M = Some ms
                  <-> find_mem x menv = Some (ms n))
      -> Memory_Corres_eqs G n M menv eqs
      -> Memory_Corres_eqs G n M menv (EqFby x v0 lae::eqs).

Scheme Memory_Corres_mult := Induction for Memory_Corres Sort Prop
with Memory_Corres_eqs_mult := Induction for Memory_Corres_eqs Sort Prop.

Lemma not_Is_node_in_cons:
  forall n eq eqs,
    ~ Is_node_in n (eq::eqs) <-> ~Is_node_in_eq n eq /\ ~Is_node_in n eqs.
Proof.
  intros n eq eqs.
  split; intro HH.
  - split; intro; apply HH; unfold Is_node_in; intuition.
  - destruct HH; inversion_clear 1; intuition.
Qed.

Lemma find_node_tl:
  forall f node G,
    node.(n_name) <> f
    -> find_node f (node::G) = find_node f G.
Proof.
  intros f node G Hnf.
  unfold find_node.
  unfold List.find at 1.
  apply Pos.eqb_neq in Hnf.
  unfold ident_eqb.
  rewrite Hnf.
  reflexivity.
Qed.

Lemma find_node_split:
  forall f G node,
    find_node f G = Some node
    -> exists bG aG,
      G = bG ++ node :: aG.
Proof.
  induction G as [|nd G IH]; [unfold find_node, List.find; discriminate|].
  intro nd'.
  intro Hfind.
  unfold find_node in Hfind; simpl in Hfind.
  destruct (ident_eqb (n_name nd) f) eqn:Heq.
  - injection Hfind; intro He; rewrite <-He in *; clear Hfind He.
    exists []; exists G; reflexivity.
  - apply IH in Hfind.
    destruct Hfind as [bG [aG Hfind]].
    exists (nd::bG); exists aG; rewrite Hfind; reflexivity.
Qed.

Lemma Ordered_nodes_append:
  forall G G',
    Ordered_nodes (G ++ G')
    -> Ordered_nodes G'.
Proof.
  induction G as [|nd G IH]; [intuition|].
  intros G' HnGG.
  apply IH; inversion_clear HnGG; assumption.
Qed.

Lemma Ordered_nodes_cons_find_node_None:
  forall node G,
    Ordered_nodes (node::G)
    -> find_node node.(n_name) G = None.
Proof.
  intros node G Hord.
  inversion_clear Hord as [|? ? Hord' H0 Hfa]; clear H0.
  induction G as [|eq G IH]; [trivial|].
  simpl.
  destruct (ident_eqb eq.(n_name) node.(n_name)) eqn:Heq;
    apply Forall_cons2 in Hfa;
    destruct Hfa as [Hneq H0].
  - apply Peqb_true_eq in Heq.
    rewrite Heq in Hneq.
    exfalso; apply Hneq; reflexivity.
  - apply IH; inversion_clear Hord'; assumption.
Qed.

Lemma find_node_later_names_not_eq:
  forall f nd G nd',
    Ordered_nodes (nd::G)
    -> find_node f (G) = Some nd'
    -> f <> nd.(n_name).
Proof.
  intros f nd G nd' Hord Hfind.
  pose proof (Ordered_nodes_cons_find_node_None _ _ Hord) as Hnone.
  intro Heq.
  rewrite Heq, Hnone in Hfind.
  discriminate.
Qed.

Lemma find_node_later_not_Is_node_in:
  forall f nd G nd',
    Ordered_nodes (nd::G)
    -> find_node f (G) = Some nd'
    -> ~Is_node_in nd.(n_name) nd'.(n_eqs).
Proof.
  intros f nd G nd' Hord Hfind Hini.
  apply find_node_split in Hfind.
  destruct Hfind as [bG [aG HG]].
  rewrite HG in Hord.
  inversion_clear Hord as [|? ? Hord' H0 Hnin]; clear H0.
  apply Ordered_nodes_append in Hord'.
  inversion_clear Hord' as [| ? ? Hord Heqs Hnin'].
  apply Heqs in Hini.
  destruct Hini as [H0 HH]; clear H0.
  rewrite Forall_app in Hnin.
  destruct Hnin as [H0 Hnin]; clear H0.
  inversion_clear Hnin as [|? ? H0 HH']; clear H0.
  apply List.Exists_exists in HH.
  destruct HH as [node [HaG Heq]].
  rewrite List.Forall_forall in HH'.
  apply HH' in HaG.
  contradiction.
Qed.

Lemma Memory_Corres_eqs_tl:
  forall node G eqs n M menv,
    Ordered_nodes (node::G)
    -> ~Is_node_in node.(n_name) eqs
    -> (Memory_Corres_eqs (node::G) n M menv eqs
        <-> Memory_Corres_eqs G n M menv eqs).
Proof.
  intros node G eqs n M menv Hord Hini.
  split; intro Hmc; revert M menv eqs Hmc Hini.
  - induction 1 as [? ? ? ? ? ? Hfind| | | |? ? ? ? ? ? Hmfind]
      using Memory_Corres_eqs_mult
      with (P0:=fun M menv eqs IH=>
                  ~Is_node_in node.(n_name) eqs
                  -> Memory_Corres_eqs G n M menv eqs)
           (P:=fun f M menv IH=>
                 node.(n_name) <> f ->
                 Memory_Corres G n f M menv); intro HH.
    + rewrite find_node_tl with (1:=HH) in Hfind.
      econstructor; [exact Hfind|].
      apply IHHmc.
      apply find_node_later_not_Is_node_in with (1:=Hord) (2:=Hfind).
    + constructor.
    + constructor; apply IHHmc; apply not_Is_node_in_cons in HH; intuition.
    + constructor.
      * intros Mo omenv Hmfind Hfindo.
        apply H; try assumption.
        intro Hneq; rewrite <-Hneq in HH.
        apply HH; repeat constructor.
      * apply IHHmc; apply not_Is_node_in_cons in HH; intuition.
    + constructor; [trivial|].
      apply IHHmc. apply not_Is_node_in_cons in HH. intuition.
  - induction 1 as [? ? ? ? ? ? Hfind| | | |? ? ? ? ? ? Hmfind]
      using Memory_Corres_eqs_mult
      with (P0:=fun M menv eqs IH=>
                  ~Is_node_in node.(n_name) eqs
                  -> Memory_Corres_eqs (node::G) n M menv eqs)
           (P:=fun f M menv IH=>
                 node.(n_name) <> f ->
                 Memory_Corres (node::G) n f M menv); intro HH.
    + econstructor; [rewrite find_node_tl with (1:=HH); exact Hfind|].
      apply IHHmc.
      apply find_node_later_not_Is_node_in with (1:=Hord) (2:=Hfind).
    + constructor.
    + constructor; apply IHHmc; apply not_Is_node_in_cons in HH; intuition.
    + constructor.
      * intros Mo omenv Hmfind Hfindo.
        apply H; try assumption.
        intro Hneq; rewrite <-Hneq in HH.
        apply HH; repeat constructor.
      * apply IHHmc; apply not_Is_node_in_cons in HH; intuition.
    + constructor; [trivial|].
      apply IHHmc. apply not_Is_node_in_cons in HH. intuition.
Qed.

Lemma Memory_Corres_tl:
  forall f node G n M menv,
    node.(n_name) <> f
    -> Ordered_nodes (node :: G)
    -> (Memory_Corres (node :: G) n f M menv <-> Memory_Corres G n f M menv).
Proof.
  intros f node G n M menv Hnf Hord.
  split;
    inversion_clear 1;
    econstructor;
    repeat progress
         match goal with
         | Hf: find_node ?f (_ :: ?G) = Some _ |- _ =>
           rewrite find_node_tl with (1:=Hnf) in Hf
         | |- find_node ?f (_ :: ?G) = Some _ =>
           rewrite find_node_tl with (1:=Hnf)
         | Hf: find_node ?f ?G = Some _ |- find_node ?f ?G = Some _ => exact Hf
         | H:Memory_Corres_eqs _ _ _ _ _ |- Memory_Corres_eqs _ _ _ _ _ =>
           apply Memory_Corres_eqs_tl with (1:=Hord) (3:=H)
         | Hf: find_node ?f ?G = Some _ |- ~Is_node_in _ _ =>
           apply find_node_later_not_Is_node_in with (1:=Hord) (2:=Hf)
         end.
Qed.

Lemma Is_node_correct:
  forall (G: global)
         (f: ident)
         (fnode: node)
         (xs: stream)
         (M: memory)
         (ys: stream)

         (prog: program)
         (prog': program)
         (fclass: class)
         (n: nat)
         (menv: memoryEnv)
         (env: constEnv)
         (menv': memoryEnv)
         (env': constEnv),

    Welldef_global G
    -> find_node f G = Some (fnode)
    -> msem_node G f xs M ys

    -> prog = translate G
    -> find_class f prog = Some(fclass, prog')
    -> (forall c, xs n = present c <-> PM.find (fclass.(c_input)) env = Some c)
    -> (forall x, Is_variable_in x (fnode.(n_eqs)) -> PM.find x env = None)
    -> stmt_eval prog' menv env (fclass.(c_step)) (menv', env')

    -> Memory_Corres G n f M menv

    -> (forall c, ys n =present c <-> PM.find (fclass.(c_output)) env' = Some c)
       /\ Memory_Corres G (S n) f M menv'.
Proof.
  induction G as [|node G IH]; [discriminate|].
  intros f fnode xs M ys prog prog' fclass n menv env menv' env'.
  intros Hwd Hfnd Hmsem Hprog Hfcls Hin1 Hother Hstmt Hmc.
  assert (Ordered_nodes (node::G)) as Hord
    by apply Welldef_global_Ordered_nodes with (1:=Hwd).

  simpl in Hfnd.
  destruct (ident_eqb (n_name node) f) eqn:Hfeq.

  Focus 2.
  { assert (node.(n_name) <> f) as Hfneq
        by apply Pos.eqb_neq with (1:=Hfeq).
    rewrite Memory_Corres_tl with (1:=Hfneq) (2:=Hord) in Hmc |- *.
    apply IH with (f:=f) (fnode:=fnode) (xs:=xs)
                         (prog:=translate G) (prog':=prog')
                         (menv:=menv) (env:=env)
                         (menv':=menv') (env':=env').
    apply (Welldef_global_cons _ _ Hwd).
    apply Hfnd.
    apply Pos.eqb_neq in Hfeq.
    apply Welldef_global_Ordered_nodes in Hwd.
    apply msem_node_cons with (1:=Hwd) (2:=Hmsem) (3:=Hfeq).
    reflexivity.
    rewrite Hprog in Hfcls; simpl in Hfcls; rewrite Hfeq in Hfcls; exact Hfcls.
    exact Hin1.
    exact Hother.
    exact Hstmt.
    exact Hmc. }
  Unfocus.

  rewrite Hprog in Hfcls; clear Hprog.
  simpl in Hfcls; rewrite Hfeq in Hfcls.
  symmetry in Hfcls; injection Hfcls.
  intros He1 He2; rewrite He1, He2 in *; clear He1 He2 Hfcls.

  injection Hfnd; intro He; rewrite He in *; clear He Hfnd.

  destruct fnode.
  simpl in *.

  inversion_clear Hmsem as [? ? ? ? i o eqs Hfind Hsem].
  simpl in *.
  rewrite Hfeq in Hfind.
  injection Hfind.
  intros; subst.
  clear Hfeq Hfind.
  destruct Hsem as [H [Hi [Ho Hsem]]].
  specialize Hi with n.
  specialize Ho with n.

  inversion_clear Hwd as [|? ? Hwd' neqs ni no Hwsch Hin2 Hout Hnode].
  rename Hwd' into Hwd.
  simpl in *.
  unfold neqs, ni, no in *; clear neqs ni no.
  rewrite ps_from_list_gather_eqs_memories in Hstmt.

  assert (forall alleqs, (exists oeqs, alleqs = oeqs ++ eqs) ->
    (forall x, Is_variable_in x eqs ->
     forall c, sem_var H x n (present c) <-> PM.find x env' = Some c)
    /\
    Memory_Corres_eqs G (S n) M menv' eqs) as His_step_correct.
  {
    intros alleqs Hall.
    admit. (* TODO: Replay the Is_step_correct induction *)
  }

  clear IH.
  specialize His_step_correct with ([] ++ eqs).
  destruct His_step_correct as [Hvar' Hmc']; [now eauto|].
  split.
  - intro c.
    apply Hvar' with (c:=c) in Hout.
    rewrite <- Hout.
    split; intro HH;
      [ rewrite HH in Ho; exact Ho
      | now apply sem_var_det with (1:=Ho) (2:=HH) ].
  - econstructor.
    + simpl; rewrite Pos.eqb_refl; reflexivity.
    + apply Memory_Corres_eqs_tl with (1:=Hord) (2:=Hnode) (3:=Hmc').
Qed.

(* TODO next:
   - show that fclass.(c_reset) satisfies: Memory_Corres M 0 menv
   - replace msem_node G f xs M ys with just sem_node G f xs ys
     using a lemma from DataflowNatMSemantics.
   - Show that running the step function for any n gives correct
     results (provided we stock and repass the memory), and
     eliminate the Memory_Corress hypothesis and result.
*)



Lemma is_step_correct:
  forall (G: global)
         (H: history)
         (H': history)
         (input: ident)
         (mems: PS.t)
         (alleqs: list equation),

    sem_equations G H alleqs
    -> sem_held_equations H H' alleqs
    -> (forall x:ident, PS.In x mems -> Is_memory_in x alleqs)

    -> forall (eqs: list equation)
              (n: nat)
              (menv: memoryEnv)
              (menv': memoryEnv)
              (env: constEnv)
              (env': constEnv),

    Is_well_sch (PS.add input mems) eqs
    -> (exists oeqs, alleqs = oeqs ++ eqs)
    -> stmt_eval menv env (translate_eqns mems eqs) (menv', env')

    (* NB: PM.find x env' = Some c -> sem_var H x n (present c)
           does not hold if PM.find x env = Some arbitrary_c, since
           x will not be written to when its clock is absent.

           It may just be better to show the direction:
           sem_var H x n (present c) -> PM.find x env' = Some c

           which is enough if the outputs are only sampled when
           they are present (normally the case).

           More discussion/context is needed. *)
    -> (forall x, Is_variable_in x eqs -> PM.find x env = None)

    (* - inputs (assumed) *)
    -> ~Is_memory_in input eqs
    -> (forall c, sem_var H input n (present c) <-> PM.find input env = Some c)

    (* - unwritten memories (assumed) *)
    -> (forall x:ident,
           PS.In x mems ->
           forall c, sem_var H' x n (present c) <-> find_mem x menv = Some c)

    (* - locals (shown) *)
    -> (forall x:ident,
           Is_variable_in x eqs ->
           forall c, sem_var H x n (present c) <-> PM.find x env' = Some c)

    (* - written memories (shown) *)
       /\ (forall x:ident,
              Is_memory_in x eqs ->
              forall c, sem_var H' x (S n) (present c)
                        <-> find_mem x menv' = Some c).
Proof.
  intros until alleqs.
  intros Hsems Hheld Himi.

  induction eqs as [|eq].
  split; intros; match goal with
                 | H:Is_variable_in _ nil |- _ => inversion H
                 | H:Is_memory_in _ nil |- _ => inversion H
                 end.
  intros n menv menv'' env env'' Hwsch Hall Hevals Henv Hin1 Hin2 Humem.

  (* split stmt_eval into two parts *)
  apply stmt_eval_translate_eqns_cons in Hevals;
    destruct Hevals as [menv' Hevals];
    destruct Hevals as [env' Hevals];
    destruct Hevals as [Hevals Heval].

  assert (forall x, Is_variable_in x eqs -> PM.find x env = None) as Henv'
      by (intros; apply Henv; constructor 2; auto).

  apply not_Is_memory_in_cons in Hin1.
  destruct Hin1 as [Hin1 Hin1s].

  specialize (IHeqs _ _ _ _ _
                    (Is_well_sch_cons _ _ _ Hwsch)
                    (List_shift_away _ _ _ _ Hall)
                    Hevals Henv' Hin1s Hin2 Humem).
  destruct IHeqs as [IHeqs1 IHeqs2].
  clear Henv'.

  destruct Hall as [oeqs Hall].
  assert (Hsems' := Hsems); rewrite Hall in Hsems'.
  apply sem_equations_app2 in Hsems'.
  apply sem_equations_cons in Hsems'.
  destruct Hsems' as [Hsem Hsems'].

  split.
  - intros x Hvi c.
    apply Is_variable_in_cons in Hvi; destruct Hvi as [Hvieq|Hivieqs].
    + destruct eq as [y cae|y f lae|]; inversion Hvieq; subst; clear Hvieq.
      * (* Inductive step for EqDef *)
        destruct cae as [ck ce].
        simpl in Heval.
        inversion_clear Hsem as [? ? Hsem'| |];
          specialize Hsem' with n;
          destruct Hsem' as [v Hsem];
          destruct Hsem as [Hsv Hcae].
        pose proof (stmt_eval_translate_eqns_menv_inv _ _ _ _ _ _ Hevals)
          as Hminv.
        apply stmt_eval_Control in Heval;
          destruct Heval as [Heval|Heval];
          destruct Heval as [Hpi Heval].
        { (* Is_present_in ck *)
          inversion Hcae as [? ? ? c' Hcexp Hclk|? ? ? Hcexp Hclk];
          subst; clear Hcae.
          { (* sem_clock H ck n true *)
            apply (cexp_correct _ _ _ _ _ _ _ _ _ _ Hcexp) in Heval.
            2: resolve_env_assumption.
            rewrite Heval; rewrite PM.gss; split.
            intro Hsv';
              assert (present c' = present c) as Heq
                by apply sem_var_det with (1:=Hsv) (2:=Hsv').
            injection Heq as Heq'; subst; reflexivity.
            injection 1 as Heq; rewrite Heq in Hsv; assumption. }
          { (* sem_clock H ck n false *)
            apply clock_correct_false with _ _ mems menv' env' _ in Hclk.
            2: resolve_env_assumption.
            contradiction. }
        }
        { (* ~Is_present_in ck *)
          destruct Heval as [HR1 HR2]; rewrite HR2 in *; clear HR1 HR2.
          inversion Hcae as [ ck' ce' n' c' Hcexp Hclk
                            | ck' ce' n' Hcexp Hclk [HR1 HR2] HR3 HR4].
          { (* sem_clock H ck n true *)
            apply (clock_correct_true H n mems menv' env' ck) in Hclk.
            2: resolve_env_assumption.
            contradiction. }
          { (* sem_clock H ck n false *)
            split.
            { intro Hsv'.
              pose proof (sem_var_det _ _ _ _ _ Hsv Hsv') as Hbad.
              rewrite <- HR4 in Hbad.
              discriminate Hbad. }
            { intro Hfx.
              destruct (Is_variable_in_dec y eqs) as [Hvi|Hvni].
              apply IHeqs1; [apply Hvi | apply Hfx].
              apply (stmt_eval_translate_eqns_env_inv _ _ _ _ _ _ Hevals) in Hvni.
              rewrite Hvni in Hfx.
              rewrite Henv in Hfx.
              discriminate.
              repeat constructor. }
            }
        }
      * (* TODO: Inductive step for EqApp. *) admit.
    + destruct Hivieqs as [H0 H1].
      apply IHeqs1 with (c:=c) in H1; rewrite H1.
      apply not_Is_variable_in_eq with (2:=Heval) in H0.
      rewrite H0; intuition.
  - (* Inductive step for EqFby: y = v0 fby lae *)
    intros x Hmi c.
    apply Is_memory_in_cons in Hmi; destruct Hmi as [Hmieq|Himieqs].
    2:now (destruct Himieqs as [Himieq Himieqs];
           rewrite IHeqs2;
           [ rewrite not_Is_memory_in_eq with (1:=Himieq) (2:=Heval) | auto ]).
    destruct eq as [| |y v0 lae]; inversion Hmieq; subst; clear Hmieq.
    destruct lae as [ck le].
    simpl in Heval.
    pose proof (stmt_eval_translate_eqns_menv_inv _ _ _ _ _ _ Hevals)
      as Hminv.

    assert (Hheld' := Hheld).
    apply sem_held_equations_app2 in Hheld'.
    apply sem_held_equations_cons in Hheld'.
    destruct Hheld' as [Hheld' Hhelds'].
    inversion_clear Hheld' as [| |? ? ? ls Hlae Hsv].
    specialize Hlae with n.

    apply stmt_eval_Control in Heval;
      destruct Heval as [Heval|Heval];
      destruct Heval as [Hpi Heval].
    { (* Is_present_in ck *)
      inversion Heval as [|? ? ec ? Hexp Hmenv''| | | | |]; subst.
      rewrite find_mem_gss.
      inversion Hlae as [? ? ? ? Hlexp Hclk H1 H2 Hlsn|? ? ? Hlexp Hclk]; subst.
      { (* sem_clock H ck n true *)
        rewrite Hsv; clear Hsv.
        assert (exp_eval menv' env'' (translate_lexp mems le) c0) as Hexp'
          by (apply (lexp_correct _ _ _ _ _ _ _ Hlexp); resolve_env_assumption).
        apply (exp_eval_det _ _ _ _ _ Hexp) in Hexp'.
        rewrite Hexp' in *; clear Hexp'.
        symmetry in Hlsn.
        apply holdR_present with v0 _ _ _ in Hlsn.
        split.
        - intro Hlsn'.
          apply hold_rel in Hlsn.
          apply hold_rel in Hlsn'.
          subst; reflexivity.
        - injection 1.
          intro HR; rewrite HR in Hlsn; auto. }
      { (* sem_clock H ck n false *)
        apply clock_correct_false with _ _ mems menv' env'' _ in Hclk.
        2: resolve_env_assumption; apply IHeqs1; auto.
        contradiction. } }
    { (* ~Is_present_in ck *)
      destruct Heval as [HR1 HR2]; rewrite HR1 in *; clear HR1 HR2.
      inversion Hlae as [? ? ? ? Hlexp Hclk H1 H2 Hlsn
                        | ? ? ? Hlexp Hclk H0 H2 Hlsn]; subst.
      { (* sem_clock H ck n true *)
        apply (clock_correct_true H n mems menv' env' ck) in Hclk.
        2: resolve_env_assumption.
        contradiction. }
      { (* sem_clock H ck n false *)
        Hint Constructors Is_memory_in_eq.
        Hint Immediate Is_memory_in_EqFby.
        destruct Is_memory_in_dec with y eqs as [Hxin|Hxin];
        [ now apply IHeqs2 with (1:=Hxin) | ].
        apply Hminv in Hxin.
        rewrite Hxin; clear Hxin.
        assert (PS.In y mems) as Hymems.
        { apply Is_wsch_Is_memory_in_mems with _ y _ in Hwsch; [|now auto].
          apply PS.add_spec in Hwsch.
          destruct Hwsch as [Hwsch|Hwsch]; [|now auto].
          rewrite Hwsch in Hin1.
          exfalso; auto. }
        rewrite <- Humem with (1:=Hymems).
        split.
        - intro HH.
          apply Hsv in HH.
          inversion_clear HH as [|? ? Hlsn' HholdR|? ? Hlsn'];
            [ apply Hsv in HholdR; exact HholdR
            | rewrite Hlsn' in Hlsn; discriminate ].
        - intro HH.
          symmetry in Hlsn.
          apply holdR_absent with v0 _ c _ in Hlsn;
            [ apply Hsv in Hlsn; exact Hlsn
            | apply Hsv; exact HH ].
      }
    }
Qed.

Lemma stmt_eval_translate_eqn_init_shift:
  forall eqs iacc menv env menv' env',
    stmt_eval menv env
              (List.fold_left translate_eqn_init eqs iacc)
              (menv', env')
    <->
    exists menv'' env'',
      stmt_eval menv env
                (List.fold_left translate_eqn_init eqs Skip)
                (menv'', env'')
      /\
      stmt_eval menv'' env'' iacc (menv', env').
Proof.
  Hint Constructors stmt_eval.
  induction eqs as [|eq eqs IH].
  - split; [ now eauto | ].
    intro H; do 2 destruct H.
    destruct H as [H0 H1].
    inversion_clear H0; apply H1.
  - intros.
    split.
    + intro H0.
      apply IH in H0.
      destruct H0 as [menv'' [env'' [H0 H1]]].
      destruct eq; [now eauto|now eauto|].
      inversion_clear H1.
      exists menv1; exists env1.
      split; try (simpl; apply IH); eauto.
    + intros.
      destruct eq;
        [now (apply IH; auto)|now (apply IH; auto)|].
      apply IH.
      simpl in H.
      destruct H as [menv'' [env'' [H0 H1]]].
      apply IH in H0.
      destruct H0 as [menv0 [env0 [H2 H3]]].
      exists menv0; exists env0.
      split; [now auto|].
      inversion_clear H3.
      inversion H0; subst.
      econstructor; eauto.
Qed.

Lemma is_step_initialized:
  forall (G: global)
         (H: history)
         (H': history)
         (mems: PS.t)
         (eqs: list equation)
         (menv: memoryEnv)
         (menv': memoryEnv)
         (env: constEnv)
         (env': constEnv),
    sem_equations G H eqs
    -> sem_held_equations H H' eqs
    -> stmt_eval menv env (translate_eqns_init eqs) (menv', env')
    -> (forall x:ident,
           Is_memory_in x eqs ->
           forall c, sem_var H' x 0 (present c) <-> find_mem x menv' = Some c).
Proof. (* TODO: Tidy up this proof *)
  induction eqs as [|eq]; [ inversion 4 | ].
  intros menv menv' env env' Hsem Hheld Heval x Himi c.
  apply sem_equations_cons in Hsem;
    destruct Hsem as [Hsem Hsems].
  apply sem_held_equations_cons in Hheld;
    destruct Hheld as [Hheld Hhelds].
  destruct eq;
    (apply Is_memory_in_cons in Himi;
     destruct Himi as [Himi|Himi];
     [inversion Himi|destruct Himi as [Hnimi Himi]];
     try apply IHeqs with (1:=Hsems) (2:=Hhelds) (3:=Heval) (4:=Himi)).
  - subst.
    unfold translate_eqns_init in Heval.
    simpl in Heval.
    apply stmt_eval_translate_eqn_init_shift in Heval.
    destruct Heval as [menv'' [env'' [Hevals Heval]]].
    inversion Heval; subst.
    repeat progress
           match goal with
           | H:stmt_eval _ _ Skip _ |- _ => inversion H; subst; clear H
           | H:stmt_eval _ _ (AssignSt _ _) _ |- _ => inversion H; subst; clear H
           end.
    rewrite find_mem_gss.
    inversion Hheld; subst.
    split.
    intro HH.
    apply H5 in HH.
    inversion HH; subst.
    inversion_clear H4.
    reflexivity.

    intro HH.
    injection HH.
    intro.
    apply H5.
    inversion H4. subst.
    constructor.
  - unfold translate_eqns_init in Heval.
    simpl in Heval.
    apply stmt_eval_translate_eqn_init_shift in Heval.
    destruct Heval as [menv'' [env'' [Hevals Heval]]].
    change (stmt_eval menv env (translate_eqns_init eqs) (menv'', env'')) in Hevals.
    apply IHeqs with (1:=Hsems) (2:=Hhelds) (3:=Hevals) (c:=c) in Himi.
    rewrite Himi.
    inversion_clear Heval.
    repeat progress
           match goal with
           | H:stmt_eval _ _ Skip _ |- _ => inversion H; subst; clear H
           | H:stmt_eval _ _ (AssignSt _ _) _ |- _ => inversion H; subst; clear H
           end.
    assert (x<>i) as Hxni by (contradict Hnimi; subst; constructor).
    rewrite find_mem_gso with (1:=Hxni).
    intuition.
Qed.

(* TODO: lemma to 'close the loop' on is_step_correct.
         Induction on n (the number of the instant). *)

(*
Lemma is_steps_correct:
  forall (G: global)
         (H: history)
         (H': history)
         (input: ident)
         (mems: PS.t),

    sem_equations G H eqs
    -> sem_held_equations H H' eqs
    -> (forall x:ident, PS.In x mems -> Is_memory_in x eqs)

    -> forall (eqs: list equation)
              (n: nat)
              (menv: memoryEnv)
              (menv': memoryEnv)
              (env: constEnv)
              (env': constEnv),

    Is_well_sch (PS.add input mems) eqs
    -> stmt_eval menv env (translate_eqns mems eqs) (menv', env')

    (* NB: PM.find x env' = Some c -> sem_var H x n (present c)
           does not hold if PM.find x env = Some arbitrary_c, since
           x will not be written to when its clock is absent.

           It may just be better to show the direction:
           sem_var H x n (present c) -> PM.find x env' = Some c

           which is enough if the outputs are only sampled when
           they are present (normally the case).

           More discussion/context is needed. *)
    -> (forall x, Is_variable_in x eqs -> PM.find x env = None)

    (* - inputs (assumed) *)
    -> ~Is_memory_in input eqs
    -> (forall c, sem_var H input n (present c) <-> PM.find input env = Some c)

(*
    (* - unwritten memories (assumed) *)
    -> (forall x:ident,
           PS.In x mems ->
           forall c, sem_var H' x n (present c) <-> find_mem x menv = Some c)
*)

    (* - locals (shown) *)
    -> (forall x:ident,
           Is_variable_in x eqs ->
           forall c, sem_var H x n (present c) <-> PM.find x env' = Some c)

    (* - written memories (shown) *)
       /\ (forall x:ident,
              Is_memory_in x eqs ->
              forall c, sem_var H' x (S n) (present c)
                        <-> find_mem x menv' = Some c).
*)
