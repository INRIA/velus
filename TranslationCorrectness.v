Require Import Rustre.Common.
Require Import Rustre.DataflowSyntax.

(** ** Predicates *)

(* Working: Tim *)

(* ** Definitions on dataflow equations *)

Fixpoint defined_eq (defs: PS.t) (eq: equation) : PS.t :=
  match eq with
  | EqDef x _   => PS.add x defs
  | EqApp x _ _ => PS.add x defs
  | EqFby x _ _ => PS.add x defs
  end.

Definition defined (eqs: list equation) : PS.t :=
  List.fold_left defined_eq eqs PS.empty.

Fixpoint freevar_lexp' (e: lexp) (fvs: PS.t) : PS.t :=
  match e with
    | Econst c => fvs
    | Evar x => PS.add x fvs
    | Ewhen ae c x => freevar_laexp' ae fvs
  end
with freevar_laexp' (lae: laexp) (fvs: PS.t) : PS.t :=
  match lae with
    | LAexp ck e => freevar_lexp' e fvs
  end.

Fixpoint freevar_caexp' (cae: caexp) (fvs: PS.t) : PS.t :=
  match cae with
  | CAexp ck ce => freevar_cexp' ce fvs
  end
with freevar_cexp' (ce: cexp) (fvs: PS.t) : PS.t :=
  match ce with
  | Emerge x t f => PS.add x (freevar_caexp' f (freevar_caexp' t fvs))
  | Eexp e => freevar_lexp' e fvs
  end.

Definition freevar_lexp e := freevar_lexp' e PS.empty.
Definition freevar_laexp lae := freevar_laexp' lae PS.empty.
Definition freevar_caexp cae := freevar_caexp' cae PS.empty.

(* TODO: Big question: how do we get from the scheduling property on graphs
                       to this predicate?
         (Membership in memories or not, should follow from the definition
          of 'memories' above.) *)
Inductive sch_eqs (memories: PS.t) : PS.t -> PS.t -> list equation -> Prop :=
| SchEqDef:
    forall written notwritten x e eqs,
      ~ (PS.In x memories) ->
      PS.Subset (PS.diff  (freevar_caexp e) memories) written ->
      PS.Subset (PS.inter (freevar_caexp e) memories) notwritten ->  
      sch_eqs memories (PS.add x written) (PS.remove x notwritten) eqs ->
      sch_eqs memories written notwritten (EqDef x e :: eqs)
| SchEqApp:
    forall written notwritten x f e eqs,
      ~ (PS.In x memories) ->
      PS.Subset (PS.diff  (freevar_laexp e) memories) written ->
      PS.Subset (PS.inter (freevar_laexp e) memories) notwritten ->  
      sch_eqs memories (PS.add x written) (PS.remove x notwritten) eqs ->
      sch_eqs memories written notwritten (EqApp x f e :: eqs)
| SchEqFby:
    forall written notwritten x v0 e eqs,
      PS.In x memories ->
      PS.Subset (PS.diff  (freevar_laexp e) memories) written ->
      PS.Subset (PS.inter (freevar_laexp e) memories) notwritten ->
      sch_eqs memories (PS.add x written) (PS.remove x notwritten) eqs ->
      sch_eqs memories written notwritten (EqFby x v0 e :: eqs).

(* ** Definitions on imperative statements *)

Require Import Rustre.Minimp.
Require Import Rustre.Translation.
Require Import Rustre.DataflowNatSemantics.
Require Import Rustre.SynchronousNat.

(* TODO:
   - Assume we are given a list of dataflow equations eqs satisfying
        sch_eqs (memories eqs) PS.empty (defined eqs) eqs
   - Show that the step function generated by translate_eqs is correct,
     i.e., that its semantics correspond to the 'held semantics' of the
     original dataflow equations.
   - The 'held semantics' use holdR rather than fbyR for defining 'fby'.
   - Basic invariant for a single pass (to show by induction along the list
     of dataflow equations/sequence of conditional assignments):
        forall x,
             (PS.In x (PS.inter memories written) -> M x = H x (S n))
          /\ (PS.In x (PS.diff memories written) -> M x = H x n)
          /\ (PS.In x (PS.diff written memories) ->
              H x n = present c -> p x = c)

   - Afterward, this must be extended to run (i.e., forall n from 0).
   - and we must switch back to the standard fby semantics for instants
     where a clock is active.
 *)

Lemma pm_in_dec: forall A i m, PM.In (A:=A) i m \/ ~PM.In (A:=A) i m.
Proof.
  unfold PM.In.
  unfold PM.MapsTo.
  intros A i m.
  case (PM.find i m).
  eauto.
  right; intro; destruct H; discriminate H.
Qed.

Lemma ps_in_dec: forall i m, PS.In i m \/ ~PS.In i m.
Proof.
  intros i m.
  unfold PS.In.
  case (PS.mem i m); auto.
Qed.

Lemma exp_correct:
  forall H memories lae n c menv env,
    sem_laexp H lae n (present c) ->
    (forall i c, PM.find i (H n) = Some (present c) ->
                 (PS.In i memories -> find_mem i menv = Some c)
                 /\ (~PS.In i memories -> PM.find i env = Some c)) ->
    exp_eval menv env (translate_laexp memories lae) c.
Proof.
  intros H memories lae n c menv env.
  (* TODO: is there a better way to do this?: *)
  apply (laexp_mult (fun l0 : laexp =>
                       sem_laexp H l0 n c ->
                       (forall (i : BinNums.positive) (c0 : const),
                           PM.find i (H n) = Some (present c0) ->
                           (PS.In i memories -> find_mem i menv = Some c0) /\
                           (~ PS.In i memories -> PM.find i env = Some c0)) ->
                       exp_eval menv env (translate_laexp memories l0) c)
                    (fun l0 : lexp =>
                       sem_lexp H l0 n c ->
                       (forall (i : BinNums.positive) (c0 : const),
                           PM.find i (H n) = Some (present c0) ->
                           (PS.In i memories -> find_mem i menv = Some c0) /\
                           (~ PS.In i memories -> PM.find i env = Some c0)) ->
                       exp_eval menv env (translate_lexp memories l0) c)).
  (* TODO: How to make this proof shorter? *)
  - intros ck le IH H1 H2.
    inversion H1 as [? ? ? ? Hlexp|].
    apply (IH Hlexp H2).
  - intros c0 H0 ?.
    inversion H0.
    apply econst.
  - intros.
    inversion H0.
    inversion H5.
    apply H1 in H6.
    destruct H6.
    destruct (ps_in_dec i memories) as [Hin | Hout].
    + unfold translate_lexp.
      generalize Hin.
      unfold PS.In.
      intro Hin'.
      rewrite Hin'.
      clear Hin'.
      apply estate.
      apply H6.
      apply Hin.
    + unfold translate_lexp.
      generalize Hout.
      unfold PS.In.
      intro Hout'.
      rewrite (Bool.not_true_is_false _ Hout').
      apply evar.
      apply H7.
      apply Hout.
  - intros.
    inversion H1.
    change (exp_eval menv env (translate_laexp memories l) c).
    apply (H0 H9 H2).
Qed.

Inductive exp_eval (menv: memoryEnv)(env: valueEnv):
  exp -> const -> Prop :=
| evar: 
    forall x v, 
      PositiveMap.find x env = Some(v) -> 
      exp_eval menv env (Var(x)) v
| econst:
    forall c ,
      exp_eval menv env (Const(c)) c.


Lemma step_correct:
  forall eqs : list equation,

    (* assumptions *)
    sch_eqs (memories eqs) PS.empty (defined eqs) eqs -> (* written = { input } *)

    (* invariant *)
      forall x,
             (PS.In x (PS.inter memories written) -> M x = H x (S n))
          /\ (PS.In x (PS.diff memories written) -> M x = H x n)
          /\ (PS.In x (PS.diff written memories) ->
              H x n = present c -> p x = c)

    (* meaning of data-flow equations *)

    (* TODO: replace this with the 'hold semantics' *)
    sem_equations G H eqs ->

    (* meaning of imperative code; linked by translation function *)
    s = runCompiler (translate_eqns eqs) ->
    run M R s.(st_instrs) n (R', M') ->

    s.(st_mem)
    s.(st_instrs)

    (* missing: assumptions on input:  n.(n_input).(v_name) *)


Lemma step_correct:
  forall eqs : list equation,

    (* assumptions *)
    sch_eqs (memories eqs) PS.empty (defined eqs) eqs ->

    PS.Subset (memories eqs) mems ->
    PS.Subset (defined eqs) defs ->

    (* invariant *)
      forall x,
             (PS.In x (PS.inter memories written) -> M x = H x (S n))
          /\ (PS.In x (PS.diff memories written) -> M x = H x n)
          /\ (PS.In x (PS.diff written memories) ->
              H x n = present c -> p x = c)  

    (* meaning of data-flow equations *)

               (* TODO: replace this with the 'hold semantics' *)
     sem_equations G H eqs ->


    (* meaning of imperative code; linked by translation function *)
               let s := runCompiler (translate_eqns eqs) in
               s.(st_mem)
                   s.(st_instrs)

             run M R s.(st_instrs) n (R', M')

    (* missing: assumptions on input:  n.(n_input).(v_name) *)

(* Working: *)
Inductive run :
  memoryEnv -> valueEnv -> stmt -> nat -> valueEnv * memoryEnv -> Prop :=
               





(* TODO: Do we really need these definitions? We should be able to extract
         the relevant information from the definitions above via the
         translation functions. *)
Fixpoint freevar_exp (fvs: PS.t) (e: exp) : PS.t :=
  match e with
  | Var x => PS.add x fvs
  | Const c => fvs
  end.
    
Fixpoint freevar_stmt (fvs: PS.t) (s: stmt) : PS.t :=
   match s with
   | Assign i e => freevar_exp fvs e
   | AssignSt i e => freevar_exp fvs e
   | Ifte i s1 s2 => freevar_stmt (freevar_stmt (PS.add i fvs) s1) s2
   | Step_ap i f e => freevar_exp fvs e
   | Comp s1 s2 => freevar_stmt (freevar_stmt fvs s1) s2
   | Skip => fvs
   end.



