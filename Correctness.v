Require Import List.
Import List.ListNotations.
Open Scope list_scope.

Require Import Rustre.Common.
Open Scope positive.

Require Import Rustre.Heap.
Require Import Rustre.Dataflow.
(* TODO: these should go *)
Require Import Rustre.Dataflow.IsVariable.Decide.
Require Import Rustre.Dataflow.IsDefined.Decide.

(* ** Definitions on imperative statements *)

Require Import Rustre.Minimp.
Require Import Rustre.Translation.
Require Import Rustre.Correctness.Proper.
Require Import Rustre.Correctness.IsPresent.
Require Import Rustre.Correctness.MemoryCorres.


(* TODO:
   - Assume we are given a list of dataflow equations eqs satisfying
        sch_eqs (memories eqs) PS.empty (defined eqs) eqs
   - Show that the step function generated by translate_eqs is correct,
     i.e., that its semantics correspond to the 'held semantics' of the
     original dataflow equations.
   - The 'held semantics' use holdR rather than fbyR for defining 'fby'.
   - Basic invariant for a single pass (to show by induction along the list
     of dataflow equations/sequence of conditional assignments):
        forall x,
             (PS.In x (PS.inter memories written) -> M x = H x (S n))
          /\ (PS.In x (PS.diff memories written) -> M x = H x n)
          /\ (PS.In x (PS.diff written memories) ->
              H x n = present c -> p x = c)

   - Afterward, this must be extended to run (i.e., forall n from 0).
   - and we must switch back to the standard fby semantics for instants
     where a clock is active.
 *)

(** ** Technical lemmas *)

Lemma exp_eval_tovar:
  forall x v menv env memories,
    exp_eval menv env (tovar memories x) v
    <-> (exp_eval menv env (State x) v /\ PS.In x memories)
        \/ (exp_eval menv env (Var x) v /\ ~PS.In x memories).
Proof.
  split; intro Heval;
  destruct In_dec with x memories as [Hxm|Hxm];
    pose proof Hxm as Hxmt;
    apply PS.mem_spec in Hxmt || apply mem_spec_false in Hxmt;
    unfold tovar in *;
    rewrite Hxmt in *;
    intuition.
Qed.

Lemma stmt_eval_translate_eqns_cons:
  forall prog mems menv env menv' env' eq eqs,
    stmt_eval prog menv env (translate_eqns mems (eq :: eqs)) (menv', env')
    <->
    (exists menv'' env'',
        stmt_eval prog menv env (translate_eqns mems eqs) (menv'', env'')
        /\ stmt_eval prog menv'' env'' (translate_eqn mems eq) (menv', env')).
Proof. (* TODO: redo proof *)
  split.
  - intro H.
    unfold translate_eqns in H.
    simpl in H.
    apply stmt_eval_fold_left_shift in H.
    destruct H as [menv'' [env'' [H1 H2]]].
    exists menv'', env''.
    split; [now apply H1|].
    inversion_clear H2.
    inversion H0.
    subst.
    exact H.
  - intro H.
    destruct H as [menv'' [env'' [H1 H2]]].
    unfold translate_eqns.
    simpl.
    apply stmt_eval_fold_left_shift.
    exists menv'', env''.
    split; [now apply H1|].
    eapply Icomp. apply H2.
    apply Iskip.
Qed.

Lemma stmt_eval_Control_fwd:
  forall prog menv env mems c s menv' env',
    stmt_eval prog menv env (Control mems c s) (menv', env')
    -> (Is_present_in mems menv env c
        /\ stmt_eval prog menv env s (menv', env'))
       \/ (Is_absent_in mems menv env c
           /\ menv' = menv /\ env' = env).
Proof.
  Hint Constructors Is_present_in Is_absent_in.
  intros prog menv env mems c s menv' env' Hs.
  revert s Hs.
  induction c; [now intuition|].
  intros s Hs.
  simpl in Hs.
  destruct b;
    specialize (IHc _ Hs); clear Hs;
    destruct IHc as [[Hp Hs]|[Hp [Hmenv Henv]]];
    try inversion_clear Hs;
  (left; now intuition)
   || (right;
        repeat progress
               match goal with
               | H: stmt_eval _ _ _ Skip _ |- _ => inversion H; subst; clear H
               | Hp: Is_present_in _ _ _ _,
                     He: exp_eval _ _ _ _ |- Is_absent_in _ _ _ _
                 => apply IsAbs2 with (1:=Hp) (2:=He)
               | _ => intuition
               end).
Qed.

Lemma stmt_eval_Control:
  forall prog mems menv env ck stmt,
    (Is_absent_in mems menv env ck
     -> stmt_eval prog menv env (Control mems ck stmt) (menv, env))
    /\
    (forall menv' env',
       Is_present_in mems menv env ck
       -> stmt_eval prog menv env stmt (menv', env')
       -> stmt_eval prog menv env (Control mems ck stmt) (menv', env')).
Proof.
  intros prog mems menv env ck.
  induction ck; intro s; split.
  - now inversion 1.
  - intros menv' env' Hp Hs; exact Hs.
  - inversion_clear 1 as [? ? ? Hp|? ? ? ? Hp Hexp Hneq];
    destruct b;
    try (now apply IHck with (1:=Hp));
    apply not_eq_sym in Hneq;
      (apply Bool.not_true_is_false in Hneq
       || apply Bool.not_false_is_true in Hneq);
      subst;
      apply IHck with (1:=Hp);
      (apply Iifte_false with (1:=Hexp)
       || apply Iifte_true with (1:=Hexp));
      constructor.
  - inversion_clear 1 as [|? ? ? Hp Hexp];
    intro Hs;
    destruct b;
    apply IHck with (1:=Hp);
    [ now apply Iifte_true with (1:=Hexp) (2:=Hs)
    | now apply Iifte_false with (1:=Hexp) (2:=Hs) ].
Qed.

Lemma stmt_eval_Control_absent:
  forall prog mems menv env ck stmt,
    Is_absent_in mems menv env ck
    -> stmt_eval prog menv env (Control mems ck stmt) (menv, env).
Proof.
  apply stmt_eval_Control.
Qed.

Lemma stmt_eval_Control_present:
  forall prog mems menv env ck stmt menv' env',
    Is_present_in mems menv env ck
    -> stmt_eval prog menv env stmt (menv', env')
    -> stmt_eval prog menv env (Control mems ck stmt) (menv', env').
Proof.
  apply stmt_eval_Control.
Qed.

Lemma stmt_eval_translate_cexp_menv_inv:
  forall prog menv env mems x menv' env' ce,
    stmt_eval prog menv env (translate_cexp mems x ce) (menv', env')
    -> menv' = menv.
Proof.
  intros prog menv env mems x menv' env'.
  induction ce;
  (apply IHce || inversion_clear 1); auto.
Qed.

Lemma stmt_eval_translate_cexp_env_add:
  forall prog menv env mems x menv' env' ce,
    stmt_eval prog menv env (translate_cexp mems x ce) (menv', env')
    -> exists c, env' = PM.add x c env.
Proof.
  intros prog menv env mems x menv' env'.
  induction ce;
    (apply IHce || inversion_clear 1); auto.
  exists v; rewrite <- H1; intuition.
Qed.

Lemma not_Is_defined_in_eq_stmt_eval_menv_inv:
  forall prog x eq menv env mems menv' env',
    ~Is_defined_in_eq x eq
    -> stmt_eval prog menv env (translate_eqn mems eq) (menv', env')
    -> mfind_mem x menv' = mfind_mem x menv.
Proof. (* TODO: Tidy proof *)
  intros prog x eq menv env mems menv' env' Hneq Heval.
  destruct eq as [y cae|y f lae|y v0 lae].
  - destruct cae.
    simpl in Heval.
    apply stmt_eval_Control_fwd in Heval; destruct Heval as [Heval|Heval];
    destruct Heval as [Heval1 Heval2].
    apply stmt_eval_translate_cexp_menv_inv in Heval2.
    rewrite Heval2. intuition.
    destruct Heval2 as [Hmenv]; rewrite Hmenv; intuition.
  - destruct lae.
    simpl in Heval.
    apply stmt_eval_Control_fwd in Heval; destruct Heval as [Heval|Heval];
    destruct Heval as [Hipi Heval].
    inversion_clear Heval.
    rewrite <- H2.
    reflexivity.
    destruct Heval as [Hmenv Henv]; rewrite Hmenv; intuition.
  - apply not_Is_defined_in_eq_EqFby in Hneq.
    unfold translate_eqn in Heval.
    destruct lae.
    apply stmt_eval_Control_fwd in Heval; destruct Heval as [Heval|Heval];
    destruct Heval as [Hipi Heval].
    inversion_clear Heval.
    rewrite <- H0.
    unfold mfind_mem, madd_mem.
    simpl; rewrite PM.gso; [intuition | apply Hneq].
    destruct Heval as [Hmenv Henv]; rewrite Hmenv; intuition.
Qed.

Lemma not_Is_defined_in_eq_stmt_eval_mobj_inv:
  forall prog x eq menv env mems menv' env',
    ~Is_defined_in_eq x eq
    -> stmt_eval prog menv env (translate_eqn mems eq) (menv', env')
    -> mfind_inst x menv' = mfind_inst x menv.
Proof. (* TODO: Tidy proof *)
  intros prog x eq menv env mems menv' env' Hneq Heval.
  destruct eq as [y cae|y f lae|y v0 lae].
  - destruct cae.
    simpl in Heval.
    apply stmt_eval_Control_fwd in Heval; destruct Heval as [Heval|Heval];
    destruct Heval as [Heval1 Heval2].
    apply stmt_eval_translate_cexp_menv_inv in Heval2.
    rewrite Heval2. intuition.
    destruct Heval2 as [Hmenv]; rewrite Hmenv; intuition.
  - destruct lae.
    simpl in Heval.
    apply stmt_eval_Control_fwd in Heval; destruct Heval as [Heval|Heval];
    destruct Heval as [Hipi Heval].
    + inversion_clear Heval.
      rewrite <- H2.
      destruct (ident_eq_dec x y) as [Hxy|Hxny].
      * rewrite Hxy in Hneq; exfalso; apply Hneq; constructor.
      * rewrite mfind_inst_gso; [reflexivity|assumption].
    + destruct Heval as [HR1 HR2]; rewrite HR1; reflexivity.
  - unfold translate_eqn in Heval.
    destruct lae.
    apply stmt_eval_Control_fwd in Heval; destruct Heval as [Heval|Heval];
    destruct Heval as [Hipi Heval].
    inversion_clear Heval.
    rewrite <- H0.
    unfold mfind_inst, madd_mem.
    reflexivity.
    destruct Heval as [Hmenv Henv]; rewrite Hmenv; intuition.
Qed.

Lemma not_Is_variable_in_eq_stmt_eval_env_inv:
  forall prog x eq menv env mems menv' env',
    ~Is_variable_in_eq x eq
    -> stmt_eval prog menv env (translate_eqn mems eq) (menv', env')
    -> PM.find x env' = PM.find x env.
Proof.
  intros prog x eq menv env mems menv' env' Hnd Heval.
  destruct eq as [y e|y f e|y v0 e].
  - unfold translate_eqn in Heval.
    destruct e.
    apply stmt_eval_Control_fwd in Heval;
      destruct Heval as [[Hipi Heval]|[Habs [Hmenv Henv]]];
      [|rewrite Henv; reflexivity].
    apply stmt_eval_translate_cexp_env_add in Heval.
    destruct Heval; rewrite H; rewrite PM.gso;
    [reflexivity|intro HR; rewrite HR in *; apply Hnd; constructor].
  - simpl in Heval; destruct e.
    apply stmt_eval_Control_fwd in Heval; destruct Heval as [Heval|Heval];
    destruct Heval as [Heval1 Heval2].
    inversion_clear Heval2.
    rewrite <- H3.
    rewrite PM.gso; [reflexivity|].
    intro Hxy; apply Hnd; rewrite Hxy; constructor.
    destruct Heval2 as [Hmenv Henv]; rewrite Henv; intuition.
  - simpl in Heval; destruct e.
    apply stmt_eval_Control_fwd in Heval; destruct Heval as [Heval|Heval];
    destruct Heval as [Heval1 Heval2].
    inversion Heval2; intuition.
    destruct Heval2 as [Hmenv Henv]; rewrite Henv; intuition.
Qed.

Lemma not_Is_defined_in_eq_stmt_eval_env_inv:
  forall prog x eq menv env mems menv' env',
    ~Is_defined_in_eq x eq
    -> stmt_eval prog menv env (translate_eqn mems eq) (menv', env')
    -> PM.find x env' = PM.find x env.
Proof.
  intros prog x eq menv env mems menv' env' Hidi Hstmt.
  apply not_Is_defined_in_eq_not_Is_variable_in_eq in Hidi.
  now apply not_Is_variable_in_eq_stmt_eval_env_inv with (1:=Hidi) (2:=Hstmt).
Qed.

Lemma stmt_eval_translate_eqns_menv_inv:
  forall prog menv env mems eqs menv' env',
    stmt_eval prog menv env (translate_eqns mems eqs) (menv', env')
    -> (forall x, ~Is_defined_in x eqs ->
                  mfind_mem x menv' = mfind_mem x menv).
Proof.
  induction eqs as [ |eq].
  + inversion_clear 1; reflexivity.
  + intros menv' env' Heval x Hnmem.
    apply not_Is_defined_in_cons in Hnmem.
    destruct Hnmem as [H0 H1].
    apply stmt_eval_translate_eqns_cons in Heval.
    destruct Heval as [menv'' [env'' [Heval0 Heval1]]].
    apply IHeqs with (x:=x) (2:=H1) in Heval0.
    apply not_Is_defined_in_eq_stmt_eval_menv_inv with (1:=H0) in Heval1.
    rewrite Heval1, Heval0.
    reflexivity.
Qed.

Lemma stmt_eval_translate_eqns_minst_inv:
  forall prog menv env mems eqs menv' env',
    stmt_eval prog menv env (translate_eqns mems eqs) (menv', env')
    -> (forall x, ~Is_defined_in x eqs ->
                  mfind_inst x menv' = mfind_inst x menv).
Proof.
  induction eqs as [ |eq].
  + inversion_clear 1; reflexivity.
  + intros menv' env' Heval x Hnmem.
    apply not_Is_defined_in_cons in Hnmem.
    destruct Hnmem as [H0 H1].
    apply stmt_eval_translate_eqns_cons in Heval.
    destruct Heval as [menv'' [env'' [Heval0 Heval1]]].
    apply IHeqs with (x:=x) (2:=H1) in Heval0.
    apply not_Is_defined_in_eq_stmt_eval_mobj_inv with (1:=H0) in Heval1.
    rewrite Heval1, Heval0.
    reflexivity.
Qed.

Lemma stmt_eval_translate_eqns_env_inv:
  forall prog menv env mems eqs menv' env',
    stmt_eval prog menv env (translate_eqns mems eqs) (menv', env')
    -> (forall x, ~Is_variable_in x eqs ->
                  PM.find x env' = PM.find x env).
Proof.
  induction eqs as [ |eq].
  + inversion_clear 1; reflexivity.
  + intros menv' env' Heval x Hndef.
    apply not_Is_variable_in_cons in Hndef.
    destruct Hndef as [H0 H1].
    apply stmt_eval_translate_eqns_cons in Heval.
    destruct Heval as [menv'' [env'' [Heval0 Heval1]]].
    apply IHeqs with (x:=x) (2:=H1) in Heval0.
    apply not_Is_variable_in_eq_stmt_eval_env_inv with (1:=H0) in Heval1.
    rewrite Heval1, Heval0.
    reflexivity.
Qed.

Local Ltac split_env_assumption :=
  match goal with
  | Henv: context Is_free_in_lexp [_], Hsem: sem_var_instant _ ?y _
    |- _ => apply Henv in Hsem; [destruct Hsem |solve [auto]]; clear Henv
  | Henv: context Is_free_in_clock [_], Hsem: sem_var_instant _ ?y _
    |- _ => apply Henv in Hsem; [destruct Hsem |solve [auto]]; clear Henv
  end.


Definition equiv_env (Is_free: ident -> Prop) R memories env menv :=
  forall x c, Is_free x
              -> sem_var_instant R x (present c)
              -> (~PS.In x memories -> PM.find x env = Some c)
              /\ (PS.In x memories -> mfind_mem x menv = Some c).

Hint Unfold equiv_env.

(* We often need to weaken an equivalence to a subterm: for example we
know that the environments are equivalent for all [Is_free_caexp x
(AnnExp e ck)], we can deduce that the environements are equivalent
for all [Is_free_exp x e]. *)
Lemma equiv_env_map (Is_free1 Is_free2: ident -> Prop) H memories env menv:
  (forall x, Is_free2 x -> Is_free1 x) ->
  equiv_env Is_free1 H memories env menv -> 
  equiv_env Is_free2 H memories env menv.
Proof.
  intros Hinv Hequiv1 x **; auto.
Qed.

Ltac weaken_equiv_env :=
  match goal with
    | [H: equiv_env ?is_free1 ?R ?mems ?env ?menv 
       |- equiv_env ?is_free2 ?R ?mems ?env ?menv] =>
      eapply equiv_env_map; [|exact H]; constructor(auto)
  end.


Lemma clock_correct_true:
  forall R memories menv env ck,
    equiv_env (fun x => Is_free_in_clock x ck) R memories env menv
    -> sem_clock_instant R ck true
    -> Is_present_in memories menv env ck.
Proof.
  Hint Constructors Is_present_in.
  Hint Constructors sem_clock_instant.
  Hint Constructors Is_free_in_clock.
  Hint Constructors exp_eval.
  intros H memories menv env.
  induction ck as [|? ? x]; [ intuition | ].
  intro Henv.
  inversion_clear 1.
  constructor. apply IHck; auto.
  intros.
  split_env_assumption.
  apply exp_eval_tovar;
    destruct In_dec with x memories;
    intuition.
Qed.

Lemma get_exp_eval_tovar:
  forall x mems menv env v,
    (~ PS.In x mems -> PM.find x env = Some v)
    -> (PS.In x mems -> mfind_mem x menv = Some v)
    -> exp_eval menv env (tovar mems x) v.
Proof.
  intros x mems menv env v Hvar Hmem.
  unfold tovar.
  destruct (In_dec x mems) as [Hin|Hnin].
  - specialize (Hmem Hin).
    apply PS.mem_spec in Hin; rewrite Hin.
    constructor; exact Hmem.
  - specialize (Hvar Hnin).
    apply mem_spec_false in Hnin; rewrite Hnin.
    constructor; exact Hvar.
Qed.

Lemma clock_correct_false:
  forall R memories menv env ck,
    equiv_env (fun x => Is_free_in_clock x ck) R memories env menv
    -> sem_clock_instant R ck false
    -> Is_absent_in memories menv env ck.
Proof.
  Hint Constructors Is_absent_in sem_clock_instant Is_free_in_clock exp_eval.
  intros H memories menv env.
  induction ck as [|? ? x]; [ now inversion 2 | ].
  intro Henv.
  inversion_clear 1.
  constructor; apply IHck; now auto.
  apply clock_correct_true
  with (memories:=memories) (menv:=menv) (env:=env) in H1;
    [|now auto].
  apply IsAbs2 with (1:=H1) (3:=H3).
  split_env_assumption.
  destruct In_dec with x memories as [Hin|Hin];
    match goal with
    | H:~PS.In _ _ -> _, Hin:~PS.In _ _ |- _ => specialize (H Hin)
    | H:PS.In _ _ -> _, Hin:PS.In _ _ |- _ => specialize (H Hin)
    end;
    apply PS.mem_spec in Hin || apply mem_spec_false in Hin;
    unfold tovar;
    rewrite Hin;
    intuition.
Qed.

(** ** Validity of [translate_lexp] *)

Lemma lexp_correct:
  forall R memories menv env c e,
    sem_lexp_instant R e (present c)
    -> equiv_env (fun x => Is_free_in_lexp x e) R memories env menv 
    -> exp_eval menv env (translate_lexp memories e) c.
Proof.
  Hint Constructors exp_eval.
  intros R memories menv env c.
  induction e as [c0|y|e IH y yb];
    inversion 1; intros;
    try apply IH; try apply econst; auto.
  split_env_assumption;
    unfold translate_lexp;
    destruct (PS.mem y memories) eqn:Hm;
    rewrite PS.mem_spec in Hm || rewrite mem_spec_false in Hm;
    auto.
Qed.

(** ** Validity of [translate_laexp] *)

Lemma laexp_correct:
  forall R memories menv env c e,
    sem_laexp_instant R e (present c)
    -> equiv_env (fun x => Is_free_in_laexp x e) R memories env menv
    -> exp_eval menv env (translate_laexp memories e) c.
Proof.
  intros H memories menv env c e Hsem Henv.
  destruct e as [ck ce].
  inversion Hsem as [? ? ? Hlexp|].
  change (exp_eval menv env (translate_lexp memories ce) c).
  eapply lexp_correct; [eassumption | weaken_equiv_env]. 
Qed.

(** ** Validity of [translate_cexp] *)

Lemma cexp_correct:
  forall R memories prog menv env c x e,
    sem_cexp_instant R e (present c)
    -> equiv_env (fun x => Is_free_in_cexp x e) R memories env menv
    -> stmt_eval prog menv env (translate_cexp memories x e)
                                                        (menv, PM.add x c env).
Proof.
  intros R memories prog menv env c x.
  induction e as [b et IHt ef IHf|e].
  - (* Emerge *)
    inversion_clear 1; intro Henv.
    + apply Iifte_true.
      split_env_assumption.
      apply get_exp_eval_tovar; now auto.
      apply IHt; now auto.
    + apply Iifte_false.
      split_env_assumption.
      apply get_exp_eval_tovar; now auto.
      apply IHf; now auto.
  - (* Eexp *)
    inversion_clear 1; intro Henv.
    unfold translate_cexp.
    econstructor.
    eapply lexp_correct; [eassumption|now auto].
    reflexivity.
Qed.

(** ** Validity of [translate_caexp] *)

Lemma caexp_correct:
  forall R memories prog menv env c x e,
    sem_caexp_instant R e (present c)
    -> equiv_env (fun x => Is_free_in_caexp x e) R memories env menv
    -> stmt_eval prog menv env (translate_caexp memories x e)
                                                  (menv, PM.add x c env).
Proof.
  intros H memories prog menv env c x e Hsem Henv.
  destruct e as [ck ce].
  inversion_clear Hsem as [? ? ? Hlexp ?|].
  change (stmt_eval prog menv env (translate_cexp memories x ce)
                     (menv, PM.add x c env)).
  apply cexp_correct with (1:=Hlexp); now auto.
Qed.

(* Notes:
   1. The assumption sem_equations must be shown for a set of equations.
      TODO: lemma showing that a well-typed and well-clocked set of
            equations has a semantics.

   2. The assumption stmt_eval (translate_eqns mems eqs) implies that an
      execution exists and thus that exp_eval's evar and estate find some
      value for each required variable.
      This is somehow backwards; it should be an obligation to show that
      an execution exists. This is something assured indirectly in the
      lemma below where we require not just that evar and estate find
      some value, but also that it is the correct value.
 *)

(** ** More technical lemma! *)

Definition equiv_node G prog f :=
  forall n xs ys M menv input output,
    Memory_Corres G n f M menv 
    -> msem_node G f xs M ys
    -> xs n = present input 
    -> ys n = present output 
    -> exists menv',
         stmt_step_eval prog menv f input menv' output 
     /\  Memory_Corres G (S n) f M menv'.

Definition equiv_prog G prog :=
  forall f,
    equiv_node G prog f.


Lemma Is_memory_in_msem_var:
  forall G H M n x eqs c,
    Is_defined_in x eqs
    -> ~Is_variable_in x eqs
    -> sem_var_instant (restr H n) x (present c)
    -> List.Forall (msem_equation G H M) eqs
    -> (exists ms, mfind_mem x M = Some ms /\ ms n = c).
Proof.
  induction eqs as [|eq eqs IH];
  inversion_clear 1 as [? ? Hidi|? ? Hidi];
  intros Hnvi Hsv Hmsem;
  apply Forall_cons2 in Hmsem;
  apply not_Is_variable_in_cons in Hnvi;
  destruct Hnvi as [Hnvi0 Hnvi1];
  destruct Hmsem as [Hmeq Hmeqs].
  - destruct eq; inversion Hidi; subst;
    try (exfalso; apply Hnvi0; now constructor).
    inversion_clear Hmeq as [| |? ? ? ? ls ? ? ? Hmfind Hms0 Hsemls HxS Hmls].
    exists ms.
    split; [apply Hmfind|].
    specialize Hmls with n; specialize (HxS n); simpl in HxS.
    destruct (ls n);
      destruct Hmls as [Hms Hsv'].
    rewrite Hsv' in HxS.
    + assert (present c = absent) by sem_det; discriminate.
    + cut (present (ms n) = present c); [injection 1; auto|].
      rewrite Hsv' in HxS.
      sem_det.
  - apply IH; assumption.
Qed.


(** ** Validity of [translate_eqns] *)

Section IsStepCorrect.

Variables (G: global)
          (HG: Welldef_global G)
          (H: history)
          (M: memory)
          (mems: PS.t)
          (alleqs : list equation)
          (Hsems: msem_equations G H M alleqs)
          (prog: program)
          (input: ident).


Lemma is_step_correct:
  forall (eqs: list equation)
         (n: nat)
         (menv: heap)
         (env: stack),
        (exists oeqs, alleqs = oeqs ++ eqs)
        -> (forall x, PS.In x mems
                      -> (Is_defined_in x alleqs
                          /\ ~Is_variable_in x alleqs))
        
        (* - input (assumed) *)
        -> (forall c, sem_var_instant (restr H n) input (present c)
                      <-> PM.find input env = Some c)
          (* NB: PM.find x env' = Some c -> sem_var H x n (present c)
                 does not hold if PM.find x env = Some arbitrary_c, since
                 x will not be written to when its clock is absent.

                 It may just be better to show the direction:
                 sem_var H x n (present c) -> PM.find x env' = Some c

                 which is enough if the outputs are only sampled when
                 they are present (normally the case).

                 More discussion/context is needed. *)
        -> (forall x, Is_variable_in x eqs -> PM.find x env = None)
        -> ~PS.In input mems
        -> ~ Is_defined_in input eqs

        (* - execution of translated equations *)
        -> Is_well_sch mems input eqs

        (* - instantiated nodes (assumed) *)
        -> equiv_prog G prog

        (* - unwritten memories (assumed) *)
        -> List.Forall (Memory_Corres_eq G n M menv) alleqs

        (* - locals (shown) *)
        -> (exists menv' env',
               stmt_eval prog menv env (translate_eqns mems eqs) (menv', env')
               /\ (forall x, Is_variable_in x eqs
                             -> forall c : const, sem_var_instant (restr H n) x (present c)
                                                  <-> PM.find x env' = Some c)
               (* - written memories (shown) *)
               /\ List.Forall (Memory_Corres_eq G (S n) M menv') eqs).
Proof.
  (* Induction on equations: translate_eqns [] = Skip *)
  induction eqs as [|eq];
    [ intros; exists menv, env;
      split; [unfold translate_eqns; constructor|];
      split; intros; [ match goal with
                       | H:Is_variable_in _ nil |- _ => inversion H
                       end | now constructor ]| ].
  intros n menv env Hall Hinmems Hin Henv Hin1 Hin2 Hwsch Hnode Hmc.

  assert (exists menv' env',
             stmt_eval prog menv env (translate_eqns mems eqs) (menv', env')
             /\ (forall x, Is_variable_in x eqs
                           -> forall c, sem_var_instant (restr H n) x (present c)
                                        <-> PM.find x env' = Some c)
             /\ List.Forall (Memory_Corres_eq G (S n) M menv') eqs) as IHeqs'.
  { eapply IHeqs.
    - apply List_shift_away with (1:=Hall).
    - exact Hinmems.
    - exact Hin.
    - intros; apply Henv; constructor 2; auto.
    - exact Hin1.
    - apply not_Is_defined_in_cons with (1:=Hin2).
    - apply Is_well_sch_cons with (1:=Hwsch).
    - exact Hnode.
    - exact Hmc. }

  clear IHeqs.
  destruct IHeqs' as [menv' [env' [Hstmt [IHeqs0 IHeqs1]]]].

  destruct Hall as [oeqs Hall].
  assert (Hsems' := Hsems); rewrite Hall in Hsems'.

  apply Forall_app in Hsems'.
  destruct Hsems' as [H0 Hsems']; clear H0.
  apply Forall_cons2 in Hsems'.
  destruct Hsems' as [Hsem Hsems'].

  inversion Hsem as [H0 M0 i xs cae Hvar Hcae HR1 HR2 HR3
                    |H0 M0 y f Mo lae ls xs Hmfind Hlae Hvar Hmsem HR1 HR2 HR3
                    |H0 M0 ms y ls yS v0 lae Hmfind Hms0 Hlae HyS Hvar HR1 HR2 HR3];
    (rewrite <-HR3 in *; clear HR1 HR2 HR3 H0 M0);
    specialize (Hvar n).
  - (* Case EqDef: y = cae *)
    exists menv'. (* the memory does not change *)
    specialize (Hcae n); simpl in *.
    assert (equiv_env (fun x => Is_free_in_caexp x cae) (restr H n) mems env' menv')
      as Hcae'. {
      intros. 
      split; intro Hmems.

      - assert (Hdecide_x: Is_variable_in x eqs \/ x = input)
          by (eapply Is_well_sch_free_variable;
              eassumption || constructor (assumption)). 

        destruct Hdecide_x; try subst x.
        + apply IHeqs0; assumption.
        + erewrite stmt_eval_translate_eqns_env_inv; try eassumption.
          apply Hin; assumption.
          apply not_Is_defined_in_not_Is_variable_in.
          apply not_Is_defined_in_cons in Hin2; destruct Hin2; assumption.
          
      - assert (~ Is_defined_in x eqs) 
          by (eapply Is_well_sch_free_variable_in_mems; 
              eassumption || constructor (assumption)).
        specialize (Hinmems _ Hmems); destruct Hinmems.
        erewrite stmt_eval_translate_eqns_menv_inv; try eassumption.
        eapply Is_memory_in_msem_var in H1; try eassumption. do 2 destruct H1; subst c.
        assert (Is_defined_in x alleqs) by intuition.
        assert (~ Is_variable_in x alleqs) by intuition.
        erewrite Is_memory_in_Memory_Corres_eqs; try eauto.
    }

    destruct (xs n).
    + (* xs n = absent *)
      exists env'.
      inversion Hcae as [|? ? Hcexp Hclk HR1 HR2];
        rewrite <-HR1 in *; clear HR1 HR2 .
      split; [|split].
      * apply stmt_eval_translate_eqns_cons.
        exists menv', env'.
        split; [exact Hstmt|].
        apply stmt_eval_Control_absent.
        eapply clock_correct_false; eauto. 
      * intros x0 Hivi c.
        (* TODO: do we really need this [destruct]? It seems that we *know* that it cannot be a variable (proof by [contradiction]/[discriminate]).
                 If not, remove dependency on [Dataflow.IsVariable.Decide] *)
        destruct (Is_variable_in_dec x0 eqs) as [Hvin|Hvin];
          [now apply IHeqs0 with (1:=Hvin)|].
        apply stmt_eval_translate_eqns_env_inv with (2:=Hvin) in Hstmt.
        rewrite Hstmt.
        inversion_clear Hivi as [? ? Hivi'|];
          [|unfold Is_variable_in in Hvin; contradiction].
        inversion_clear Hivi'.
        split; intro Hsv'.
        assert (present c = absent) by sem_det. discriminate.
        assert (PM.find i env = None).
        apply Henv; now repeat constructor.
        rewrite Hsv' in *; discriminate.
      * rewrite Hall in Hmc.
        apply Forall_app in Hmc; destruct Hmc as [Hmc0 Hmc]; clear Hmc0.
        apply Forall_cons2 in Hmc; destruct Hmc as [Hmc Hmc0]; clear Hmc0.
        inversion_clear Hmc.
        repeat constructor; assumption.
    + (* xs n = present *)
      exists (PM.add i v env').
      inversion Hcae as [? ? ? Hcexp Hclk HR1 HR2|];
        rewrite <-HR1 in *; clear HR1 HR2 c.
      split; [|split].
      * apply stmt_eval_translate_eqns_cons.
        exists menv', env'.
        split; [exact Hstmt|].
        apply stmt_eval_Control_present.
        apply clock_correct_true with (2:=Hclk); now auto.
        apply cexp_correct with (1:=Hcexp); now auto.
      * intros x0 Hivi c.
        inversion_clear Hivi as [? ? Hivi'|]; [inversion_clear Hivi'|].
        { rewrite PM.gss; split; intro HH.
          - assert (c = v) by
              (cut (present c = present v); [injection 1; auto|];
               sem_det).
            congruence.
          - injection HH; intro Heq. subst. assumption. }
        { destruct (ident_eq_dec x0 i) as [Hxy|Hnxy].
          - rewrite Hxy in *; clear Hxy.
            rewrite PM.gss.
            split; intro Hsv'.
            * assert (v = c) 
                by (cut (present v = present c); [injection 1; auto|]; sem_det).
              congruence.
            * injection Hsv'; congruence.
          - erewrite PM.gso; try eassumption.
            apply IHeqs0; assumption.  
        }
      * rewrite Hall in Hmc.
        apply Forall_app in Hmc; destruct Hmc as [Hmc0 Hmc]; clear Hmc0.
        apply Forall_cons2 in Hmc; destruct Hmc as [Hmc Hmc0]; clear Hmc0.
        inversion_clear Hmc.
        repeat constructor; assumption.
  - (* Case EqApp: y = f lae *)
    specialize (Hlae n).
    (* used variables are defined *)
    assert (equiv_env (fun x => Is_free_in_laexp x lae) (restr H n) mems env' menv')
      as Hlae'. {
      intros.
      split; intro Hmems.

      - assert (Hdecide_x: Is_variable_in x eqs \/ x = input) 
          by (eapply Is_well_sch_free_variable;
              eassumption || constructor (assumption)). 

        destruct Hdecide_x; try subst x.
        + apply IHeqs0; assumption.
        + erewrite stmt_eval_translate_eqns_env_inv; try eassumption.
          apply Hin; assumption.
          apply not_Is_defined_in_not_Is_variable_in.
          apply not_Is_defined_in_cons in Hin2; destruct Hin2; assumption.
          
      - assert (~ Is_defined_in x eqs) 
          by (eapply Is_well_sch_free_variable_in_mems; 
              eassumption || constructor (assumption)).
        specialize (Hinmems _ Hmems); destruct Hinmems.
        erewrite stmt_eval_translate_eqns_menv_inv; try eassumption.
        eapply Is_memory_in_msem_var in H1; try eassumption. do 2 destruct H1; subst c.
        assert (Is_defined_in x alleqs) by intuition.
        assert (~ Is_variable_in x alleqs) by intuition.
        erewrite Is_memory_in_Memory_Corres_eqs; try eauto.
    }

    (* memory correspondence before execution *)
    rewrite Hall in Hmc.
    apply Forall_app in Hmc.
    destruct Hmc as [Hmc0 Hmc]; clear Hmc0.
    apply Forall_cons2 in Hmc.
    destruct Hmc as [Hmceq Hmceqs].
    inversion_clear Hmceq as [|? ? ? ? ? Hmc0|].
    specialize (Hmc0 _ Hmfind).
    destruct Hmc0 as [omenv [Hfindo Hmc0]].
    (* dataflow semantics *)
    assert (Hmsem':=Hmsem).
    inversion_clear Hmsem' as [? ? ? ? i o neqs Hfind Hnsem].
    destruct Hnsem as [Hn [Hlsn [Hxsn [Habs [Hout Hnsem]]]]].
    specialize (Hlsn n);
      specialize (Hxsn n);
      specialize (Habs n);
      specialize (Hout n); 
      simpl in *.
    (* no other instance *)
    assert (~Is_defined_in y eqs) as Hniii
        by (inversion_clear Hwsch; assumption).
    destruct (ls n) eqn:Hls.
    + (* y = absent *)
      exists menv', env'.
      specialize (Habs (eq_refl absent)).
      assert (xs n = absent) as Hout'
          by (apply Hout; reflexivity); clear Hout.
      inversion Hlae as [|? ? Hlexp Hclk HR1 HR2];
        rewrite <-HR1 in *; clear HR1 HR2.
      split; [|split].
      * apply stmt_eval_translate_eqns_cons.
        exists menv', env'.
        split; [exact Hstmt|].
        apply stmt_eval_Control_absent.
        apply clock_correct_false with (2:=Hclk); now auto.
      * intros x Hivi c.
        destruct (Is_variable_in_dec x eqs) as [Hvin|Hvin];
          [now apply IHeqs0 with (1:=Hvin)|].
        apply stmt_eval_translate_eqns_env_inv with (2:=Hvin) in Hstmt.
        rewrite Hstmt.
        inversion_clear Hivi as [? ? Hivi'|];
          [|unfold Is_variable_in in Hvin; contradiction].
        inversion Hivi' as [|x' f' e HR1 [HR2 HR3 HR4]];
          rewrite HR2 in *; clear HR1 HR2 HR3 HR4 x' f' e Hivi'.
        split; intro Hsv'.
        { inversion_clear Hsv' as [Hfind'].
          inversion_clear Hvar as [Hfind''].
          rewrite Hfind' in Hfind''.
          injection Hfind''; intro HR1; rewrite <-HR1 in *; clear HR1 Hfind''.
          discriminate. }
        { assert (PM.find y env = None) as Hnone
              by (apply Henv; repeat constructor).
          rewrite Hnone in Hsv'.
          discriminate. }
      * apply Forall_cons; [|now apply IHeqs1].
        constructor.
        intros Mo' Hmfind'.
        rewrite Hmfind in Hmfind'.
        injection Hmfind'; intro He; rewrite <-He in *; clear He Hmfind'.
        exists omenv.
        rewrite stmt_eval_translate_eqns_minst_inv with (1:=Hstmt) (2:=Hniii).
        split; [exact Hfindo|].
        now apply Memory_Corres_unchanged
        with (2:=Hmsem) (3:=Hls) (4:=Hmc0).
    + (* y = present *)
      assert (xs n <> absent) as Hxsp
          by (intro HH; apply Hout in HH; discriminate).
      apply not_absent_present in Hxsp.
      destruct Hxsp as [c Hxsc].
      rewrite Hxsc in *.

      rename v into inValue. rename c into outValue.
      
      assert (exists menv' : heap,
                stmt_step_eval prog omenv  f inValue menv' outValue
             /\ Memory_Corres G (S n) f Mo menv') as Hclass
             by (eapply Hnode; try eassumption).
      destruct Hclass as [omenv' [Hnstmt Hnmc]].

      simpl in *.
      exists (madd_obj y omenv' menv'), (PM.add y outValue env'). 
      inversion Hlae as [? ? c0 Hlexp Hclk HR1 HR2|];
        rewrite <-HR1 in *; clear HR1 HR2 c0.
      split;[|split].
      * apply stmt_eval_translate_eqns_cons.
        exists menv', env'.
        split; [exact Hstmt|].
        apply stmt_eval_Control_present.
        apply clock_correct_true with (2:=Hclk); now auto.
        apply lexp_correct
        with (memories:=mems) (menv:=menv') (env:=env') in Hlexp;
          [|now auto].
        rewrite <-stmt_eval_translate_eqns_minst_inv
        with (1:=Hstmt) (2:=Hniii) in Hfindo.
        eapply Istep; eauto.
      * {
          intros x Hivi c.
          apply Is_variable_in_cons in Hivi.
          destruct Hivi as [Hivi | [notxy Hivi] ].
          - (* x = y *)
            inversion_clear Hivi.
            rewrite PM.gss. split; intro HH.
            + assert (present c = present outValue) by sem_det.
              congruence.
            + injection HH. intro Heq; rewrite <-Heq.
              apply Hvar.
          - (* x <> y *)
             not_Is_variable x y.
             rewrite PM.gso; [|assumption].
             apply IHeqs0; assumption.
        }
      * apply Forall_cons.
        2:now apply Memory_Corres_eqs_add_obj with (1:=IHeqs1) (2:=Hniii).
        constructor.
        intros Mo' Hmfind'.
        rewrite Hmfind in Hmfind'.
        injection Hmfind'; intro Heq; rewrite <-Heq in *; clear Heq Hmfind'.
        exists omenv'.
        split; [rewrite mfind_inst_gss; reflexivity|exact Hnmc].
  - (* Case EqFby: y = v0 fby lae *)
    specialize (Hlae n).
    assert (equiv_env (fun x => Is_free_in_laexp x lae) (restr H n) mems env' menv')
      as Hlae'. {
      intros.
      split; intro Hmems.

      - assert (Hdecide_x: Is_variable_in x eqs \/ x = input) 
          by (eapply Is_well_sch_free_variable;
              eassumption || constructor (assumption)). 

        destruct Hdecide_x; try subst x.
        + apply IHeqs0; assumption.
        + erewrite stmt_eval_translate_eqns_env_inv; try eassumption.
          apply Hin; assumption.
          apply not_Is_defined_in_not_Is_variable_in.
          apply not_Is_defined_in_cons in Hin2; destruct Hin2; assumption.
          
      - assert (~ Is_defined_in x eqs) 
          by (eapply Is_well_sch_free_variable_in_mems; 
              eassumption || constructor (assumption)).
        specialize (Hinmems _ Hmems); destruct Hinmems.
        erewrite stmt_eval_translate_eqns_menv_inv; try eassumption.
        eapply Is_memory_in_msem_var in H1; try eassumption. do 2 destruct H1; subst c.
        assert (Is_defined_in x alleqs) by intuition.
        assert (~ Is_variable_in x alleqs) by intuition.
        erewrite Is_memory_in_Memory_Corres_eqs; try eauto.
    }

    destruct (ls n) eqn:Hls;
      destruct Hvar as [Hms Hvar].
    + (* y = absent *)
      exists menv', env'.
      inversion Hlae as [|? ? Hlexp Hclk HR1 HR2];
        rewrite <-HR1 in *; clear HR1 HR2.
      split; [|split].
      * apply stmt_eval_translate_eqns_cons.
        exists menv', env'.
        split; [exact Hstmt|].
        apply stmt_eval_Control_absent.
        apply clock_correct_false with (2:=Hclk); now auto.
      * intros x Hivi c.
        destruct (Is_variable_in_dec x eqs) as [Hvin|Hvin];
          [now apply IHeqs0 with (1:=Hvin)|].
        apply stmt_eval_translate_eqns_env_inv with (2:=Hvin) in Hstmt.
        rewrite Hstmt.
        inversion_clear Hivi as [? ? Hivi'|];
          [|unfold Is_variable_in in Hvin; contradiction].
        inversion_clear Hivi'.
      * constructor.
        2:assumption.
        constructor.
        intros ms0' Hmfind'.
        rewrite Hmfind in Hmfind'.
        injection Hmfind'; intro Heq; rewrite <-Heq in *; clear Heq Hmfind'.
        (* TODO: do we really need this? We seem to *know* that it
        cannot be equal ([exfalso] branch).

                 If unnecessary, remove the import on Dataflow.IsDefined.Decide *)
        destruct (Is_defined_in_dec y eqs) as [Hxin|Hxin];
          [ exfalso; inversion_clear Hwsch; now intuition|].
        rewrite Hall in Hmc.
        apply Forall_app in Hmc.
        destruct Hmc as [H0 Hmc]; clear H0.
        apply Forall_cons2 in Hmc.
        destruct Hmc as [Hmc H0]; clear H0.
        inversion_clear Hmc as [| |? ? ? ? ? Hfindc].
        rewrite Hms.
        apply stmt_eval_translate_eqns_menv_inv with (2:=Hxin) in Hstmt.
        rewrite Hstmt.
        apply Hfindc with (1:=Hmfind).
    + (* y = present *)
      exists (madd_mem y v menv'), env'.
      inversion Hlae as [? ? v' Hlexp Hclk HR1 HR2|];
        rewrite <-HR1 in *; clear HR1 HR2 v'.
      split; [|split].
      * apply stmt_eval_translate_eqns_cons.
        exists menv', env'.
        split; [exact Hstmt|].
        apply stmt_eval_Control_present.
        apply clock_correct_true with (2:=Hclk); now auto.
        econstructor.
        apply lexp_correct with (1:=Hlexp); now auto.
        reflexivity.
      * intros x Hivi c.
        inversion_clear Hivi as [? ? Hivi'|]; [now inversion_clear Hivi'|].
        apply IHeqs0.
        assumption.
      * rewrite <-Hms.
        apply Forall_cons.
        2:now apply Memory_Corres_eqs_add_mem with (1:=Hmfind) (2:=IHeqs1).
        constructor.
        intros ms' Hmfind'.
        rewrite Hmfind in Hmfind'.
        injection Hmfind'; intro Heq; rewrite <-Heq in *; clear Hmfind' Heq.
        now apply mfind_mem_gss.
Qed.

End IsStepCorrect.

Section IsNodeCorrect.


Lemma equiv_prog_empty: equiv_prog [] (translate []).
Proof.
  intro Hwdef. 
  intros n **.
  exfalso.
  repeat match goal with 
      | H: msem_node [] _ _ _ _ |- _ => inversion H; clear H
      | H: find_node _ [] = Some _ |- _ => inversion H; clear H
         end.
Qed.

Lemma is_node_correct:
  forall (G: global), 
    Welldef_global G ->
    equiv_prog G (translate G).
Proof.
  (* TODO: Develop a version of msem_node_mult that works for eqs? *)
  induction G as [|node G IH].
  - intro; apply equiv_prog_empty.
  - intros Hwd f n xs ys M menv input output Hmc Hmsem Hxs Hys.
    set (nodeName := n_name node).

    assert (Welldef_global G) as HwdG 
        by (eapply Welldef_global_cons; eassumption).

    assert (Ordered_nodes (node::G)) as Hord
        by (apply Welldef_global_Ordered_nodes; assumption).

    destruct (ident_eqb nodeName f) eqn:Hfeq.
    + (* Case: f = nodeName *)
      assert (nodeName = f)
        by (apply Pos.eqb_eq; assumption). 
      subst f.
      
      set (prog := translate (node :: G)).

      inversion_clear Hwd as [|? ? Hwd' eqs inArg outArg 
                               Hwsch Hndef_in Hdef_out Hnnode Hfind Hnodup].
      clear Hwd'.
      inversion_clear Hmsem as [? ? ? ? ? ? ? Heqs
                                [H [Hin [Hout [Hrabs [Habs Hall]]]]]].
      subst eqs inArg outArg nodeName.
      simpl in Heqs; rewrite Hfeq in Heqs; simpl in Heqs.
      injection Heqs. intro Hnode. rewrite Hnode in *. clear Heqs. simpl in *.

      rename i into inArg; rename o into outArg; rename eqs0 into eqs.

      set (env := PM.add inArg input sempty).

      assert (msem_equations G H M eqs)
        by (eapply Forall_msem_equation_global_tl; try eassumption).

      assert (exists (menv' : heap) (env' : stack),
                stmt_eval (translate G) menv env (translate_eqns (memories eqs) eqs) (menv', env') /\
                (forall x : ident,
                   Is_variable_in x eqs ->
                   forall c : const,
                     sem_var_instant (restr H n) x (present c) <->
                     PM.find x env' = Some c) /\
                Forall (Memory_Corres_eq G (S n) M menv') eqs) as His_step_correct.
      {
        eapply is_step_correct; try eassumption.
        - exists []; auto.
        - intros y Hinm.
          assert (NoDup_defs eqs) as Hndds
              by (eapply Is_well_sch_NoDup_defs; eauto).
          split; [now apply Is_defined_in_memories
                 |now apply not_Is_variable_in_memories].
        - intro c.
          specialize (Hin n); simpl in Hin.
          split; intro HH.
          + assert (Hxs_pres: c = input)
              by (cut (xs n = present c);
                  [ intro Hxsc; rewrite Hxsc in Hxs; injection Hxs; auto
                  | sem_det]).
            rewrite Hxs_pres in *.
            subst env; apply PM.gss.
          + subst env. rewrite PM.gss in HH. injection HH; intro HR1.
            rewrite Hxs in Hin; rewrite HR1 in *. 
            assumption.      
        - intros x Hivi.
          subst env.
          rewrite PM.gso; [rewrite PM.gempty;reflexivity|].
          apply Is_variable_in_Is_defined_in in Hivi.
          intro Hx; rewrite Hx in *.
          contradiction.
        - intro HinArg.
          apply Is_defined_in_memories in HinArg.
          contradiction.
        - eapply IH; assumption.
        - inversion_clear Hmc as [? ? ? ? ? ? Hf Hmeqs].

          simpl in Hf.
          rewrite ident_eqb_refl in Hf.
          injection Hf; intros Heq0 Heq1 Heq2;
          rewrite <-Heq0, <-Heq1, <-Heq2 in *;
          clear Heq0 Heq1 Heq2 Hf.
          
          eapply Memory_Corres_eqs_node_tl; try eassumption.
      }

      destruct His_step_correct as [menv' [env' [Hstmt [Hsemvar Hmem]]]].
      exists menv'.
      split.
      * {
          econstructor.
          - simpl. rewrite Pos.eqb_refl. reflexivity.
          - subst env. simpl.
            assert (inArg = n_input node)
              by (rewrite Hnode; auto).
            assert (eqs = n_eqs node) 
              by (rewrite Hnode; auto).
            subst inArg; subst eqs.
            rewrite ps_from_list_gather_eqs_memories. eapply Hstmt.
          - assert (outArg = n_output node)
              by (rewrite Hnode; auto).
            subst outArg.
            specialize (Hout n); simpl in Hout; rewrite Hys in Hout.
            simpl. apply Hsemvar; try assumption.
        }
      * { 
          econstructor.
          - simpl; rewrite Pos.eqb_refl; reflexivity.
          - eapply Memory_Corres_eqs_node_tl; eassumption.
        }

    + (* Case: f <> nodeName *)
      assert (nodeName <> f) as Hfneq
          by (eapply Pos.eqb_neq; try eassumption).

      rewrite Memory_Corres_node_tl in Hmc; try eassumption.
      apply msem_node_cons in Hmsem; try eassumption.
      eapply IH in HwdG.
      edestruct HwdG as [menv' [Hstmt' Hmc']]; try eassumption.
      inversion_clear Hstmt'.
      exists menv'; split.
      * econstructor; try eassumption.
        simpl; subst nodeName; rewrite Hfeq.
        eassumption.
      * rewrite Memory_Corres_node_tl; try assumption.
Qed.

(** ** Validity of the [reset] code *)

(* TODO: remove after rewrite of translate_reset_eqns *)
Lemma stmt_eval_translate_reset_eqn_shift:
  forall prog eqs iacc menv env menv' env',
    stmt_eval prog menv env
              (List.fold_left translate_reset_eqn eqs iacc)
              (menv', env')
    <->
    exists menv'' env'',
      stmt_eval prog menv env
                (List.fold_left translate_reset_eqn eqs Skip)
                (menv'', env'')
      /\
      stmt_eval prog menv'' env'' iacc (menv', env').
Proof.
  Hint Constructors stmt_eval.
  induction eqs as [|eq eqs IH].
  - split; [ now eauto | ].
    intro H; do 2 destruct H.
    destruct H as [H0 H1].
    inversion_clear H0; apply H1.
  - intros.
    split.
    + intro H0.
      apply IH in H0.
      destruct H0 as [menv'' [env'' [H0 H1]]].
      destruct eq; [now eauto| |];
      inversion_clear H1;
      exists menv1; exists env1;
      split; try (simpl; apply IH); eauto.
    + intros.
      destruct eq; [ now (apply IH; auto) | |];
      (apply IH;
       simpl in H;
       destruct H as [menv'' [env'' [H0 H1]]];
       apply IH in H0;
       destruct H0 as [menv0 [env0 [H2 H3]]];
       exists menv0; exists env0;
       split; [now auto|];
       inversion_clear H3;
       inversion H0; subst;
       econstructor; eauto).
Qed.

Lemma stmt_eval_translate_reset_eqns_cons:
  forall prog menv env (eq:equation) eqs P,
    (exists menv'' env'',
        stmt_eval prog menv env
                  (translate_reset_eqns (eq :: eqs)) (menv'', env'')
        /\ P menv'' env'')
    <->
    (exists menv' env' menv'' env'',
        stmt_eval prog menv env (translate_reset_eqns eqs) (menv', env')
        /\ stmt_eval prog menv' env'
                     (translate_reset_eqn Skip eq) (menv'', env'')
        /\ P menv'' env'').
Proof.
  split.
  - intro H.
    destruct H as [menv'' [env'' H]].
    unfold translate_reset_eqns in H.
    simpl in H.
    destruct H as [H HP].
    apply stmt_eval_translate_reset_eqn_shift in H.
    destruct H as [menv' [env' [H1 H2]]].
    exists menv', env', menv'', env''.
    now intuition.
  - intro H.
    destruct H as [menv' [env' [menv'' [env'' [H1 [H2 HP]]]]]].
    unfold translate_reset_eqns.
    simpl.
    exists menv'', env''.
    intuition.
    apply stmt_eval_translate_reset_eqn_shift.
    exists menv', env'.
    intuition.
Qed.

(* TODO: rework using (a simplified version of) msem_node_mult *)
(* This lemma is stated with Welldef_global rather than simply Ordered_nodes
   since the former gives Is_well_sch for each set of node equations within
   the global environment. In turn, Is_well_sch guarantees that any EqApp
   equation is unique, i.e., given x = EqApp f e, there is no other instance
   of x. This greatly simplifies the induction where it must be shown from

   that

   The case of EqFby is simpler due to the lemma Memory_Corres_eqs_add_mem.
   The comment following this lemma explains why there can be no corresponding
   Memory_Corres_eqs_add_obj lemma. *)

Definition equiv_reset G prog f :=
  forall xs ys M,
    msem_node G f xs M ys 
    -> exists menv',
         stmt_reset_eval prog f menv'
      /\ Memory_Corres G 0 f M menv'.

(* TODO: remove/factorize with equiv_prog *)
Lemma equiv_reset_empty: forall f, equiv_reset [] (translate []) f.
Proof.
  intro Hwdef. 
  intros n **.
  exfalso.
  repeat match goal with 
      | H: msem_node [] _ _ _ _ |- _ => inversion H; clear H
      | H: find_node _ [] = Some _ |- _ => inversion H; clear H
         end.
Qed.

Section IsResetCorrect.

Variables (G: global)
          (HG: Welldef_global G)
          (H: history)
          (M: memory)
          (mems: PS.t)
          (input: ident).


Lemma is_reset_correct:
  forall eqs, 
    msem_equations G H M eqs ->
    Is_well_sch mems input eqs ->
    (forall f, equiv_reset G (translate G) f) ->
  exists menv' env',
    stmt_eval (translate G) hempty sempty (translate_reset_eqns eqs)
              (menv', env')
    /\ Forall (Memory_Corres_eq G 0 M menv') eqs.
Proof.
  intros eqs Hmsem Hwsch Hreset.
  induction eqs as [|eq eqs IH]; [eauto|].
  destruct eq as [i e|i f e|i v e];
  inversion_clear Hmsem as [| ? ? Hsem Hmsem' ];
  inversion_clear Hwsch;
  edestruct IH as [menv' [env' [Hstmt Hmc]]]; try eassumption.
  - (* EqDef *)
    Hint Constructors Forall.
    Hint Constructors Memory_Corres_eq.
    eauto.
  - (* EqApp *)
    unfold translate_reset_eqns; simpl.
    inversion_clear Hsem as [|? ? ? ? Mo ? xs' ys' Hmfind Hxs' Hys' HsemNode|].
    assert (exists omenv, stmt_reset_eval (translate G) f omenv 
                       /\ Memory_Corres G 0 f Mo omenv) as [omenv [Hstmt_reset Hmcf]]
      by (eapply Hreset; try eassumption).
    
    exists (madd_obj i omenv menv'), env'.
    split.
    + rewrite stmt_eval_translate_reset_eqn_shift.
      exists menv', env'.
      split; try assumption.
      econstructor; [|constructor].
      econstructor; auto.
      assumption.
    + repeat constructor; [| apply Memory_Corres_eqs_add_obj; assumption].
      intros M' Hmfind'.
      rewrite Hmfind in Hmfind'; injection Hmfind'; intro Heq; subst M'.
      exists omenv.
      rewrite mfind_inst_gss.
      auto.
  - (* EqFby *)
    exists (madd_mem i v menv'), env'.
    split.
    + unfold translate_reset_eqns; simpl;
        rewrite stmt_eval_translate_reset_eqn_shift.
      exists menv', env'.
      Hint Constructors stmt_eval.
      eauto.
    + inversion_clear Hsem as [| | ? ? ? ? ? ? ? ? Hmfind Hms Hlae Hls]. 
      rewrite <- Hms.
      constructor; [|apply Memory_Corres_eqs_add_mem; assumption].
      constructor. intros ms' Hmfind'.
      rewrite Hmfind in Hmfind'.
      injection Hmfind'; intro HR; rewrite HR in *; clear HR Hmfind'.
      rewrite mfind_mem_gss.
      reflexivity.
Qed.

End IsResetCorrect.

Lemma is_node_reset_correct:
  forall (G: global) f,
         Welldef_global G ->
         equiv_reset G (translate G) f.
Proof.
  induction G as [|node G IH].
  - intros f Hwd.
    apply equiv_reset_empty.
  - intros f Hwdef xs ys M Hmsem.

    assert (Ordered_nodes (node :: G)) as HordG
      by (apply Welldef_global_Ordered_nodes; assumption).
    
    set (nodeName := n_name node).

    destruct (ident_eqb nodeName f) eqn:Heqb.
    + assert (nodeName = f) as Hfeq 
        by (apply Pos.eqb_eq; assumption).

      inversion_clear Hmsem as [? ? ? ? inArg outArg eqs Hfind 
                                [H [Hin [Hout [Hrhs [Habs Hmsem']]]]]].
      rename Hmsem' into Hmsem.

      specialize (Hin 0)%nat; specialize (Hout 0)%nat;
        simpl in Hin, Hout.

      simpl in Hfind; subst nodeName; rewrite Heqb in Hfind; 
      injection Hfind; clear Hfind; intro Hfind. 

      assert (msem_equations G H M eqs).
      {
        inversion_clear Hwdef. subst eqs0; rewrite Hfind in *; simpl in *.
        eapply Forall_msem_equation_global_tl; try eassumption.
      }

      assert (Is_well_sch (memories eqs) inArg eqs)
        by (inversion Hwdef; subst ni eqs0;
            rewrite Hfind in *; simpl in *; assumption).

      assert (Welldef_global G) 
        by (inversion Hwdef; assumption).

      assert (exists menv' env',
             stmt_eval (translate G) hempty sempty (translate_reset_eqns eqs)
                       (menv', env')
             /\ Forall (Memory_Corres_eq G 0 M menv') eqs) 
        as [menv' [env' [Hstmt Hmc]]].
      {
        eapply is_reset_correct; try eassumption.
        intro; apply IH; assumption.
      }
      
      exists menv'.
      split.
      * { 
          econstructor. 
          - simpl. rewrite Heqb. reflexivity.
          - subst node; eassumption.
        }
      * { 
          econstructor.
          - simpl; rewrite Heqb. subst node. reflexivity.
          - apply Memory_Corres_eqs_node_tl; try assumption.
            inversion Hwdef. subst eqs0. rewrite Hfind in *. simpl. assumption.
        }

    + assert (nodeName <> f) as Hfneq
        by (apply Pos.eqb_neq; assumption).

      apply Welldef_global_cons in Hwdef.
      apply msem_node_cons in Hmsem; try assumption.
      edestruct IH as [menv' [Hstmt Hmc]]; try eassumption.
      exists menv'; split.
      * inversion_clear Hstmt.
        econstructor; try eassumption.
        simpl. subst nodeName; rewrite Heqb. assumption.
      * apply Memory_Corres_node_tl; eassumption.
Qed.

(** ** Validity of the whole translation *)

Lemma is_translate_correct:
  forall (G: global)
         (f: ident)
         (xs: stream value)
         (ys: stream value)
         (ci: const)
         (r: ident)
         (obj: ident)
         (n: nat),
    Welldef_global G
    -> sem_node G f xs ys
    -> (forall n, xs n = present ci)
    -> (exists menv env,
           stmt_eval (translate G) hempty sempty
             (Comp (Reset_ap f obj)
                   (Repeat (S n) (Step_ap r f obj (Const ci)))) (menv, env)
           /\ (forall co, ys n = present co <-> PM.find r env = Some co)).
Proof.
  intros until n.
  intros Hwdef Hsem Hxs.
  apply sem_msem_node with (1:=Hwdef) in Hsem.
  destruct Hsem as [M Hmsem].
  assert(Hmsem':=Hmsem).
  inversion_clear Hmsem' as [? ? ? ? ? ? ? Hfindn Hmsem''].
  destruct Hmsem'' as [H [Hi [Ho [Hclk [Habs Hmsem']]]]].

  assert (exists menv0,
            stmt_reset_eval (translate G) f menv0
         /\ Memory_Corres G 0 f M menv0) as [menv0 [Hstmtr Hmc0]]
      by (eapply is_node_reset_correct; try eassumption).

  (* TODO: extract as a standalone lemma *)
  assert (forall n, 
          exists menvN omenvN envN,
            stmt_eval (translate G) (madd_obj obj menv0 hempty) sempty
                      (Repeat (S n) (Step_ap r f obj (Const ci)))
                      (menvN, envN)
            /\ mfind_inst obj menvN = Some omenvN
            /\ Memory_Corres G (S n) f M omenvN
            /\ (forall co, ys n = present co <-> PM.find r envN = Some co)).
  {

    induction 0.
    - specialize Hxs with 0%nat.

      assert (exists co0, ys 0 = present co0)%nat as [co0 Hco0]
             by (apply not_absent_present; rewrite <- Habs; congruence).

      assert (exists menv,
              stmt_step_eval (translate G) menv0 f ci menv co0
              /\  Memory_Corres G 1 f M menv) as [menv1 [Hstmt1 Hmem1]]
        by (eapply is_node_correct; try eassumption).

      do 3 eexists.
      split; [|split; [| split]]; try eauto.
      + econstructor; [econstructor|].
        econstructor; try eauto.        
        apply mfind_inst_gss.
      + apply mfind_inst_gss.
      + rewrite Hco0, PM.gss. intuition; congruence.

    - destruct IHn0 as [menv' [omenv' [env' [Hstmt [Hfind [Hmc _]]]]]].

      assert (exists coSn, ys (S n0) = present coSn) as [coSn Hys] 
          by (apply not_absent_present; rewrite <- Habs; congruence).

      assert (exists omenv'',
                stmt_step_eval (translate G) omenv' f ci omenv'' coSn
            /\  Memory_Corres G (S (S n0)) f M omenv'') as [omenvSn [HstmtSn HmemSn]]
        by (specialize Hxs with (S n0); eapply is_node_correct; try eassumption).

      do 3 eexists. 
      split; [|split; [| split]]; try eauto.
      + rewrite mfind_inst_gss; auto.
      + rewrite Hys, PM.gss. intuition; congruence.
  }

  edestruct H0 as [menv [omenv [env [Hstmt [Hfind [Hmc Hpres]]]]]].

  exists menv, env.
  split; try eassumption.
  econstructor; try eassumption.
  econstructor; try eauto.
Qed.

