(* kind2-mc/cocospec_tcm_experiments/systems/cocospec_mono_system.lus
   2015 Adrien Champion *)

-- This file has been generated by CocoSim compiler + verifier

node max(fst, snd: real) returns (out: real) ;
let
  out = if fst >= snd then fst else snd ;
tel

node min(fst, snd: real) returns (out: real) ;
let
  out = if fst <= snd then fst else snd ;
tel

node duration(in: bool) returns (out: int) ;
var always_true: bool ;
let
  always_true = in -> in and (pre always_true) ;
  out = if always_true then (1 -> pre out + 1) else 0 ;
tel

node fall(in: bool) returns (out: bool) ;
let
  out = false -> (not in) and pre in ;
tel

node rise(in: bool) returns (out: bool) ;
let
  out = false -> in and pre not in ;
tel

node count(in: bool) returns (out: int) ;
let
  out = if in then (1 -> pre out + 1) else 0 ;
tel

node count_succ_true(in: bool) returns (out: int) ;
let
  out = if in then (1 -> pre out + 1) else 0 ;
tel

node count_true_since(in, reset: bool) returns (out: int) ;
let
  out = if reset then 0 else if in then 0 -> pre out + 1 else 0 -> pre out ;
tel

node has_been_true(in: bool) returns (out: bool) ;
let
  out = in -> in or pre out ;
tel

node has_been_true_reset(in, reset: bool) returns (out: bool) ;
let
  out = (in -> (in or pre out)) and not reset ;
tel

node spike_or_confirmed(in: bool ; const count: int ; reset: bool)
returns (out: bool) ;
let
  out = (in and not reset) or has_been_true_reset(since(in) = count, reset) ;
tel

node before_lt(max: int) returns (out: bool) ;
let
  out = duration(true) < max ;
tel

node after_ge(min: int) returns (out: bool) ;
let
  out = duration(true) >= min ;
tel

node since(in: bool) returns (out: int) ;
let
  out = (if in then 1 else 0) -> ( if in then pre out + 1 else 0 ) ;
tel

node since_le_not_0(in: bool; const max: int) returns (out: bool) ;
var sinc3: int ;
let
  sinc3 = since(in) ;
  out = (0 < sinc3) and (sinc3 <= max) ;
tel

node since_gt_or_0(in: bool; const min: int) returns (out: bool) ;
var sinc3: int ;
let
  sinc3 = since(in) ;
  out = (0 = sinc3) or (sinc3 > min) ;
tel

node lasted(in: bool) returns (out: int) ;
let
  out = (if in then 1 else 0) -> (
    if in then pre out + 1 else 0
  ) ;
tel

node f_t_t_t(i1, i2, i3, i4: bool) returns (out: bool) ;
let
  out = (not i1) and i2 and i3 and i4 ;
tel

node t_f_t_t(i1, i2, i3, i4: bool) returns (out: bool) ;
let
  out = i1 and (not i2) and i3 and i4 ;
tel

node abs(in: real) returns (out: real) ;
let
  out = if in < 0.0 then -in else in ;
tel

node clamp(l_bound, in, u_bound: real) returns (out: real) ;
let
  out =
    if in < l_bound then l_bound else if in > u_bound then u_bound else in ;
tel



-- node integrator_reset(
--   in, in0 : real ; reset : bool
-- ) returns (
--   out : real
-- ) ;
-- var
--   resetting: bool ;
--   pre_reset, v, v_reset: real ;
-- let
--   resetting = reset or (false -> pre reset) ;
--   pre_reset = if resetting then in0 else (in0 -> pre v) ;
--   v = in + pre_reset ;
--   out = 0.0 -> pre v ;
-- tel


node Right (heading, cmd: real) returns (out: bool) ;
let
  out = (
    ((cmd - heading) > 0.0) and
    ((cmd - heading) < 180.0)
  ) ;
--   or (
--    (cmd - heading) < - 180.0
--  ) ;
tel


node Left (heading, cmd: real) returns (out: bool) ;
let
  -- out = (heading <> cmd) and (not Right(heading, cmd)) ;
  out = (
    ((cmd - heading) < 0.0) and
    ((cmd - heading) > - 180.0)
  ) ;
--  or (
--    (cmd - heading) > 180.0
--  ) ;
tel

node sign(in: real) returns (out: bool) ;
let
  out = in >= 0.0 ;
tel

node PseudoContinuous (in, inc: real) returns (out: bool) ;
let out = abs(in - (in -> pre in)) <= inc ; tel

-- |===| Abstractions of non-linear streams.

node times(x, y: real) returns (z: real) ;
(*@contract
var abs_x: real = if x < 0.0 then -x else x ;
var abs_y: real = if y < 0.0 then -y else y ;
var abs_z: real = if z < 0.0 then -z else z ;
-- Neutral.
guarantee (z = y) = ((x = 1.0) or (y = 0.0)) ;
guarantee (z = x) = ((y = 1.0) or (x = 0.0)) ;
-- Absorbing.
guarantee (z = 0.0) = ( (x = 0.0) or (y = 0.0) ) ;
-- Sign.
guarantee (z > 0.0) = (
  ( (x > 0.0) and (y > 0.0) ) or
  ( (x < 0.0) and (y < 0.0) )
) ;
guarantee (z < 0.0) = (
  ( (x > 0.0) and (y < 0.0) ) or
  ( (x < 0.0) and (y > 0.0) )
) ;
-- Loose proportionality.
guarantee (abs_z >= abs_y) = ((abs_x >= 1.0) or (y = 0.0)) ;
guarantee (abs_z >= abs_x) = ((abs_y >= 1.0) or (x = 0.0)) ;
guarantee (abs_z <= abs_y) = ((abs_x <= 1.0) or (y = 0.0)) ;
guarantee (abs_z <= abs_x) = ((abs_y <= 1.0) or (x = 0.0)) ;
*)
let
  z = x * y ;
tel

node divid(num, den: real) returns (res: real) ;
(*@contract
var abs_num: real = if num < 0.0 then -num else num ;
var abs_den: real = if den < 0.0 then -den else den ;
var abs_res: real = if res < 0.0 then -res else res ;
assume not (den = 0.0) ;
-- Neutral.
guarantee (res = num) = ((den = 1.0) or (num = 0.0)) ;
guarantee (res = - num) = ((den = - 1.0) or (num = 0.0)) ;
-- Absorbing.
guarantee (num = 0.0) = (res = 0.0) ;
-- Sign.
guarantee (res > 0.0) = (
  ( (num > 0.0) and (den > 0.0) ) or
  ( (num < 0.0) and (den < 0.0) )
) ;
guarantee (res < 0.0) = (
  ( (num > 0.0) and (den < 0.0) ) or
  ( (num < 0.0) and (den > 0.0) )
) ;
-- Loose proportionality.
guarantee (abs_res >= abs_num) = ((abs_den <= 1.0) or (num = 0.0)) ;
guarantee (abs_res <= abs_num) = ((abs_den >= 1.0) or (num = 0.0)) ;
-- Annulation.
guarantee (res = 1.0) = (num = den) ;
guarantee (res = - 1.0) = (num = - den) ;
*)
let
  res = num / den ;
tel

(* Division with some bounds on the denominator.
  Bounds MUST BE NUMBERS, otherwise the contract is non-linear. *)
node divid_bounded_num(
  num, den: real ; const l_bound, u_bound: real
) returns (res: real) ;
(*@contract
  var abs_num: real = if num < 0.0 then -num else num ;
  var abs_den: real = if den < 0.0 then -den else den ;
  var abs_res: real = if res < 0.0 then -res else res ;
  assume not (den = 0.0) ;
(* Denominator respects its bounds. *)
  assume l_bound <> 0.0 ;
  assume u_bound <> 0.0 ;
  assume l_bound <= u_bound ;
  assume l_bound <= den ;
  assume            den <= u_bound ;
-- Neutral.
  guarantee (res = num) = ((den = 1.0) or (num = 0.0)) ;
  guarantee (res = - num) = ((den = - 1.0) or (num = 0.0)) ;
-- Absorbing.
  guarantee (num = 0.0) = (res = 0.0) ;
-- Sign.
  guarantee (res > 0.0) = (
  ( (num > 0.0) and (den > 0.0) ) or
  ( (num < 0.0) and (den < 0.0) )
) ;
  guarantee (res < 0.0) = (
  ( (num > 0.0) and (den < 0.0) ) or
  ( (num < 0.0) and (den > 0.0) )
) ;
-- Loose proportionality.
  guarantee (abs_res >= abs_num) = ((abs_den <= 1.0) or (num = 0.0)) ;
  guarantee (abs_res <= abs_num) = ((abs_den >= 1.0) or (num = 0.0)) ;
-- Annulation.
  guarantee (res = 1.0) = (num = den) ;
  guarantee (res = - 1.0) = (num = - den) ;

-- Bounded result.
  mode num_pos_l_bound_pos (
    require num >= 0.0 ;
    require l_bound > 0.0 ;
    ensure num / u_bound <= res ;
    ensure                  res <= num / l_bound ;
  ) ;
  mode num_pos_u_bound_neg (
    require num >= 0.0 ;
    require u_bound < 0.0 ;
    ensure num / u_bound <= res ;
    ensure                  res <= num / l_bound ;
  ) ;
  mode num_neg_l_bound_pos (
    require num < 0.0 ;
    require l_bound > 0.0 ;
    ensure num / l_bound <= res ;
    ensure                  res <= num / u_bound ;
  ) ;
  mode num_neg_u_bound_neg (
    require num < 0.0 ;
    require u_bound < 0.0 ;
    ensure num / l_bound <= res ;
    ensure                  res <= num / u_bound ;
  ) ;
  mode num_pos_l_bound_neg_u_bound_pos (
    require num >= 0.0 ;
    require u_bound > 0.0 ;
    require l_bound < 0.0 ;
    ensure res <= num / l_bound or num / u_bound <= res ;
  ) ;
  mode num_neg_l_bound_neg_u_bound_pos (
    require num < 0.0 ;
    require u_bound > 0.0 ;
    require l_bound < 0.0 ;
    ensure res <= num / u_bound or num / l_bound <= res ;
  ) ;
*)
let
  res = num / den ;
tel

node temporal_divid(num, den: real) returns (res: real) ;
(*@contract
  var abs_num: real = if num < 0.0 then -num else num ;
  var abs_den: real = if den < 0.0 then -den else den ;
  var abs_res: real = if res < 0.0 then -res else res ;
  assume not (den = 0.0) ;
-- Neutral.
  guarantee (res = num) = ((den = 1.0) or (num = 0.0)) ;
  guarantee (res = - num) = ((den = - 1.0) or (num = 0.0)) ;
-- Absorbing.
  guarantee (num = 0.0) = (res = 0.0) ;
-- Sign.
  guarantee (res > 0.0) = (
  ( (num > 0.0) and (den > 0.0) ) or
  ( (num < 0.0) and (den < 0.0) )
) ;
  guarantee (res < 0.0) = (
  ( (num > 0.0) and (den < 0.0) ) or
  ( (num < 0.0) and (den > 0.0) )
) ;
-- Loose proportionality.
  guarantee (abs_res >= abs_num) = ((abs_den <= 1.0) or (num = 0.0)) ;
  guarantee (abs_res <= abs_num) = ((abs_den >= 1.0) or (num = 0.0)) ;
-- Annulation.
  guarantee (res = 1.0) = (num = den) ;
  guarantee (res = - 1.0) = (num = - den) ;

-- Evolution.
  mode init (
    require true -> false ;
    ensure true -> false ;
  ) ;

  mode both_inc (
    require false -> (num > pre num) ;
    require false -> (den > pre den) ;
  ) ;

  mode both_dec (
    require false -> (num < pre num) ;
    require false -> (den < pre den) ;
  ) ;

  mode inc_by_num_inc (
    require false -> (num > pre num) ;
    require false -> (den = pre den) ;
    ensure  false -> (res > pre res) ;
  ) ;

  mode inc_by_den_dec (
    require false -> (num = pre num) ;
    require false -> (den < pre den) ;
    ensure  false -> (res > pre res or res = 0.0) ;
  ) ;

  mode inc_by_num_inc_den_dec (
    require false -> (num > pre num) ;
    require false -> (den < pre den) ;
    ensure  false -> (res > pre res) ;
  ) ;

  mode dec_by_num_dec (
    require false -> (num < pre num) ;
    require false -> (den = pre den) ;
    ensure  false -> (res < pre res) ;
  ) ;

  mode dec_by_den_inc (
    require false -> (num = pre num) ;
    require false -> (den > pre den) ;
    ensure  false -> (res < pre res or res = 0.0) ;
  ) ;

  mode dec_by_num_dec_den_inc (
    require false -> (num < pre num) ;
    require false -> (den > pre den) ;
    ensure  false -> (res < pre res) ;
  ) ;

  mode steady (
    require false -> (num = pre num) ;
    require false -> (den = pre den) ;
    ensure  false -> (res = pre res) ;
  ) ;
*)
let
  res = num / den ;
tel



-- |===| latitudinal_control.lus

node nl_latitudinal_1(in1, in2, in3: real) returns (out: real) ;
let
  -- out = in1 / in2 * in3 ;
  out = times(in3, divid(in1, in2)) ;
tel

node nl_latitudinal_2(in1, in2, in3: real) returns (out: real) ;
let
  -- out = in1 / in2 * in3 ;
  out = times(in3, divid(in1, in2)) ;
tel

node nl_latitudinal_3(in1, in2, in3: real) returns (out: real) ;
let
  -- out = in1 / in2 * in3 ;
  out = times(in3, divid(in1, in2)) ;
tel

node nl_latitudinal_4(in1, in2: real) returns (out: real) ;
let
  -- out = in1 / in2 ;
  out = times(in1, in2) ;
tel

node nl_latitudinal_5(in1, in2: real) returns (out: real) ;
let
  -- out = in1 / in2 ;
  out = times(in1, in2) ;
tel

node nl_latitudinal_6(in1, in2: real) returns (out: real) ;
let
  -- out = in1 / in2 ;
  out = times(in1, in2) ;
tel

node nl_latitudinal_7(in1, in2: real) returns (out: real) ;
let
  -- out = in1 / in2 ;
  out = times(in1, in2) ;
tel

node nl_latitudinal_8(in1, in2: real) returns (out: real) ;
let
  -- out = in1 * in2 ;
  out = times(in1, in2) ;
tel

node nl_latitudinal_9(in1, in2, in3: real) returns (out: real) ;
let
  -- out = in1 * in2 * in3 ;
  out = times(in1, times(in2, in3)) ;
tel

node nl_latitudinal_10(in1, in2, in3: real) returns (out: real) ;
let
  -- out = in1 * in2 * in3 ;
  out = times(in1, times(in2, in3)) ;
tel

node nl_latitudinal_11(in1, in2, in3: real) returns (out: real) ;
let
  -- out = in1 * in2 * in3 ;
  out = times(in1, times(in2, in3)) ;
tel

node nl_latitudinal_12(in1, in2: real) returns (out: real) ;
let
  -- out = in1 * in2 ;
  out = times(in1, in2) ;
tel

-- |===| longitudinal_control.lus

node nl_longitudinal_1(in1, in2: real) returns (out: real) ;
let
  -- out = in1 * in2 ;
  out = times(in1, in2) ;
tel

node nl_longitudinal_2(in1, in2: real) returns (out: real) ;
let
  -- out = in1 * in2 ;
  out = times(in1, in2) ;
tel

node nl_longitudinal_3(in1, in2, in3: real) returns (out: real) ;
let
  -- out = in1 * in2 ;
  out = times(in1, in2) ;
tel

node nl_longitudinal_4(in1, in2: real) returns (out: real) ;
let
  -- out = in1 / in2 ;
  out = divid(in1, in2) ;
tel

node nl_longitudinal_5(in1, in2, in3: real) returns (out: real) ;
let
  -- out = in1 / (in2 * in3) ;
  out = divid(in1, times(in2, in3)) ;
tel

node nl_longitudinal_6(in1, in2, in3: real) returns (out: real) ;
let
  -- out = in1 / (in2 * in3) ;
  out = divid(in1, times(in2, in3)) ;
tel

node nl_longitudinal_7(in1, in2, in3: real) returns (out: real) ;
let
  -- out = in1 / (in2 * in3) ;
  out = divid(in1, times(in2, in3)) ;
tel

node nl_longitudinal_8(in1, in2, in3: real) returns (out: real) ;
let
  -- out = in1 / in2 * in3 ;
  out = divid(in1, times(in2, in3)) ;
tel

node nl_longitudinal_9(in1, in2, in3: real) returns (out: real) ;
let
  -- out = in1 / in2 * in3 ;
  out = divid(in1, times(in2, in3)) ;
tel

node nl_longitudinal_10(in1, in2, in3: real) returns (out: real) ;
let
  -- out = in1 / in2 * in3 ;
  out = divid(in1, times(in2, in3)) ;
tel

(* Threshold on the altitude gap for Guide 210 and 170/180. *)
const altitude_gap_threshold = 200.0 ;

(* Contract for `MODE_LOGIC_HeadingMode`. *)
contract logic_heading(
  in_engage, in_disengage: bool
) returns (
  out_engaged: bool
) ;
let
  var head_deactivation: bool = false -> pre in_disengage ;
  (* Head requested and no deactivation since then. *)
  var head_req: bool = has_been_true_reset(
    in_engage, head_deactivation and not in_engage
  ) ;

  (* System does not behave well when inputs rise and fall change value too
  fast. The assumptions that follow say that when an input changes value, it
  keeps the new value for at least two steps. *)
  assume true -> (
    since(in_engage) = 1 => pre since(not in_engage) > 1
  ) ;
  assume true -> (
    since(not in_engage) = 1 => pre since(in_engage) > 1
  ) ;
  assume true -> (
    since(in_disengage) = 1 => pre since (not in_disengage) > 1
  ) ;
  assume true -> (
    since(not in_disengage) = 1 => pre since (in_disengage) > 1
  ) ;

  (* System does not behave well when an both inputs fall at the same time. *)
  assume not ( fall(in_engage) and fall(in_disengage) ) ;

  (* Not asked to engage yet. *)
  mode init (
    require duration(not in_engage) > 0 ;
    ensure  not out_engaged ;
  ) ;

  (* Asked to engage in the past, but disengaged now. *)
  mode deactivating (
    (* No collision with init mode. *)
    require not ::init ;
    require not head_req ;
    require not in_engage ;
    ensure  not out_engaged ;
  ) ;

  mode engaged (
    require head_req ;
    ensure  out_engaged ;
  ) ;
tel













(* Contract for `MODE_LOGIC_AltAndFPAMode`. *)
contract logic_alt_fpa(
  in_alt_engage, in_fpa_engage, in_disengage: bool ;
  altitude, altitude_target: real
) returns (
  out_alt_engaged, out_fpa_engaged: bool
) ;
let
  var deactivation: bool = false -> pre in_disengage ;

  (* Alt requested and no deactivation since then. *)
  var alt_requested: bool = has_been_true_reset(
    in_alt_engage, deactivation and not in_alt_engage
  ) ;
  (* FPA requested and no deactivation since then. *)
  var fpa_requested: bool = has_been_true_reset(
    in_fpa_engage, deactivation and not in_fpa_engage
  ) ;

  (* Separates Guide 210 (`tiny_altitude_gap`) from Guide 170/180
  (`wide_altitude_gap`). In the former altitude has priority, while in the
  latter it's FPA. *)
  var wide_altitude_gap: bool = abs(
    altitude - altitude_target
  ) > altitude_gap_threshold ;
  var tiny_altitude_gap: bool = not wide_altitude_gap ;

  (* The following assumptions say that [alt_eng_in], [fpa_eng_in] and
  [deactivation] cannot change too fast. It can only change from [v] to [not v]
  if it had value [v] for at least two steps.

  The system remembers which mode were requested since the last deactivation
  and activates whoever has priority, depending on the width of the gap between
  the actual altitude and the altitude command.

  But it seems a request is only remembered if it lasts for more than one
  cycle. My understanding is that in this case, the relevant mode is still
  activated for this one cycle, but that's all.

  I tried to specify the system for this behavior, and it worked to some
  extent, but the spec was way messier. More importantly, when there are
  alternations of one-cycle-long requests for Alt and FPA the system just stops
  making any sense to me. I might be missing something, but when in addition
  [deactivation] is allowed to spike for a single cycle, it becomes a
  nightmare.

  Example of very confusing trace:
  Node MODE_LOGIC_AltAndFPAMode ()
   == Inputs ==
   ActiavteFPA_1_1                               0     0     0     0     0
   Deactivate_1_1                             true  true false false false
   Altitude_1_1                                201  -201    -1     0   201
   AltCmd_1_1                                    0     0     0   200     0
   ActiavteAlt_1_1                               0     0     6     0     0
   == Outputs ==
   AltEng_1_1                                false false  true false  true
   FPAEng_2_1                                false false false false false

  Notice that there's an Alt request in step 3 that's not confirmed so Alt is
  active in step 3 but not step 4. However for some reason it is activated
  again in step 5 even though there's no request at all... *)
  assume true -> (
    since(    in_alt_engage) = 1 => pre since(not in_alt_engage) > 1
  ) ;
  assume true -> (
    since(not in_alt_engage) = 1 => pre since(    in_alt_engage) > 1
  ) ;
  assume true -> (
    since(    in_fpa_engage) = 1 => pre since(not in_fpa_engage) > 1
  ) ;
  assume true -> (
    since(not in_fpa_engage) = 1 => pre since(    in_fpa_engage) > 1
  ) ;
  assume true -> (
    since(    in_disengage ) = 1 => pre since(not in_disengage ) > 1
  ) ;
  assume true -> (
    since(not in_disengage ) = 1 => pre since(    in_disengage ) > 1
  ) ;

  (* System does not behave well when two signals fall at the same time. *)
  assume fall(in_alt_engage) => not fall(in_disengage) ;
  assume fall(in_fpa_engage) => not fall(in_disengage) ;

  (* Whatever happens, altitude control and PFA control can't be active at the
  same time. *)
  guarantee not (out_alt_engaged and out_fpa_engaged) ;

  (* Nothing happened so far. *)
  mode init (
    require duration( not (in_alt_engage or in_fpa_engage) ) > 0 ;
    (* Neither alt or FPA is active. *)
    ensure not (out_alt_engaged or out_fpa_engaged) ;
  ) ;

  (* Asked to engage in the past but disengaged now. *)
  mode disengaged (
    (* No collision with inactive mode. *)
    require not ::init ;
    require not alt_requested ;
    require not fpa_requested ;
    (* Neither alt or FPA is active. *)
    ensure  not (out_alt_engaged or out_fpa_engaged) ;
  ) ;

  (* |===| Guide 170.
  Altitude does not have priority. It cannot be active if FPA was requested
  since the beginning / last deactivation, or if a deactivation happened since
  the last request for altitude. *)
  mode alt_wag_170 (
    require wide_altitude_gap ;
    require alt_requested ;
    require not fpa_requested ;
    (* Altitude is engaged. *)
    ensure  out_alt_engaged ;
  ) ;

  (* |===| Guide 180.
  FPA has priority. It is active if no deactivation happened since the last FPA
  request. *)
  mode fpa_wag_180 (
    require wide_altitude_gap ;
    require fpa_requested ;
    (* FPA is engaged. *)
    ensure  out_fpa_engaged ;
  ) ;

  (* |===| Guide 210, fpa mode.
  FPA does not have priority. It cannot be active if altitude was requested
  since the beginning / last deactivation, or if a deactivation happened since
  the last request for FPA. *)
  mode fpa_tag_210 (
    require tiny_altitude_gap ;
    require fpa_requested ;
    require not alt_requested ;
    (* FPA is active. *)
    ensure  out_fpa_engaged ;
  ) ;

  (* |===| Guide 210, altitude mode.
  Altitude has priority. It is active if no deactivation happened since the
  last altitude request. *)
  mode alt_tag_210 (
    require tiny_altitude_gap ;
    require alt_requested ;
    (* Altitude is active. *)
    ensure  out_alt_engaged ;
  ) ;

tel










(* Contract for `MODE_LOGIC`.
Gathers `logic_heading` and `logic_alt_fpa`. *)
contract logic (
  in_head_engage, in_alt_engage, in_fpa_engage, in_disengage: bool ;
  in_alt, in_alt_target: real
) returns (
  out_head_engaged, out_alt_engaged, out_fpa_engaged: bool
) ;
let
  import logic_heading (
    in_head_engage, in_disengage
  ) returns (
    out_head_engaged
  ) ;
  import logic_alt_fpa (
    in_alt_engage, in_fpa_engage, in_disengage, in_alt, in_alt_target
  ) returns (
    out_alt_engaged, out_fpa_engaged
  ) ;
tel







(* Contract for `LONGITUDINAL_CONTROLLER_FPAControl`. *)
contract fpa (
  in_engaged: bool ;
  in_fpa, in_fpa_target, in_pitch, in_speed: real
) returns (
  out_pitch: real
) ;
let
  var pre_in_fpa_target: real = in_fpa_target -> pre in_fpa_target ;
  var pre_out_pitch: real = out_pitch -> pre out_pitch ;

  (* True if the fpa target hasn't changed. *)
  var cmd_stable: bool = true -> in_fpa_target = pre in_fpa_target ;
  var pitch_diff_ubound: real = 4.83 * 57.2958 * 1.6878 * in_speed ;
  var safe_pitch_diff: real = (
    if in_fpa_target - in_fpa > pitch_diff_ubound
    then pitch_diff_ubound
    else if in_fpa_target - in_fpa < - pitch_diff_ubound
    then - pitch_diff_ubound
    else in_fpa_target - in_fpa
  ) ;

  (* Rising means that the pitch command is above the current pitch, or above
  its previous value, or that FPA is expected to reach / go above the FPA
  target in the next step. *)
  var rising: bool =
    out_pitch > in_pitch or
    out_pitch >= pre_out_pitch or
    in_fpa_target <= in_fpa + ( 0.0 -> (in_fpa - pre in_fpa) ) ;

  (* Lowering means that the pitch command is below the current pitch, or below
  its previous value, or that FPA is expected to reach / go below the FPA
  target in the next step. *)
  var lowering: bool =
    out_pitch < in_pitch or
    out_pitch <= pre_out_pitch or
    in_fpa_target >= in_fpa + ( 0.0 -> (in_fpa - pre in_fpa) ) ;

  (* Speed is positive. *)
  assume in_speed >= 0.0 ;

  (* We're not engaged initially. *)
  -- assume not in_engaged -> true ;
  (* We start with pitch and FPA at 0. *)
  -- assume in_pitch = 0.0 -> true ;
  -- assume in_fpa = 0.0 -> true ;


  (* ## Pseudo-closed-loop assumptions. *)

  (* Pitch cannot change too fast. *)
  -- assume PseudoContinuous(in_pitch, 1.0) ;
  (* Neither can FPA. *)
  -- assume PseudoContinuous(in_fpa, 1.0) ;
  (* Neither can FPA command. *)
  -- assume PseudoContinuous(in_fpa_target, 1.0) ;
  (* Pitch command is immediate when we're engaged. *)
  -- assume true -> (
  --   in_engaged and pre in_engaged => in_pitch = pre out_pitch
  -- ) ;
  (* Super strong relation between pitch and FPA. *)
  -- assume in_pitch = 1.4 * in_fpa ;

  (* Pitch converges towards pitch command. Ideally we want this and not the
  previous one. *)
  assume true -> (
    pre in_engaged => (
      abs( 0.0 -> (in_pitch - pre out_pitch) ) <=
      abs( 0.0 -> (pre in_pitch - pre out_pitch) )
      -- or (pre in_pitch) = pre out_pitch
    )
  ) ;

  (* Link between pitch and FPA. *)
  (* FPA and theta have same sign, and abs(fpa) < (theta). *)
--   assume (in_pitch = 0.0 => in_fpa = 0.0) ;
--   assume true -> (
--     in_pitch > 0.0 => (
--       in_pitch > in_fpa and in_fpa >= in_pitch / 1.4
--     )
--   ) ;
--   assume true -> (
--     in_pitch < 0.0 => (
--       in_pitch / 1.4 >= in_fpa and in_fpa > in_pitch
--     )
--   ) ;
  (* Derivatives of FPA and pitch have the same sign. *)
  assume true -> ( (in_pitch > pre in_pitch) = (in_fpa > pre in_fpa) ) ;
  assume true -> ( (in_pitch < pre in_pitch) = (in_fpa < pre in_fpa) ) ;
  assume true -> ( (in_pitch = pre in_pitch) = (in_fpa = pre in_fpa) ) ;


  (* Cannot be engaged if speed is less than 100. *)
  assume in_speed < 100.0 => not in_engaged ;
  (* When engaging actual FPA and command must match. *)
  -- assume true -> (
  --   rise(in_engaged) => (
  --     abs(in_fpa - in_fpa_target) < 0.001
  --   )
  -- ) ;


  (* |===| "Pitch command clamped by aircraft limitations." Probably.
    Constants come from the system, no idea what they mean.

    System acts weird when fpa_eng_in_in is true in the initial state. We thus
    request that at least a deactivation occured. *)
  -- guarantee (true -> has_been_true(not engaged)) => (
  --   engaged =>
  --     abs(in_pitch - out_pitch) <= 4.83 * 57.2958 * 1.6878 * in_speed
  -- ) ;


  (* |===| Modes. *)

  -- (* Inhibited. *)
  -- mode inhibited (
  --   require in_hibit ;
  -- ) ;

  (* Not activated. Seems to me the ensure here should be that
  out_pitch = in_pitch. *)
  mode fpa_deactivated (
--     require not ::inhibited ;
    require not in_engaged ;
    ensure true -> (
      (has_been_true(in_engaged) and pre not in_engaged) => (
        out_pitch = (
          pre (safe_pitch_diff + in_pitch + 1.4 * in_fpa)
        ) - 1.4 * in_fpa
      )
    ) ;
  ) ;

  mode fpa_fpa_engaging (
    -- require not ::inhibited ;
    require in_engaged -> rise(in_engaged) ;
  ) ;

  (* |===| Guide 120/130, rising. *)
  mode fpa_g120_130_rising (
    -- require not ::inhibited ;
    require in_engaged ;
    require false -> pre in_engaged ;
    require in_fpa_target > in_fpa ;
    ensure (
      (* Not confirmed that we're climbing. *)
      (false -> pre (in_fpa_target <= in_fpa)) or
      (* Pitch was at pitch command. *)
      (false -> pre (in_pitch = out_pitch)) or
      (* Climbing. *)
      rising or
      (* We're not climbing but we were in the previous state. *)
      ( not rising and (false -> pre rising) )
    ) ;
  ) ;

  (* |===| Guide 120/130, lowering. *)
  mode fpa_g120_130_lowering (
    -- require not ::inhibited ;
    require in_engaged ;
    require false -> pre in_engaged ;
    require in_fpa_target < in_fpa ;
    ensure (
      (* Not confirmed that we're descending. *)
      (false -> pre (in_fpa_target >= in_fpa)) or
      (* Pitch was at pitch command. *)
      (false -> pre (in_pitch = out_pitch)) or
      (* descending. *)
      lowering or
      (* We're not descending but we were in the previous state. *)
      ( not lowering and (false -> pre lowering) )
    ) ;
  ) ;

  (* |===| Guide 120/130, stabilizing version.
    Things get tricky when we get to the requested FPA. Not sure what the
    ensure should be here. This mode cannot be active for two consecutive
    states though because of `count_succ_true(...) = 1` unless the command
    changes. *)
  mode fpa_g120_130_stabilizing (
    -- require not ::inhibited ;
    require in_engaged ;
    require (
      (not cmd_stable) or
      -- (false -> not pre in_engaged) or
      (false -> (in_fpa_target < in_fpa <> pre (in_fpa_target < in_fpa))) or
      (false -> (in_fpa_target > in_fpa <> pre (in_fpa_target > in_fpa))) or
      count_succ_true(in_fpa_target = in_fpa) = 1
    ) ;
  ) ;

  (* |===| Guide 120, stable version. *)
  mode fpa_g120_130_stable (
    require not ::fpa_fpa_engaging ;
    require count_succ_true(in_engaged) >= 2 ;
    require count_succ_true(in_fpa_target = in_fpa) >= 2 ;
    require cmd_stable ;
    ensure (
      out_pitch = in_pitch
      -- ( (next_fpa < in_fpa_target) and (pitch > in_fpa_target) ) or
      -- ( (next_fpa > in_fpa_target) and (pitch < in_fpa_target) ) or
      -- duration(true) < 3
    ) ;
  ) ;


tel













(* Contract for `LONGITUDINAL_CONTROLLER_AltitudeControl`. *)
contract alt(
  in_hibit, in_engaged: bool ;
  in_alt, in_alt_target, in_gskts, in_hdot: real
) returns (
  out_alt: real
) ;
let
  (* Forcing continuity over the altitude and its derivative. *)
  assume PseudoContinuous(in_alt, 1.0) ;
  assume PseudoContinuous(in_hdot, 1.0) ;

  (* Forcing the semantics of `hdot`, derivative of the altitude. *)
  assume true -> in_alt = in_hdot + pre in_alt ;

  mode inhibited (
    require in_hibit ;
  ) ;

  mode alt_disengaged_slow (
    require not ::inhibited ;
    require not in_engaged ;
    require in_gskts < 100.0 ;
  ) ;

  mode alt_disengaged_fast (
    require not ::inhibited ;
    require not in_engaged ;
    require not ::alt_disengaged_slow ;
    (* O.34 > 57.2958 / (1.6878 * 100), where 100 is the lower bound of
    gskts_in. *)
    ensure  true -> (
      (pre not in_engaged) => (
        out_alt <= (3.2 + pre in_hdot) * 0.34
      )
    ) ;
    ensure true -> (
      (pre not in_engaged) => (
        out_alt >= (- 3.2 + pre in_hdot) * 0.34
      )
    ) ;
  ) ;

  (* Engaged, unspecified for now. *)
  mode alt_engaged (
    require not ::inhibited ;
    require in_engaged ;
  ) ;
tel




(* Maximum CAS value for which controllers are active. *)
const max_cas = 500.0 ;


(* Contract for `LONGITUDINAL_CONTROLLER`. *)
contract longitudinal (
  in_alt_engaged, in_fpa_engaged: bool ;
  in_alt, in_alt_target, in_hdot,
  in_fpa, in_fpa_target,
  in_pitch,
  in_speed,
  in_gskts,
  in_cas,
  in_elev: real
) returns (
  out_alt, out_pitch, out_elev: real
) ;
let

  var pre_out_pitch: real = out_pitch -> pre out_pitch ;

  var fpa_target_stable: bool = true -> in_fpa_target = pre in_fpa_target ;

  var fpa_tgt_delta_lb: real = 0.0 -> (-3.2 + pre in_hdot) * 0.34 ;
  var fpa_tgt_delta_ub: real = 0.0 -> ( 3.2 + pre in_hdot) * 0.34 ;
  var fpa_tgt_lb: real = in_fpa_target + fpa_tgt_delta_lb ;
  var fpa_tgt_ub: real = in_fpa_target + fpa_tgt_delta_ub ;
  -- var fpa_tgt_delta = abs(0.0 -> ( 3.2 + pre in_hdot) * 0.34) ;
  -- var fpa_tgt_lb = in_fpa_target - fpa_tgt_delta ;
  -- var fpa_tgt_ub = in_fpa_target + fpa_tgt_delta ;

  var rising: bool = 
    out_pitch > in_pitch or
    out_pitch >= pre_out_pitch or
    fpa_tgt_lb <= in_fpa + (0.0 -> in_fpa - pre in_fpa) ;

  var lowering: bool =
    out_pitch < in_pitch or
    out_pitch <= pre_out_pitch or
    fpa_tgt_ub >= in_fpa + (0.0 -> in_fpa - pre in_fpa) ;

  (* All speed inputs are positive. *)
  assume in_speed >= 0.0 ;
  assume in_gskts >= 0.0 ;
  assume in_cas   >= 0.0 ;

  assume PseudoContinuous(in_alt,   1.0) ;
  assume PseudoContinuous(in_hdot,  1.0) ;
  assume PseudoContinuous(in_speed, 1.0) ;
  assume PseudoContinuous(in_gskts, 1.0) ;
  assume PseudoContinuous(in_cas,   1.0) ;

  assume true -> in_alt = in_hdot + pre in_alt ;

  (* Cannot be engaged if speed is less than 100. *)
  assume (in_fpa_engaged or in_alt_engaged) => in_speed >= 100.0 ;
  assume (in_fpa_engaged or in_alt_engaged) => in_gskts >= 100.0 ;
  assume (in_fpa_engaged or in_alt_engaged) => in_cas   >= 100.0 ;
  assume (in_fpa_engaged or in_alt_engaged) => in_alt_target >= 0.0 ;
  assume (in_fpa_engaged or in_alt_engaged) => in_fpa_target = 0.0 ;

  -- assume in_fpa_engaged ;
  -- assume in_alt > 100.0 ;

  (* FPA and altitude cannot be engaged at the same time. *)
  assume not (in_fpa_engaged and in_alt_engaged) ;

  assume fall(in_alt_engaged) => not in_fpa_engaged ;

  assume true -> (
    ( (in_pitch > pre in_pitch) = (in_fpa > pre in_fpa) ) and
    ( (in_pitch < pre in_pitch) = (in_fpa < pre in_fpa) ) and
    ( (in_pitch = pre in_pitch) = (in_fpa = pre in_fpa) )
  ) ;

  assume true -> (
    pre in_fpa_engaged => (
      abs( 0.0 -> (in_pitch - pre out_pitch) ) <=
      abs( 0.0 -> pre (in_pitch - out_pitch) )
      -- or (pre in_pitch) = pre out_pitch
    )
  ) ;

  mode always_true (
    require true ;
  ) ;

  (* Elevation stick bypasses everything. *)
  mode manual_override (
    require in_elev <> 0.0 ;
    ensure out_elev = in_elev ;
  ) ;

  (* If CAS is above 500 and there's no manual overrid, output is zero. *)
  mode too_fast (
    require not ::manual_override ;
    require in_cas > max_cas ;
    ensure  out_elev = 0.0 ;
  ) ;

  (* Disengaged, no manual override, not too fast. *)
  mode disengaged (
    require not ::manual_override ;
    require not ::too_fast ;
    require not in_fpa_engaged ;
    require not in_alt_engaged ;
    ensure  out_elev = 0.0 ;
  ) ;

  mode alt_engaged (
    require not ::manual_override ;
    require not ::too_fast ;
    require in_alt_engaged ;
  ) ;

  mode fpa_engaging (
    require not ::manual_override ;
    require not ::too_fast ;
    require in_fpa_engaged -> rise(in_fpa_engaged) ;
  ) ;

  (* |===| Guide 120/130, rising. *)
  mode fpa_g120_130_rising (
    require not ::manual_override ;
    require not ::too_fast ;
    require in_fpa_engaged ;
    require false -> pre in_fpa_engaged ;
    require (
      (* (-3.2 + pre hdot_in) * 0.34 is the lower bound on alt_cmd_out when alt
        is not engaged. *)
      fpa_tgt_lb > in_fpa
    ) ;
    ensure (
      (* Not confirmed that we're rising. *)
      (false -> pre (fpa_tgt_lb <= in_fpa)) or
      (* Pitch was at pitch command. *)
      (false -> pre (in_pitch = out_pitch)) or
      (* Rising. *)
      rising or
      (* We're not rising but we were in the previous state. *)
      (false -> pre rising)
    ) ;
  ) ;

  (* |===| Guide 120/130, lowering. *)
  mode fpa_g120_130_lowering (
    require not ::manual_override ;
    require not ::too_fast ;
    require in_fpa_engaged ;
    require false -> pre in_fpa_engaged ;
    require (
      (* (+3.2 + pre hdot_in) * 0.34 is the lower bound on alt_cmd_out when alt
        is not engaged. *)
      fpa_tgt_ub < in_fpa
    ) ;
    ensure (
      (* Not confirmed that we're lowering. *)
      (false -> pre (fpa_tgt_ub >= in_fpa)) or
      (* Pitch was at pitch command. *)
      (false -> pre (in_pitch = out_pitch)) or
      (* lowering. *)
      lowering or
      (* We're not lowering but we were in the previous state. *)
      (false -> pre lowering)
    ) ;
  ) ;

  (* |===| Guide 120_130, stabilizing version.
   Things get tricky when we get to the requested FPA.
   Not sure what the ensure should be here. *)
  mode g120_130_stabilizing (
    require not ::manual_override ;
    require not ::too_fast ;
    require in_fpa_engaged ;
    require fpa_tgt_lb >= in_fpa ;
    require fpa_tgt_ub <= in_fpa ;
  ) ;


  -- import alt (
  --   inhibit, in_alt_engaged, in_alt, in_alt_target, in_gskts, in_hdot
  -- ) returns (
  --   out_alt
  -- ) ;
  -- import fpa (
  --   inhibit, in_fpa_engaged, in_fpa, in_fpa_target, in_pitch, in_speed,
  --   fpa_tgt_lb, fpa_tgt_ub
  -- ) returns (
  --   out_pitch
  -- ) ;
tel







(* Contract for `Mode_plus_Longitudinal`. *)
contract logic_longitudinal (
  in_head_engage, in_alt_engage, in_fpa_engage: bool ;
  in_alt, in_alt_target, in_hdot,
  in_fpa, in_fpa_target,
  in_pitch,
  in_speed,
  in_gskts,
  in_cas,
  in_elev,
  in_ail: real
) returns (
  out_head_engaged, out_alt_engaged, out_fpa_engaged: bool ;
  out_alt, out_pitch, out_elev: real
) ;
let
  var deactivate: bool = in_elev <> 0.0 or in_ail <> 0.0 ;

  import logic (
    in_head_engage, in_alt_engage, in_fpa_engage, deactivate,
    in_alt, in_alt_target
  ) returns (
    out_head_engaged, out_alt_engaged, out_fpa_engaged
  ) ;

  import longitudinal (
    ::logic::logic_alt_fpa::alt_wag_170 or
    ::logic::logic_alt_fpa::alt_tag_210,
    ::logic::logic_alt_fpa::fpa_wag_180 or
    ::logic::logic_alt_fpa::fpa_tag_210,
    in_alt, in_alt_target, in_hdot,
    in_fpa, in_fpa_target,
    in_pitch,
    in_speed,
    in_gskts,
    in_cas,
    in_elev
  ) returns (
    out_alt, out_pitch, out_elev
  ) ;

tel

-- System nodes
node MODE_LOGIC_SpeedMode (Actiavte_1_1 : real; Deactivate_1_1 : real; AltEng_1_1 : bool; CAS_1_1 : real; CASCmdMCP_1_1 : real; )
returns (ATEng_1_1 : bool;
  CASCmd_2_1 : real) ;
var
  Add_1_1 : int;
  CompareToConstant_1_1 : bool;
  CompareToConstant1_1_1 : bool;
  LogicalOperator_1_1 : bool;
  LogicalOperator2_1_1 : bool;
  Switch_1_1 : real;
  Switch1_1_1 : real;
  SRFlipFlopRepl_dot__LogicalOperator_1_1 : bool;
  SRFlipFlopRepl_dot__LogicalOperator1_1_1 : bool;
  SRFlipFlopRepl_dot__LogicalOperator2_1_1 : bool;
  SRFlipFlopRepl_dot__LogicalOperator3_1_1 : bool;
  SRFlipFlopRepl_dot__UnitDelay_1_1 : bool;
  SRFlipFlopRepl_dot__UnitDelay1_1_1 : bool;
  UnitDelay2_1_1 : real;
let 
  Add_1_1 = (if CompareToConstant1_1_1 then 1 else 0) + (if LogicalOperator_1_1 then 1 else 0);
  CompareToConstant_1_1 = not(Deactivate_1_1 = 0.0000000000);
  CompareToConstant1_1_1 = not(Actiavte_1_1 = 0.0000000000);
  LogicalOperator_1_1 = AltEng_1_1 and SRFlipFlopRepl_dot__LogicalOperator_1_1;
  LogicalOperator2_1_1 = CompareToConstant1_1_1 or LogicalOperator_1_1;
  Switch_1_1 = if Add_1_1 >= 0 then UnitDelay2_1_1 else Switch1_1_1;
  Switch1_1_1 = if Add_1_1 > 1 then CASCmdMCP_1_1 else CAS_1_1;
  SRFlipFlopRepl_dot__LogicalOperator_1_1 = not(SRFlipFlopRepl_dot__UnitDelay_1_1 and SRFlipFlopRepl_dot__LogicalOperator3_1_1);
  SRFlipFlopRepl_dot__LogicalOperator1_1_1 = not(SRFlipFlopRepl_dot__LogicalOperator2_1_1 and SRFlipFlopRepl_dot__UnitDelay1_1_1);
  SRFlipFlopRepl_dot__LogicalOperator2_1_1 = not LogicalOperator2_1_1;
  SRFlipFlopRepl_dot__LogicalOperator3_1_1 = not CompareToConstant_1_1;
  SRFlipFlopRepl_dot__UnitDelay_1_1 = false -> pre SRFlipFlopRepl_dot__LogicalOperator1_1_1;
  SRFlipFlopRepl_dot__UnitDelay1_1_1 = true -> pre SRFlipFlopRepl_dot__LogicalOperator_1_1;
  UnitDelay2_1_1 = 0.0000000000 -> pre Switch_1_1;
  ATEng_1_1 = SRFlipFlopRepl_dot__LogicalOperator1_1_1;
  CASCmd_2_1 = UnitDelay2_1_1;
tel

node MODE_LOGIC_HeadingMode (
  Actiavte_1_1 : real; Deactivate_1_1 : bool
) returns (HeadEng_1_1 : bool) ;

var
  CompareToConstant_1_1 : bool;
  CompareToConstant1_1_1 : bool;
  SRFlipFlopRepl_dot__LogicalOperator_1_1 : bool;
  SRFlipFlopRepl_dot__LogicalOperator1_1_1 : bool;
  SRFlipFlopRepl_dot__LogicalOperator2_1_1 : bool;
  SRFlipFlopRepl_dot__LogicalOperator3_1_1 : bool;
  SRFlipFlopRepl_dot__UnitDelay_1_1 : bool;
  SRFlipFlopRepl_dot__UnitDelay1_1_1 : bool;
let 
  CompareToConstant_1_1 = not((if Deactivate_1_1 then 1.0 else 0.0) = 0.0000000000);
  CompareToConstant1_1_1 = not(Actiavte_1_1 = 0.0000000000);
  SRFlipFlopRepl_dot__LogicalOperator_1_1 = not(SRFlipFlopRepl_dot__UnitDelay_1_1 and SRFlipFlopRepl_dot__LogicalOperator3_1_1);
  SRFlipFlopRepl_dot__LogicalOperator1_1_1 = not(SRFlipFlopRepl_dot__LogicalOperator2_1_1 and SRFlipFlopRepl_dot__UnitDelay1_1_1);
  SRFlipFlopRepl_dot__LogicalOperator2_1_1 = not CompareToConstant1_1_1;
  SRFlipFlopRepl_dot__LogicalOperator3_1_1 = not CompareToConstant_1_1;
  SRFlipFlopRepl_dot__UnitDelay_1_1 = false -> pre SRFlipFlopRepl_dot__LogicalOperator1_1_1;
  SRFlipFlopRepl_dot__UnitDelay1_1_1 = true -> pre SRFlipFlopRepl_dot__LogicalOperator_1_1;
  HeadEng_1_1 = SRFlipFlopRepl_dot__LogicalOperator1_1_1;
tel

node MODE_LOGIC_AltAndFPAMode (
  ActiavteFPA_1_1 : real; Deactivate_1_1 : bool;
  Altitude_1_1, AltCmd_1_1, ActiavteAlt_1_1 : real
) returns (
  AltEng_1_1 : bool; FPAEng_2_1 : bool
) ;


var
  Abs_1_1 : real;
  Add_1_1 : real;
  CompareToConstant_1_1 : bool;
  CompareToConstant1_1_1 : bool;
  CompareToConstant2_1_1 : bool;
  CompareToConstant3_1_1 : bool;
  LogicalOperator1_1_1 : bool;
  LogicalOperator2_1_1 : bool;
  LogicalOperator3_1_1 : bool;
  LogicalOperator4_1_1 : bool;
  LogicalOperator6_1_1 : bool;
  SRFlipFlopRepl_dot_1_LogicalOperator_1_1 : bool;
  SRFlipFlopRepl_dot_1_LogicalOperator1_1_1 : bool;
  SRFlipFlopRepl_dot_1_LogicalOperator2_1_1 : bool;
  SRFlipFlopRepl_dot_1_LogicalOperator3_1_1 : bool;
  SRFlipFlopRepl_dot_1_UnitDelay_1_1 : bool;
  SRFlipFlopRepl_dot_1_UnitDelay1_1_1 : bool;
  SRFlipFlopRepl_dot__LogicalOperator_1_1 : bool;
  SRFlipFlopRepl_dot__LogicalOperator1_1_1 : bool;
  SRFlipFlopRepl_dot__LogicalOperator2_1_1 : bool;
  SRFlipFlopRepl_dot__LogicalOperator3_1_1 : bool;
  SRFlipFlopRepl_dot__UnitDelay_1_1 : bool;
  SRFlipFlopRepl_dot__UnitDelay1_1_1 : bool;
let 
  Abs_1_1 = if Add_1_1 >= 0.0 then Add_1_1 else -Add_1_1;
  Add_1_1 = Altitude_1_1 - AltCmd_1_1;
  CompareToConstant_1_1 = not((if Deactivate_1_1 then 1.0 else 0.0) = 0.0000000000);
  CompareToConstant1_1_1 = not(ActiavteFPA_1_1 = 0.0000000000);
  CompareToConstant2_1_1 = Abs_1_1 <= 200.0000000000;
  CompareToConstant3_1_1 = not(ActiavteAlt_1_1 = 0.0000000000);
  LogicalOperator1_1_1 = LogicalOperator2_1_1 or CompareToConstant2_1_1;
  LogicalOperator2_1_1 = not SRFlipFlopRepl_dot__LogicalOperator1_1_1;
  LogicalOperator3_1_1 = SRFlipFlopRepl_dot__LogicalOperator1_1_1 and LogicalOperator6_1_1;
  LogicalOperator4_1_1 = SRFlipFlopRepl_dot_1_LogicalOperator1_1_1 and LogicalOperator1_1_1;
  LogicalOperator6_1_1 = not(SRFlipFlopRepl_dot_1_LogicalOperator1_1_1 and CompareToConstant2_1_1);
  SRFlipFlopRepl_dot_1_LogicalOperator_1_1 = not(SRFlipFlopRepl_dot_1_UnitDelay_1_1 and SRFlipFlopRepl_dot_1_LogicalOperator3_1_1);
  SRFlipFlopRepl_dot_1_LogicalOperator1_1_1 = not(SRFlipFlopRepl_dot_1_LogicalOperator2_1_1 and SRFlipFlopRepl_dot_1_UnitDelay1_1_1);
  SRFlipFlopRepl_dot_1_LogicalOperator2_1_1 = not CompareToConstant3_1_1;
  SRFlipFlopRepl_dot_1_LogicalOperator3_1_1 = not CompareToConstant_1_1;
  SRFlipFlopRepl_dot_1_UnitDelay_1_1 = false -> pre SRFlipFlopRepl_dot_1_LogicalOperator1_1_1;
  SRFlipFlopRepl_dot_1_UnitDelay1_1_1 = true -> pre SRFlipFlopRepl_dot_1_LogicalOperator_1_1;
  SRFlipFlopRepl_dot__LogicalOperator_1_1 = not(SRFlipFlopRepl_dot__UnitDelay_1_1 and SRFlipFlopRepl_dot__LogicalOperator3_1_1);
  SRFlipFlopRepl_dot__LogicalOperator1_1_1 = not(SRFlipFlopRepl_dot__LogicalOperator2_1_1 and SRFlipFlopRepl_dot__UnitDelay1_1_1);
  SRFlipFlopRepl_dot__LogicalOperator2_1_1 = not CompareToConstant1_1_1;
  SRFlipFlopRepl_dot__LogicalOperator3_1_1 = not CompareToConstant_1_1;
  SRFlipFlopRepl_dot__UnitDelay_1_1 = false -> pre SRFlipFlopRepl_dot__LogicalOperator1_1_1;
  SRFlipFlopRepl_dot__UnitDelay1_1_1 = true -> pre SRFlipFlopRepl_dot__LogicalOperator_1_1;
  AltEng_1_1 = LogicalOperator4_1_1;
  FPAEng_2_1 = LogicalOperator3_1_1;
tel

node MODE_LOGIC (HeadMode_1_1 : real; ailStick_1_1 : real; elevStick_1_1 : real; AltMode_1_1 : real; FPAMode_1_1 : real; ATMode_1_1 : real; AltCmd_1_1 : real; Altitude_1_1 : real; CAS_1_1 : real; CASCmdMCP_1_1 : real; )
returns (HeadEng_1_1 : bool ;
  AltEng_2_1 : bool;
  FPAEng_3_1 : bool;
  ATEng_4_1 : bool;
  CASCmd_5_1 : real) ;

var
  AltAndFPAMode_1_1 : bool; AltAndFPAMode_2_1 : bool;
  CompareToZero_1_1 : bool;
  CompareToZero1_1_1 : bool;
  Constant_1_1 : real;
  HeadingMode_1_1 : bool;
  LogicalOperator_1_1 : bool;
  SpeedMode_1_1 : bool; SpeedMode_2_1 : real;
let 
  (AltAndFPAMode_1_1, AltAndFPAMode_2_1) = MODE_LOGIC_AltAndFPAMode(FPAMode_1_1, LogicalOperator_1_1, Altitude_1_1, AltCmd_1_1, AltMode_1_1);
  CompareToZero_1_1 = not(ailStick_1_1 = 0.0000000000);
  CompareToZero1_1_1 = not(elevStick_1_1 = 0.0000000000);
  Constant_1_1 = 0.0000000000;
  HeadingMode_1_1 = MODE_LOGIC_HeadingMode(HeadMode_1_1, LogicalOperator_1_1);
  LogicalOperator_1_1 = CompareToZero_1_1 or CompareToZero1_1_1;
  (SpeedMode_1_1, SpeedMode_2_1) = MODE_LOGIC_SpeedMode(ATMode_1_1, Constant_1_1, AltAndFPAMode_2_1, CAS_1_1, CASCmdMCP_1_1);
  HeadEng_1_1 = HeadingMode_1_1;
  AltEng_2_1 = AltAndFPAMode_1_1;
  FPAEng_3_1 = AltAndFPAMode_2_1;
  ATEng_4_1 = SpeedMode_1_1;
  CASCmd_5_1 = SpeedMode_2_1;
tel

node LONGITUDINAL_CONTROLLER_PitchInnerLoop_lookup1d_interpolate1d_sharp_2 (In1_1_1 : real; x1_1_1 : real; x2_1_1 : real; y1_1_1 : real; y2_1_1 : real; )
returns (Out1_1_1 : real) ;
var
  Add1_1_1 : real;
  Add2_1_1 : real;
  Add3_1_1 : real;
  Add4_1_1 : real;
  Divide_1_1 : real;
let 
  Add1_1_1 =  - x1_1_1 + x2_1_1;
  Add2_1_1 = Divide_1_1 + y1_1_1;
  Add3_1_1 =  - y1_1_1 + y2_1_1;
  Add4_1_1 = In1_1_1 - x1_1_1;
  -- Divide_1_1 = Add4_1_1 / Add1_1_1 * Add3_1_1;
  Divide_1_1 = times( divid(Add4_1_1, Add1_1_1), Add3_1_1 ) ;
  Out1_1_1 = Add2_1_1;
tel

node LONGITUDINAL_CONTROLLER_PitchInnerLoop_lookup1d_interpolate1d_sharp_1 (In1_1_1 : real; x1_1_1 : real; x2_1_1 : real; y1_1_1 : real; y2_1_1 : real; )
returns (Out1_1_1 : real) ;
var
  Add1_1_1 : real;
  Add2_1_1 : real;
  Add3_1_1 : real;
  Add4_1_1 : real;
  Divide_1_1 : real;
let 
  Add1_1_1 =  - x1_1_1 + x2_1_1;
  Add2_1_1 = Divide_1_1 + y1_1_1;
  Add3_1_1 =  - y1_1_1 + y2_1_1;
  Add4_1_1 = In1_1_1 - x1_1_1;
  -- Divide_1_1 = Add4_1_1 / Add1_1_1 * Add3_1_1;
  Divide_1_1 = times( divid(Add4_1_1, Add1_1_1), Add3_1_1 ) ;
  Out1_1_1 = Add2_1_1;
tel

node LONGITUDINAL_CONTROLLER_PitchInnerLoop_lookup1d_interpolate1d_sharp_0 (In1_1_1 : real; x1_1_1 : real; x2_1_1 : real; y1_1_1 : real; y2_1_1 : real; )
returns (Out1_1_1 : real) ;
var
  Add1_1_1 : real;
  Add2_1_1 : real;
  Add3_1_1 : real;
  Add4_1_1 : real;
  Divide_1_1 : real;
let 
  Add1_1_1 =  - x1_1_1 + x2_1_1;
  Add2_1_1 = Divide_1_1 + y1_1_1;
  Add3_1_1 =  - y1_1_1 + y2_1_1;
  Add4_1_1 = In1_1_1 - x1_1_1;
  -- Divide_1_1 = Add4_1_1 / Add1_1_1 * Add3_1_1;
  Divide_1_1 = times( divid(Add4_1_1, Add1_1_1), Add3_1_1 ) ;
  Out1_1_1 = Add2_1_1;
tel

node LONGITUDINAL_CONTROLLER_PitchInnerLoop_lookup1d (In1_1_1 : real; )
returns (Out1_1_1 : real) ;
var
  Add_1_1 : real;
  branch_sharp_1_1_1 : real;
  branch_sharp_2_1_1 : real;
  branch_sharp_3_1_1 : real;
  gte1_1_1 : bool;
  gte2_1_1 : bool;
  gte3_1_1 : bool;
  interpolate1d_sharp_0_1_1 : real;
  interpolate1d_sharp_1_1_1 : real;
  interpolate1d_sharp_2_1_1 : real;
  lte1_1_1 : bool;
  lte2_1_1 : bool;
  lte3_1_1 : bool;
  r1_1_1 : real;
  r2_1_1 : real;
  r3_1_1 : real;
  r4_1_1 : real;
  r5_1_1 : real;
  r6_1_1 : real;
  r7_1_1 : real;
  r8_1_1 : real;
let 
  Add_1_1 = branch_sharp_1_1_1 + branch_sharp_2_1_1 + branch_sharp_3_1_1;
  -- branch_sharp_1_1_1 = interpolate1d_sharp_0_1_1 * (if lte1_1_1 then 1.0 else 0.0) * (if gte1_1_1 then 1.0 else 0.0);
  branch_sharp_1_1_1 =
    if lte1_1_1 and gte1_1_1 then interpolate1d_sharp_0_1_1 else 0.0 ;
  -- branch_sharp_2_1_1 = interpolate1d_sharp_1_1_1 * (if lte2_1_1 then 1.0 else 0.0) * (if gte2_1_1 then 1.0 else 0.0);
  branch_sharp_2_1_1 =
    if lte2_1_1 and gte2_1_1 then interpolate1d_sharp_1_1_1 else 0.0 ;
  -- branch_sharp_3_1_1 = interpolate1d_sharp_2_1_1 * (if lte3_1_1 then 1.0 else 0.0) * (if gte3_1_1 then 1.0 else 0.0);
  branch_sharp_3_1_1 =
    if lte3_1_1 and gte3_1_1 then interpolate1d_sharp_2_1_1 else 0.0 ;
  gte1_1_1 = In1_1_1 <= r2_1_1;
  gte2_1_1 = In1_1_1 <= r3_1_1;
  gte3_1_1 = In1_1_1 <= r4_1_1;
  interpolate1d_sharp_0_1_1 = LONGITUDINAL_CONTROLLER_PitchInnerLoop_lookup1d_interpolate1d_sharp_0(In1_1_1, r1_1_1, r2_1_1, r5_1_1, r6_1_1);
  interpolate1d_sharp_1_1_1 = LONGITUDINAL_CONTROLLER_PitchInnerLoop_lookup1d_interpolate1d_sharp_1(In1_1_1, r2_1_1, r3_1_1, r6_1_1, r7_1_1);
  interpolate1d_sharp_2_1_1 = LONGITUDINAL_CONTROLLER_PitchInnerLoop_lookup1d_interpolate1d_sharp_2(In1_1_1, r3_1_1, r4_1_1, r7_1_1, r8_1_1);
  lte1_1_1 = In1_1_1 >= r1_1_1;
  lte2_1_1 = In1_1_1 > r2_1_1;
  lte3_1_1 = In1_1_1 > r3_1_1;
  r1_1_1 = 0.0000000000;
  r2_1_1 = 120.0000000000;
  r3_1_1 = 350.0000000000;
  r4_1_1 = 500.0000000000;
  r5_1_1 = 1.0000000000;
  r6_1_1 = 1.0000000000;
  r7_1_1 = 0.3000000000;
  r8_1_1 = 0.3000000000;
  Out1_1_1 = Add_1_1;
tel

node LONGITUDINAL_CONTROLLER_PitchInnerLoop_TransferFunc (u_1_1 : real; )
returns (y_1_1 : real) ;
var
  a_sharp_1_1_1 : real;
  b0_sharp_0_1_1 : real;
  b0_sharp_1_1_1 : real;
  delay_sharp_1_1_1 : real;
  output_sum_1_1 : real;
  sample_sharp_1_1_1 : real;
  sum11_1_1 : real;
  sum21_1_1 : real;
let 
  a_sharp_1_1_1 = 0.0625000000 * delay_sharp_1_1_1;
  b0_sharp_0_1_1 = 1.0000000000 * u_1_1;
  b0_sharp_1_1_1 = -1.0000000000 * a_sharp_1_1_1;
  delay_sharp_1_1_1 = 0.0000000000 -> pre sum21_1_1;
  output_sum_1_1 = b0_sharp_0_1_1 + b0_sharp_1_1_1;
  sample_sharp_1_1_1 = 0.0200000000 * sum11_1_1;
  sum11_1_1 = u_1_1 - a_sharp_1_1_1;
  sum21_1_1 = sample_sharp_1_1_1 + delay_sharp_1_1_1;
  y_1_1 = output_sum_1_1;
tel

node LONGITUDINAL_CONTROLLER_PitchInnerLoop (PitchCmd_1_1 : real; Pitch_1_1 : real; qdeg_1_1 : real; CAS_1_1 : real; )
returns (ElevCmd_1_1 : real) ;
var
  Kpitch_1_1 : real;
  Kwo_1_1 : real;
  Mux_1_1 : real; Mux_1_2 : real;
  Product_1_1 : real;
  Sum_1_1 : real;
  Sum1_1_1 : real;
  TransferFunc_1_1 : real;
  lookup1d_1_1 : real;
let 
  Kpitch_1_1 = 2.0000000000 * Sum_1_1;
  Kwo_1_1 = 0.5000000000 * TransferFunc_1_1;
  Mux_1_1 = PitchCmd_1_1 ;
  Mux_1_2 = Pitch_1_1 ;
  -- Product_1_1 = Sum1_1_1 * lookup1d_1_1 ;
  Product_1_1 = times(Sum1_1_1, lookup1d_1_1);
  Sum_1_1 = PitchCmd_1_1 - Pitch_1_1;
  Sum1_1_1 =  - Kpitch_1_1 + Kwo_1_1;
  TransferFunc_1_1 = LONGITUDINAL_CONTROLLER_PitchInnerLoop_TransferFunc(qdeg_1_1);
  lookup1d_1_1 = LONGITUDINAL_CONTROLLER_PitchInnerLoop_lookup1d(CAS_1_1);
  ElevCmd_1_1 = Product_1_1;
tel

node LONGITUDINAL_CONTROLLER_ManualOverride (Man_1_1 : real; Auto_1_1 : real; )
returns (Out_1_1 : real) ;
var
  Switch1_1_1 : real;
let 
  -- Switch1_1_1 = if not(Man_1_1 = 0.0) then Auto_1_1 else Man_1_1;
  Switch1_1_1 = if Man_1_1 <> 0.0 then Man_1_1 else Auto_1_1 ;
  Out_1_1 = Switch1_1_1;
tel

node LONGITUDINAL_CONTROLLER_FPAControl_integrator_reset (f_lpar_x_rpar__1_1 : real; reset_level_1_1 : bool; x0_1_1 : real; )
returns (F_lpar_x_rpar__1_1 : real) ;
var
  Add_1_1 : real;
  Constant_1_1 : real;
  Gain1_1_1 : real;
  Product_1_1 : real;
  Product1_1_1 : real;
  Product2_1_1 : real;
  Sum1_1_1 : real;
  Sum2_1_1 : real;
  Sum3_1_1 : real;
  Sum4_1_1 : real;
  delay_sharp_1_1_1 : real;
  delay_sharp_2_1_1 : real;
  delay_sharp_3_1_1 : bool;
  eq0_1_1 : bool;
  ne0_1_1 : bool;
  ne1_1_1 : bool;
  zero_1_1 : real;
let 
  Add_1_1 = Product1_1_1 + Product2_1_1;
  Constant_1_1 = 0.0000000000;
  Gain1_1_1 = 1.0000000000 * f_lpar_x_rpar__1_1;
  -- Actually linear {
  --   Product_1_1 = x0_1_1 * delay_sharp_1_1_1 ;
  -- }
  -- Product_1_1 = times(x0_1_1, delay_sharp_1_1_1) ;
  Product_1_1 = x0_1_1 -> 0.0 ;
  -- Product1_1_1 = Sum3_1_1 * (if ne0_1_1 then 1.0 else 0.0);
  Product1_1_1 = if ne0_1_1 then Sum3_1_1 else 0.0 ;
  -- Product2_1_1 = (if eq0_1_1 then 1.0 else 0.0) * Sum3_1_1 * (if ne1_1_1 then 1.0 else 0.0);
  Product2_1_1 = if eq0_1_1 and ne1_1_1 then Sum3_1_1 else 0.0 ;
  Sum1_1_1 = Gain1_1_1 + Sum2_1_1;
  Sum2_1_1 = Sum4_1_1 + Product_1_1;
  Sum3_1_1 =  - delay_sharp_2_1_1 + x0_1_1;
  Sum4_1_1 = delay_sharp_2_1_1 + Add_1_1;
  delay_sharp_1_1_1 = 1.0000000000 -> pre Constant_1_1;
  delay_sharp_2_1_1 = 0.0000000000 -> pre Sum1_1_1;
  delay_sharp_3_1_1 = false -> pre reset_level_1_1;
  eq0_1_1 = (if reset_level_1_1 then 1.0 else 0.0) = zero_1_1;
  ne0_1_1 = not((if reset_level_1_1 then 1.0 else 0.0) = zero_1_1);
  ne1_1_1 = not((if delay_sharp_3_1_1 then 1.0 else 0.0) = zero_1_1);
  zero_1_1 = 0.0000000000;
  F_lpar_x_rpar__1_1 = delay_sharp_2_1_1;
tel

node LONGITUDINAL_CONTROLLER_FPAControl_DynamicSaturation (up_1_1 : real; u_1_1 : real; lo_1_1 : real; )
returns (y1_1_1 : real) ;
var
  LowerRelop1_1_1 : bool;
  Switch_1_1 : real;
  Switch2_1_1 : real;
  UpperRelop_1_1 : bool;
let 
  LowerRelop1_1_1 = u_1_1 > up_1_1;
  Switch_1_1 = if UpperRelop_1_1 then lo_1_1 else u_1_1;
  Switch2_1_1 = if LowerRelop1_1_1 then up_1_1 else Switch_1_1;
  UpperRelop_1_1 = u_1_1 < lo_1_1;
  y1_1_1 = Switch2_1_1;
tel

node LONGITUDINAL_CONTROLLER_FPAControl (engage_1_1 : bool; gamcmd_1_1 : real; gamma_1_1 : real; thetadeg_1_1 : real; VT_1_1 : real; )
returns (PitchCmd_1_1 : real) ;

var
  DynamicSaturation_1_1 : real;
  KIgamerr_1_1 : real;
  Kgamerr_1_1 : real;
  LogicalOperator_1_1 : bool;
  Mux_1_1 : real; Mux_1_2 : real;
  Mux1_1_1 : real; Mux1_1_2 : real;
  Product1_1_1 : real;
  Sum_1_1 : real;
  Sum1_1_1 : real;
  Sum2_1_1 : real;
  -- hddLim1_1_1 : real;
  -- hddLim2_1_1 : real;
  -- hddLimProduct_1_1 : real;
  integrator_reset_1_1 : real;
  kt2fps_1_1 : real;
  m1_1_1 : real;
let 
  DynamicSaturation_1_1 = LONGITUDINAL_CONTROLLER_FPAControl_DynamicSaturation(Product1_1_1, KIgamerr_1_1, m1_1_1);
  KIgamerr_1_1 = 1.0000000000 * Sum2_1_1 ;
  Kgamerr_1_1 = 1.4000000000 * gamma_1_1;
  LogicalOperator_1_1 = not engage_1_1;
  Mux_1_1 = gamcmd_1_1 ;
  Mux_1_2 = gamma_1_1 ;
  Mux1_1_1 = Sum2_1_1 ;
  Mux1_1_2 = DynamicSaturation_1_1 ;
  -- Original code, actually linear {
  --   hddLim1_1_1 = 4.8300000000;
  --   hddLim2_1_1 = 57.2958000000;
  --   hddLimProduct_1_1 = hddLim1_1_1 * hddLim2_1_1;
  --   Product1_1_1 = hddLimProduct_1_1 * kt2fps_1_1;
  -- }
  -- Abstraction, useless as it's linear {
  --   hddLim1_1_1 = 4.8300000000;
  --   hddLim2_1_1 = 57.2958000000;
  --   hddLimProduct_1_1 = times(hddLim1_1_1, hddLim2_1_1) ;
  --   Product1_1_1 = times(hddLimProduct_1_1, kt2fps_1_1) ;
  -- }
  -- Instead we just do {
  Product1_1_1 = (4.83 * 57.2958) * kt2fps_1_1 ;
  -- }
  Sum_1_1 = thetadeg_1_1 + Kgamerr_1_1;
  Sum1_1_1 = integrator_reset_1_1 - Kgamerr_1_1;
  Sum2_1_1 = gamcmd_1_1 - gamma_1_1;
  integrator_reset_1_1 = LONGITUDINAL_CONTROLLER_FPAControl_integrator_reset(DynamicSaturation_1_1, LogicalOperator_1_1, Sum_1_1);
  kt2fps_1_1 = 1.6878000000 * VT_1_1;
  m1_1_1 = -1.0000000000 * Product1_1_1;
  PitchCmd_1_1 = Sum1_1_1;
tel

node LONGITUDINAL_CONTROLLER_EngageORzero (Engage_1_1 : bool; In_1_1 : real; )
returns (Out_1_1 : real) ;
var
  LogicalOperator5_1_1 : bool;
  Switch1_1_1 : real;
  zero10_1_1 : real;
  zero9_1_1 : real;
let 
  LogicalOperator5_1_1 = Engage_1_1 and (if zero10_1_1 = 0.0 then false else true);
  Switch1_1_1 = if (if LogicalOperator5_1_1 then 1.0 else 0.0) >= 0.5000000000 then In_1_1 else zero9_1_1;
  zero10_1_1 = 1.0000000000;
  zero9_1_1 = 0.0000000000;
  Out_1_1 = Switch1_1_1;
tel

node LONGITUDINAL_CONTROLLER_AltitudeControl_VariableLimitSaturation (up_lim_1_1 : real; SigIn_1_1 : real; Lo_lim_1_1 : real; )
returns (Out1_1_1 : real) ;
var
  Enforcelowlim_1_1 : real;
  Enforceuplim_1_1 : real;
let 
  Enforcelowlim_1_1 = if Lo_lim_1_1 >= SigIn_1_1 then Lo_lim_1_1 else SigIn_1_1;
  Enforceuplim_1_1 = if Enforcelowlim_1_1 <= up_lim_1_1 then Enforcelowlim_1_1 else up_lim_1_1;
  Out1_1_1 = Enforceuplim_1_1;
tel

node LONGITUDINAL_CONTROLLER_AltitudeControl_VariableRateLimit_VariableLimitSaturation (up_lim_1_1 : real; SigIn_1_1 : real; Lo_lim_1_1 : real; )
returns (Out1_1_1 : real) ;
var
  Enforcelowlim_1_1 : real;
  Enforceuplim_1_1 : real;
let 
  Enforcelowlim_1_1 = if Lo_lim_1_1 >= SigIn_1_1 then Lo_lim_1_1 else SigIn_1_1;
  Enforceuplim_1_1 = if Enforcelowlim_1_1 <= up_lim_1_1 then Enforcelowlim_1_1 else up_lim_1_1;
  Out1_1_1 = Enforceuplim_1_1;
tel

node LONGITUDINAL_CONTROLLER_AltitudeControl_VariableRateLimit (ratelim_1_1 : real; input_1_1 : real; ICtrig_1_1 : bool; IC_1_1 : real; )
returns (output_1_1 : real) ;

(* This holds. *)
(*
--@var clamped = clamp(
  -ratelim_1_1, 20.0 * (input_1_1 - output_1_1), ratelim_1_1
) ;

--require ratelim_1_1 = 3.2 ;
--require ICtrig_1_1 => input_1_1 = 0.0 ;

--mode no_ic_trig ;
--require not ICtrig_1_1 ;

--mode ic_trig_init ;
--require ICtrig_1_1 and (true -> not pre ICtrig_1_1) ;

--mode ic_trig ;
--require false -> ICtrig_1_1 and pre ICtrig_1_1 ;
--ensure true -> duration(true) >= 3 => output_1_1 <=  3.2 + pre IC_1_1 ;
--ensure true -> duration(true) >= 3 => output_1_1 >= -3.2 + pre IC_1_1 ;
--ensure true -> (
  (duration(true) = 2 and pre ICtrig_1_1) => output_1_1 = 2.0 * pre IC_1_1
) ;
*)

var
  Gain_1_1 : real;
  Gain1_1_1 : real;
  Sum2_1_1 : real;
  VariableLimitSaturation_1_1 : real;
  integrator_reset_Add_1_1 : real;
  integrator_reset_Constant_1_1 : real;
  integrator_reset_Gain1Reset_1_1 : real;
  integrator_reset_Product_1_1 : real;
  integrator_reset_Product1_1_1 : real;
  integrator_reset_Product2_1_1 : real;
  integrator_reset_Sum1_1_1 : real;
  integrator_reset_Sum2Reset_1_1 : real;
  integrator_reset_Sum3_1_1 : real;
  integrator_reset_Sum4_1_1 : real;
  integrator_reset_delay_sharp_1_1_1 : real;
  integrator_reset_delay_sharp_2_1_1 : real;
  integrator_reset_delay_sharp_3_1_1 : bool;
  integrator_reset_eq0_1_1 : bool;
  integrator_reset_ne0_1_1 : bool;
  integrator_reset_ne1_1_1 : bool;
  integrator_reset_zero_1_1 : real;
let 
  Gain_1_1 = 20.0000000000 * Sum2_1_1;
  Gain1_1_1 = -1.0000000000 * ratelim_1_1;
  Sum2_1_1 = input_1_1 - integrator_reset_delay_sharp_2_1_1;
  VariableLimitSaturation_1_1 = LONGITUDINAL_CONTROLLER_AltitudeControl_VariableRateLimit_VariableLimitSaturation(ratelim_1_1, Gain_1_1, Gain1_1_1);
  integrator_reset_Add_1_1 = integrator_reset_Product1_1_1 + integrator_reset_Product2_1_1;
  integrator_reset_Constant_1_1 = 0.0000000000;
  integrator_reset_Gain1Reset_1_1 = 1.0000000000 * VariableLimitSaturation_1_1;
  -- integrator_reset_Product_1_1 = IC_1_1 * integrator_reset_delay_sharp_1_1_1;
  integrator_reset_Product_1_1 = IC_1_1 -> 0.0 ;
  -- integrator_reset_Product1_1_1 = integrator_reset_Sum3_1_1 * (if integrator_reset_ne0_1_1 then 1.0 else 0.0);
  integrator_reset_Product1_1_1 =
    if integrator_reset_ne0_1_1 then integrator_reset_Sum3_1_1 else 0.0 ;
  -- integrator_reset_Product2_1_1 = (if integrator_reset_eq0_1_1 then 1.0 else 0.0) * integrator_reset_Sum3_1_1 * (if integrator_reset_ne1_1_1 then 1.0 else 0.0);
  integrator_reset_Product2_1_1 =
    if integrator_reset_eq0_1_1 and integrator_reset_ne1_1_1
    then integrator_reset_Sum3_1_1 else 0.0 ;
  integrator_reset_Sum1_1_1 = integrator_reset_Gain1Reset_1_1 + integrator_reset_Sum2Reset_1_1;
  integrator_reset_Sum2Reset_1_1 = integrator_reset_Sum4_1_1 + integrator_reset_Product_1_1;
  integrator_reset_Sum3_1_1 =  - integrator_reset_delay_sharp_2_1_1 + IC_1_1;
  integrator_reset_Sum4_1_1 = integrator_reset_delay_sharp_2_1_1 + integrator_reset_Add_1_1;
  integrator_reset_delay_sharp_1_1_1 = 1.0000000000 -> pre integrator_reset_Constant_1_1;
  integrator_reset_delay_sharp_2_1_1 = 0.0000000000 -> pre integrator_reset_Sum1_1_1;
  integrator_reset_delay_sharp_3_1_1 = false -> pre ICtrig_1_1;
  integrator_reset_eq0_1_1 = (if ICtrig_1_1 then 1.0 else 0.0) = integrator_reset_zero_1_1;
  integrator_reset_ne0_1_1 = not((if ICtrig_1_1 then 1.0 else 0.0) = integrator_reset_zero_1_1);
  integrator_reset_ne1_1_1 = not((if integrator_reset_delay_sharp_3_1_1 then 1.0 else 0.0) = integrator_reset_zero_1_1);
  integrator_reset_zero_1_1 = 0.0000000000;
  output_1_1 = integrator_reset_delay_sharp_2_1_1;
tel

node LONGITUDINAL_CONTROLLER_AltitudeControl_Saturation1 (SigIn_1_1 : real; )
returns (Out1_1_1 : real) ;
var
  Constant1_1_1 : real;
  Constant2_1_1 : real;
  Enforcelowlim_1_1 : real;
  Enforceuplim_1_1 : real;
let 
  Constant1_1_1 = 0.0001000000;
  Constant2_1_1 = 1000.0000000000;
  Enforcelowlim_1_1 = if Constant1_1_1 >= SigIn_1_1 then Constant1_1_1 else SigIn_1_1;
  Enforceuplim_1_1 = if Enforcelowlim_1_1 <= Constant2_1_1 then Enforcelowlim_1_1 else Constant2_1_1;
  Out1_1_1 = Enforceuplim_1_1;
tel

node LONGITUDINAL_CONTROLLER_AltitudeControl (engage_1_1 : bool; AltCmd_1_1 : real; Altitude_1_1 : real; gskts_1_1 : real; hdot_1_1 : real; )
returns (altgamcmd_1_1 : real) ;

var
  Abs_1_1 : real;
  Constant1_1_1 : real;
  Constant3_1_1 : real;
  Constant4_1_1 : real;
  Divide_1_1 : real;
  Kh_1_1 : real;
  LogicalOperator_1_1 : bool;
  Mux_1_1 : real; Mux_1_2 : real;
  Mux1_1_1 : real; Mux1_1_2 : real;
  Saturation1_1_1 : real;
  Sum_1_1 : real;
  Sum3_1_1 : real;
  Switch_1_1 : real;
  VariableRateLimit_1_1 : real;
  VariableLimitSaturation_1_1 : real;
  k_1_1 : real;
  kts2fps_1_1 : real;
  r2d_1_1 : real;
let 
  Abs_1_1 = if hdot_1_1 >= 0.0 then hdot_1_1 else -hdot_1_1;
  Constant1_1_1 = 0.0000000000;
  Constant3_1_1 = 10.0000000000;
  Constant4_1_1 = 3.2000000000;
  -- Divide_1_1 = VariableRateLimit_1_1 / Saturation1_1_1;
  -- Divide_1_1 = temporal_divid(VariableRateLimit_1_1, Saturation1_1_1);
  -- Divide_1_1 = divid_fun(VariableRateLimit_1_1, Saturation1_1_1);
  Divide_1_1 = if gskts_1_1 >= 100.0 then divid_bounded_num(
    VariableRateLimit_1_1,
    if gskts_1_1 < 100.0 then 200.0 else Saturation1_1_1,
    168.78,
    1000.0
  ) else divid_bounded_num(
    VariableRateLimit_1_1, Saturation1_1_1, 0.0001, 1000.0
  ) ;
  Kh_1_1 = 0.0800000000 * Sum_1_1;
  LogicalOperator_1_1 = not engage_1_1;
  Mux_1_1 = AltCmd_1_1 ;
  Mux_1_2 = Altitude_1_1 ;
  Mux1_1_1 = VariableLimitSaturation_1_1 ;
  Mux1_1_2 = VariableRateLimit_1_1 ;
  Saturation1_1_1 = LONGITUDINAL_CONTROLLER_AltitudeControl_Saturation1(kts2fps_1_1);
  Sum_1_1 = AltCmd_1_1 - Altitude_1_1;
  Sum3_1_1 = Abs_1_1 + Constant3_1_1;
  (* |===| Bug, >= should be >. *)
  -- Switch_1_1 = if (if engage_1_1 then 1.0 else 0.0) >= 0.0000000000 then Kh_1_1 else Constant1_1_1;
  Switch_1_1 = if engage_1_1 then Kh_1_1 else Constant1_1_1 ;
  VariableRateLimit_1_1 = LONGITUDINAL_CONTROLLER_AltitudeControl_VariableRateLimit(Constant4_1_1, VariableLimitSaturation_1_1, LogicalOperator_1_1, hdot_1_1);
  VariableLimitSaturation_1_1 = LONGITUDINAL_CONTROLLER_AltitudeControl_VariableLimitSaturation(Sum3_1_1, Switch_1_1, k_1_1);
  k_1_1 = -1.0000000000 * Sum3_1_1;
  kts2fps_1_1 = 1.6878000000 * gskts_1_1;
  r2d_1_1 = 57.2958000000 * Divide_1_1;
  altgamcmd_1_1 = r2d_1_1;
tel

node LONGITUDINAL_CONTROLLER (FPACmd_1_1 : real; AltEng_1_1 : bool; FpaEng_1_1 : bool; AltCmd_1_1 : real; Alt_1_1 : real; thetaDeg_1_1 : real; qDeg_1_1 : real; GsKts_1_1 : real; hdot_1_1 : real; VT_1_1 : real; Gamma_1_1 : real; CAS_1_1 : real; ElevStick_1_1 : real; )
returns (alt_cmd_out, pitch_cmd_out, ElevCmd_1_1 : real) ;

var
  AltitudeControl_1_1 : real;
  EngageORzero_1_1 : real;
  FPAControl_1_1 : real;
  LogicalOperator_1_1 : bool;
  ManualOverride_1_1 : real;
  PitchInnerLoop_1_1 : real;
  Sum7_1_1 : real;
  act_cmd_ge_cmd, alt_out_loc_pos : bool ;
  k2_1_1 : real;
  k5_1_1 : real;
let 
  AltitudeControl_1_1 = LONGITUDINAL_CONTROLLER_AltitudeControl(AltEng_1_1, AltCmd_1_1, Alt_1_1, GsKts_1_1, hdot_1_1);
  EngageORzero_1_1 = LONGITUDINAL_CONTROLLER_EngageORzero(LogicalOperator_1_1, PitchInnerLoop_1_1);
  FPAControl_1_1 = LONGITUDINAL_CONTROLLER_FPAControl(FpaEng_1_1, Sum7_1_1, Gamma_1_1, thetaDeg_1_1, VT_1_1);
  LogicalOperator_1_1 = AltEng_1_1 or FpaEng_1_1;
  ManualOverride_1_1 = LONGITUDINAL_CONTROLLER_ManualOverride(ElevStick_1_1, EngageORzero_1_1);
  PitchInnerLoop_1_1 = LONGITUDINAL_CONTROLLER_PitchInnerLoop(k5_1_1, thetaDeg_1_1, qDeg_1_1, CAS_1_1);
  Sum7_1_1 = FPACmd_1_1 + k2_1_1;
  act_cmd_ge_cmd = Sum7_1_1 >= FPACmd_1_1 ;
  alt_out_loc_pos = k2_1_1 >= 0.0 ;
  k2_1_1 = 1.0000000000 * AltitudeControl_1_1;
  k5_1_1 = 1.0000000000 * FPAControl_1_1;
  ElevCmd_1_1 = ManualOverride_1_1;
  pitch_cmd_out = if act_cmd_ge_cmd or not act_cmd_ge_cmd then
    if alt_out_loc_pos or not alt_out_loc_pos then FPAControl_1_1 else 0.0
    else 0.0 ;
  alt_cmd_out = AltitudeControl_1_1 ;
tel

node Mode_plus_Longitudinal (
  head_mode : real ;
  ail_stick_in : real ;
  elev_stick_in : real ;
  -- Altitude mode.
  alt_mode : real ;
  -- Flight Path Angle mode.
  fpa_mode : real ;
  -- Auto Throttle mode.
  at_mode : real ;
  alt_cmd_in : real ;
  alt_in : real ;
  cas_in : real ;
  cas_cmd : real ;
  pitch_in : real ;
  qbdegf_1_1 : real ;
  gskts_in : real ;
  hdot_in : real ;
  speed_in : real ;
  fpa_in : real ;
  fpa_cmd_in : real ;
) returns (
  head_eng_out, alt_eng_out, at_eng_out, fpa_eng_out : bool ;
  cas_cmd_out, alt_cmd_out, pitch_cmd_out, elev_cmd_out : real ;
) ;

(*@contract
  import logic_longitudinal (
    head_mode <> 0.0, alt_mode <> 0.0, fpa_mode <> 0.0,
    alt_in, alt_cmd_in, hdot_in,
    fpa_in, fpa_cmd_in,
    pitch_in,
    speed_in,
    gskts_in,
    cas_in,
    elev_stick_in,
    ail_stick_in
  ) returns (
    head_eng_out, alt_eng_out, fpa_eng_out,
    alt_cmd_out, pitch_cmd_out, elev_cmd_out
  ) ;
*)

let 
  (
    head_eng_out,
    alt_eng_out,
    fpa_eng_out,
    at_eng_out,
    cas_cmd_out
  ) = MODE_LOGIC(
    head_mode,
    ail_stick_in,
    elev_stick_in,
    alt_mode,
    fpa_mode,
    at_mode,
    alt_cmd_in,
    alt_in,
    cas_in,
    cas_cmd
  );

  assert fall(alt_eng_out) => not fpa_eng_out ;

  (alt_cmd_out, pitch_cmd_out, elev_cmd_out) = LONGITUDINAL_CONTROLLER(
    fpa_cmd_in,
    alt_eng_out,
    fpa_eng_out,
    alt_cmd_in,
    alt_in,
    pitch_in,
    qbdegf_1_1,
    gskts_in,
    hdot_in,
    speed_in,
    fpa_in,
    cas_in,
    elev_stick_in
  );

tel

