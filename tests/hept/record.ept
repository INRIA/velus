type point = {
    x : int;
    y : int
}

node mkpoint(x, y : int) returns (p : point)
let
    p = { x = x; y = y }
tel

const p1 : point = { x = 1; y = 2 }
const p2 : point = { y = 4; x = 3 }

node p1_or_p2(b : bool) returns (p : point)
let
    p = if b then p1 else p2
tel

node distr(b : bool) returns (z : int)
let
    z = (if b then p1 else p2).x
tel

node distr2(b : bool) returns (z : int)
let
    z = (p1 fby p2).y
tel

type t = A | B | C

node distr_merge(b : t) returns (y : int)
let
    y = (merge b (A -> p1) (B -> p2) (C -> p1)).y;
tel

node copy_point(p1 : point) returns (p2 : point)
let
    p2 = p1
tel

node add(p1, p2 : point) returns (p3 : point)
let
    p3 = { x = p1.x + p2.x; y = p1.y + p2.y }
tel

type segment = {
    p1 : point;
    p2 : point
}

const s : segment = { p1 = p1; p2 = p2 }

node s_x2(s : segment) returns (o : int)
let
    o = s.p2.x;
tel

node update_s_x2(x2 : int) returns (s1 : segment)
let
    s1 = { s with .p2 = { s.p2 with .x = x2 } }
tel
