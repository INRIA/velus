(* Lustre examples from "Synchronous Programming of Reactive Systems",
   Nicolas Halbwachs, 1993 Kluwer Academic Publishers. *)

node counter(init_value, incr_value: int; vreset: bool)
   returns (n: int);
let
   n = init_value -> 
       (if vreset then init_value else (0 fby n));
tel

node watchdog1(set, vreset, deadline: bool)
   returns (alarm: bool);
var watchdog_is_on: bool;
let
   alarm = deadline and watchdog_is_on;
   watchdog_is_on = false -> (if set then true
                              else if vreset then false
                              else (false fby watchdog_is_on));
   assert not(set and vreset);
tel

node edge(b: bool) returns (edge: bool);
let
   edge = false -> (b and not (false fby b));
tel

node watchdog2(set, vreset: bool; delay: int)
   returns (alarm: bool);
var remaining_delay: int; deadline: bool;
let
   alarm = watchdog1(set, vreset, deadline);
   deadline = edge(remaining_delay = 0);
   remaining_delay = if set then delay else
                     (0 -> (0 fby remaining_delay) - 1);
tel

-- node watchdog3(set, vreset, time_unit: bool;
--                 delay: int)
--    returns (alarm: bool);
-- var clock: bool; let
--    alarm = current(watchdog2
--                ((set, vreset, delay) when clock));
--    clock = true -> set or vreset or time_unit;
-- tel

node simple_stopwatch (start_stop, vreset, hs: bool)
   returns (time: int; running: bool);
let
  time = 0 -> (if hs and running then (0 fby time) + 1
               else if vreset then 0 else (0 fby time));
  running = false -> (if start_stop then
                      not (false fby running)
                      else (false fby running));
tel

-- node stopwatch (start_stop, vreset, hs: bool)
--    returns (displayed_time: int; running, frozen: bool);
-- var internal_time: int; actual_reset: bool;
-- let
--   frozen = false ->
--               (if vreset and pre(running) then true
--                else if vreset and pre(frozen) then false
--                else pre(frozen));
--   displayed_time =
--            current(internal_time when not frozen);
--   (internal_time, running) =
--       simple_stopwatch(start_stop, actual_reset, hs);
--   actual_reset =
--       vreset and pre(not running and not frozen);
-- tel

-- node switch_1(on, off, init: bool) returns (state: bool);
-- let
--    state = init -> if on then true
--                    else if off then false
--                    else pre(state);
-- tel

-- node switch(on, off, init: bool) returns (state: bool);
-- let
--    state = init -> if on and not pre(state) then true
--                    else if off and pre(state) then false
--                    else pre(state);
-- tel

-- node compare(on, off, init: bool) returns (ok: bool);
-- var state, state_1 : bool;
-- let
--    state = switch(on, off, init);
--    state_1 = switch_1(on, off, init);
--    ok = (state = state_1);
--    assert not(on and off);
-- tel

